/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/isteps/istep06/host_discover_targets.C $              */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2015,2020                        */
/* [+] Google Inc.                                                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include <stdint.h>
#include <map>
#include <vector>
#include <trace/interface.H>
#include <sys/misc.h>
#include <errl/errlentry.H>
#include <errl/errlmanager.H>
#include <errl/errludtarget.H>
#include <targeting/attrsync.H>
#include <targeting/namedtarget.H>
#include <targeting/common/utilFilter.H>
#include <targeting/common/commontargeting.H>
#include <targeting/common/mfgFlagAccessors.H>
#include <targeting/common/entitypath.H>
#include <initservice/taskargs.H>
#include <initservice/isteps_trace.H>
#include <initservice/initserviceif.H>
#include <isteps/hwpisteperror.H>
#include <istepHelperFuncs.H>
#include <initservice/isteps_trace.H>
#include <hwas/common/hwas.H>
#include <hwas/common/hwasCommon.H>
#include <hwas/common/hwas_reasoncodes.H>
#include <hwas/hwasPlat.H>
#include <vpd/vpd_if.H>
#include <console/consoleif.H>
#include <attributetraits.H>
#ifdef CONFIG_PLDM
#include <pldm/extended/pdr_manager.H>
#include <pldm/extended/hb_fru.H>
#include <pldm/extended/pldm_entity_ids.H>
#endif
#include <fapi2/plat_hwp_invoker.H>
#include <fapi2/target.H>
#include <eeprom/eepromCache.H>
#include <runtime/customize_attrs_for_payload.H>

//SBE interfacing
#include <sbeio/sbeioif.H>
#include <sys/misc.h>
#include <sbe/sbeif.H>

// FIXME RTC: 208841 MPIPL support
//#include <p9_query_core_access_state.H>
#include <p10_setup_sbe_config.H>
//#include <p9_query_cache_access_state.H>
//#include <p9_hcd_core_stopclocks.H>
//#include <p9_hcd_cache_stopclocks.H>
//#include <p9_hcd_common.H>
//#include <p9_quad_power_off.H>
//#include <p9_perv_scom_addresses.H>

#ifdef CONFIG_PRINT_SYSTEM_INFO
#include <stdio.h>
#endif

//  HWP call support
#include <nest/nestHwpHelperFuncs.H>   // fapiHWPCallWrapperHandler


namespace ISTEP_06
{

#ifdef CONFIG_PRINT_SYSTEM_INFO

//Loop through list of targets and print out HUID and other key attributes if
//the target has it
void print_target_list(TARGETING::TargetHandleList i_targetList)
{

    for(auto & l_targ : i_targetList)
    {
        char * l_targetString =
        l_targ->getAttr<TARGETING::ATTR_PHYS_PATH>().toString();

        TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace, "%s", l_targetString);

        free(l_targetString);

        //Every target has a HUID so it is safe to assume this will return okay
        //from getAttr
        uint32_t l_huid =  get_huid(l_targ );

        //if output says DEAD then the attribute is not defined
        uint32_t l_isFunc = 0xDEAD;
        uint32_t l_isPres = 0xDEAD;
        uint32_t l_pos = 0xDEAD;
        uint32_t l_fapi_pos = 0xDEAD;
        uint32_t l_chip_unit = 0xDEAD;

        //The rest of these attributes may or may not exist on the target, so
        //only add them to the string if the attribute exists
        TARGETING::AttributeTraits<TARGETING::ATTR_HWAS_STATE>::Type hwasState;
        if(l_targ->tryGetAttr<TARGETING::ATTR_HWAS_STATE>(hwasState))
        {
            l_isFunc = hwasState.functional;
            l_isPres = hwasState.present;
        }

        TARGETING::AttributeTraits<TARGETING::ATTR_POSITION>::Type position;
        if(l_targ->tryGetAttr<TARGETING::ATTR_POSITION>(position))
        {
            l_pos = position;
        }

        TARGETING::AttributeTraits<TARGETING::ATTR_FAPI_POS>::Type fapi_position;
        if(l_targ->tryGetAttr<TARGETING::ATTR_FAPI_POS>(fapi_position))
        {
            l_fapi_pos = fapi_position;
        }

        TARGETING::AttributeTraits<TARGETING::ATTR_CHIP_UNIT>::Type chip_unit;
        if(l_targ->tryGetAttr<TARGETING::ATTR_CHIP_UNIT>(chip_unit))
        {
            l_chip_unit = chip_unit;
        }

        //Trace out the string
        TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace,"HUID:0x%x   Functional: 0x%x   Present: 0x%x      Position: 0x%x     FAPI_POS: 0x%x     Chip Unit: 0x%x",
                                                     l_huid,      l_isFunc,          l_isPres,          l_pos,             l_fapi_pos,        l_chip_unit);

    }
}

//Debugging tool used to print out target information early on in IPL
void print_system_info(void)
{
    //Vector of target types you want to print out
    std::vector<TARGETING::AttributeTraits<TARGETING::ATTR_TYPE>::Type> types_to_print;

    //Add all the target types that you want to see in the output to this vector
    types_to_print.push_back(TARGETING::TYPE_PROC);
    types_to_print.push_back(TARGETING::TYPE_DIMM);
    types_to_print.push_back(TARGETING::TYPE_CORE);
    types_to_print.push_back(TARGETING::TYPE_MC);
    types_to_print.push_back(TARGETING::TYPE_MI);
    types_to_print.push_back(TARGETING::TYPE_MCC);
    types_to_print.push_back(TARGETING::TYPE_OCMB_CHIP);

    //Loop through each type to get a list of targets then print it out
    for(auto l_type : types_to_print)
    {
        TARGETING::PredicateCTM l_CtmFilter(TARGETING::CLASS_NA,
                                            l_type,
                                            TARGETING::MODEL_NA);

        // Apply the filter through all targets
        TARGETING::TargetRangeFilter l_targetList(TARGETING::targetService().begin(),
                                                  TARGETING::targetService().end(),
                                                  &l_CtmFilter);

        TARGETING::TargetHandleList l_allTargets;

        for ( ; l_targetList; ++l_targetList)
        {
            l_allTargets.push_back(*l_targetList);
        }

        print_target_list(l_allTargets);
    }

}
#endif


/**
*  @brief  Walk through list of PROC chip targets and send a continueMPIPL
*          FIFO chip-op to all of the slave PROC chips
*
*  @return     errlHndl_t
*/
errlHndl_t sendContinueMpiplChipOp()
{
    errlHndl_t l_err = nullptr;

    TARGETING::TargetHandleList l_procChips;
    TARGETING::getAllChips(l_procChips, TARGETING::TYPE_PROC, true);
    TARGETING::PROC_SBE_MASTER_CHIP_ATTR l_is_master_chip = 1;

    for(const auto & l_chip : l_procChips)
    {
        l_is_master_chip = l_chip->getAttr<TARGETING::ATTR_PROC_SBE_MASTER_CHIP>();
        if(!l_is_master_chip)
        {
            l_err = SBEIO::sendContinueMpiplRequest(l_chip);

            if(l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Failed sending continueMPIPL request on this proc = %x",
                          l_chip->getAttr<TARGETING::ATTR_HUID>());
                break;
            }
        }
    }
    return l_err;
}

/**
*  @brief  Walk through list of PROC chip targets and run p9_setup_sbe_config
*          HWP on all of the slave PROC chips to ensure scratch regs are updated
*
*  @return     errlHndl_t
*/
errlHndl_t updateSlaveSbeScratchRegs()
{
    errlHndl_t l_err = nullptr;
/* FIXME RTC: 215162
    TARGETING::TargetHandleList l_procChips;
    TARGETING::getAllChips(l_procChips, TARGETING::TYPE_PROC, true);
    TARGETING::PROC_SBE_MASTER_CHIP_ATTR l_is_master_chip = 1;

    for(const auto & l_chip : l_procChips)
    {
        l_is_master_chip = l_chip->getAttr<TARGETING::ATTR_PROC_SBE_MASTER_CHIP>();
        if(!l_is_master_chip)
        {
            fapi2::Target <fapi2::TARGET_TYPE_PROC_CHIP> l_fapi_proc_target (l_chip);
            // Run the setup_sbe_config hwp on all of the slave procs to make sure
            // the scratch registers are up to date prior to sending the continueMPIPL
            // operation
            FAPI_INVOKE_HWP(l_err,
                            p9_setup_sbe_config,
                            l_fapi_proc_target);

            if(l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Failed during updateSlaveSbeScratchRegs request on this proc = %x",
                          l_chip->getAttr<TARGETING::ATTR_HUID>());
                break;
            }
        }
    }
*/
    return l_err;
}


/**
*  @brief  loop through slave quads, make sure clocks are stopped
*          (core and cache) and power them down
*
*  @return     errlHndl_t
*/
errlHndl_t powerDownSlaveQuads()
{
    errlHndl_t l_err = NULL;
/* FIXME RTC: 208841
    TARGETING::Target* l_sys_target = nullptr;
    TARGETING::targetService().getTopLevelTarget(l_sys_target);

    bool l_isMasterEq = false;
    bool l_masterFound = false;
    //Need to know who master is so we can skip them
    uint8_t l_masterCoreId = TARGETING::getMasterCore()->getAttr<TARGETING::ATTR_CHIP_UNIT>();

    TARGETING::TargetHandleList l_eqTargetList;
    getAllChiplets(l_eqTargetList, TARGETING::TYPE_EQ, true);

    TARGETING::TargetHandleList l_procChips;
    TARGETING::getAllChips(l_procChips, TARGETING::TYPE_PROC, true);

    //Loop through EQs
    for(const auto & l_eq_target : l_eqTargetList)
    {
        l_isMasterEq = false;
        fapi2::Target <fapi2::TARGET_TYPE_EQ> l_fapi_eq_target (l_eq_target);
        fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP> l_chip =
            l_fapi_eq_target.getParent<fapi2::TARGET_TYPE_PROC_CHIP>();

        TARGETING::ATTR_PROC_SBE_MASTER_CHIP_type l_is_master_chip;
        FAPI_ATTR_GET(fapi2::ATTR_PROC_SBE_MASTER_CHIP, l_chip, l_is_master_chip);

        TARGETING::TargetHandleList l_coreTargetList;
        TARGETING::getChildChiplets( l_coreTargetList,
                                     l_eq_target,
                                     TARGETING::TYPE_CORE,
                                     true);
        //If this ex is on the master processor and we have not found the master ex yet
        //Check if either of the cores is master (probably could just check the first)
        if (l_is_master_chip == fapi2::ENUM_ATTR_PROC_SBE_MASTER_CHIP_TRUE && !l_masterFound)
        {
            for(const auto & l_core_target : l_coreTargetList)
            {
                if(l_core_target->getAttr<TARGETING::ATTR_CHIP_UNIT>() == l_masterCoreId)
                {
                    l_isMasterEq = true;
                    break;
                }
            }
            //If this is the master quad, we have already power cycled so we dont need this
            if(l_isMasterEq)
            {
                //continue to next EQ
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Found and prepped master, jumping to next EQ");
                l_masterFound = true;
                continue;
            }
        }

        //Stop Clocks on all the cores
        for(const auto & l_core_target : l_coreTargetList)
        {
            fapi2::Target <fapi2::TARGET_TYPE_CORE> l_fapi_core_target (l_core_target);
            bool l_isScomable = false;
            bool l_isScanable = false;
            //Check if the core target has clocks running
            FAPI_INVOKE_HWP(l_err,
                            p9_query_core_access_state,
                            l_fapi_core_target,
                            l_isScomable,
                            l_isScanable);
            if(l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Error reading core state for core %d", l_core_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                //Break out of core for-loop
                break;
            }

            //If clocks are running (IE is scommable) then stop them
            if(l_isScomable)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Stopping core %d", l_core_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                FAPI_INVOKE_HWP(l_err,
                                p9_hcd_core_stopclocks,
                                l_fapi_core_target);
                if(l_err)
                {
                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                              "Error stopping clocks on core %d", l_core_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                    //Break out of core for-loop
                    break;
                }
            }
            else
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Core %d is not scommable according to query", l_core_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
            }
        }

        if(l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      "An error occurred while attempting to stop clocks on the core, skipping attempt to stop cache and returning error");
            //Break out of EQ for-loop
            break;
        }


        do
        {
            bool l_l2IsScanable[MAX_L2_PER_QUAD];
            bool l_l2IsScomable[MAX_L2_PER_QUAD];
            bool l_l3IsScanable[MAX_L3_PER_QUAD];
            bool l_l3IsScomable[MAX_L3_PER_QUAD];
            bool isScomable = false;

            for (auto cnt = 0; cnt < MAX_L2_PER_QUAD; ++cnt)
            {
                l_l2IsScanable[cnt] = false;
                l_l2IsScomable[cnt] = false;
            }
            for (auto cnt = 0; cnt < MAX_L3_PER_QUAD; ++cnt)
            {
                l_l3IsScanable[cnt] = false;
                l_l3IsScomable[cnt] = false;
            }

            //Same thing with cache, need to check if any clocks are running
            FAPI_INVOKE_HWP(l_err,
                            p9_query_cache_access_state,
                            l_fapi_eq_target,
                            l_l2IsScomable,
                            l_l2IsScanable,
                            l_l3IsScomable,
                            l_l3IsScanable);

            if(l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                            "Error checking cache access state for EQ %d", l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                //Break from do-while
                break;
            }

            //Check if any of the L3's are scommable
            for (auto cnt = 0; cnt < MAX_L3_PER_QUAD; ++cnt)
            {
                if ( l_l3IsScomable[cnt])
                {
                   isScomable = true;
                   break;
                }
            }

            //either l3 cache on the quad is scommable then the clocks are running and we need to stop them
            // It's ok to send BOTH_EX..for procedure p9_hcd_cache_stopclocks..
            // as it handles iternally
            if(isScomable)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                        "Stopping even ex for eq %d", l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                //Stop clocks on both EXs
                FAPI_INVOKE_HWP(l_err,
                                p9_hcd_cache_stopclocks,
                                l_fapi_eq_target,
                                p9hcd::CLK_REGION_ALL_BUT_EX_DPLL,
                                p9hcd::BOTH_EX);
                if(l_err)
                {
                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                            "Error stopping clocks on EVEN EX of EQ %d", l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                    //Break from do-while
                    break;
                }
            }

            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                "Powering down EQ %d", l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
            //Power down slave quad
            FAPI_INVOKE_HWP(l_err,
                            p9_quad_power_off,
                            l_fapi_eq_target,
                            nullptr);
            if(l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          "Error powering off EQ %d", l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
                //Break from do-while
                break;
            }

        }while(0);

        if(l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      "Error detected while attempting to power off EQ 0x%x" , l_eq_target->getAttr<TARGETING::ATTR_CHIP_UNIT>());
            //Break out of EQ for loop
            break;
        }
    }//end EQ for-loop
*/
    return l_err;
}

#ifdef CONFIG_PLDM

/* @brief Perform the first step of the PDR exchange, which will fetch the BMC's
 *        PDRs and add them to Hostboot's PDR repository.  These are necessary
 *        to request the FRU VPD for targets "owned" by the BMC.
 *
 * @return errlHndl_t Error if any, otherwise nullptr.
 */
static errlHndl_t fetch_remote_pdrs()
{
    errlHndl_t l_err = nullptr;

    /* Fetch the BMC's PDRs. */

    do
    {
        PLDM::thePdrManager().resetPdrs();

        /* Get the BMC's PDRs. */

        l_err = PLDM::thePdrManager().addRemotePdrs();

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"Failed to add remote PDRs to PDR manager");
            break;
        }

        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "Added %llu remote PDRs to PDR manager",
                  PLDM::thePdrManager().pdrCount());
    } while (false);

    return l_err;
}

/* @brief Add local PDRs and finish the first half of the PDR exchange with the
 *        BMC (until and including Hostboot notifying the BMC that it has added
 *        its own PDRs to its repository). Presence detection should have already
 *        been done.
 *
 * @return errlHndl_t Error if any, otherwise nullptr.
 */
static errlHndl_t exchange_pdrs()
{
    /* Perform part of the PDR exchange sequence with the BMC. We will get their
     * PDRs first, then allow them to request our PDRs after we send them a PDR
     * Repository Changed event. */

    errlHndl_t l_err = nullptr;

    do
    {
        /* Save a list of the BMC's PDR handles. */

        const auto bmc_pdr_handles = PLDM::thePdrManager().getAllPdrHandles();

        /* Add our own PDRs to our repository. */

        PLDM::thePdrManager().addLocalPdrs();

        auto hb_pdr_handles = PLDM::thePdrManager().getAllPdrHandles();

        /*  Remove the BMC handles from the HB PDR handle list */

        const auto bmc_pdrs
            = std::remove_if(begin(hb_pdr_handles), end(hb_pdr_handles),
                             [&bmc_pdr_handles](const uint32_t handle)
                             {
                                 return (std::find(cbegin(bmc_pdr_handles), cend(bmc_pdr_handles), handle)
                                         != cend(bmc_pdr_handles));
                             });

        hb_pdr_handles.erase(bmc_pdrs, end(hb_pdr_handles));

        /* Notify the BMC that our PDR repository has changed. */

        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "Sending PDR notification to the BMC for %llu new Hostboot PDRs",
                  hb_pdr_handles.size());

        for (const auto handle : hb_pdr_handles)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      "Sending PDR notification to the BMC for handle 0x%08x",
                      handle);
        }

        l_err = PLDM::thePdrManager().sendPdrRepositoryChangeEvent(hb_pdr_handles);

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"Failed to send repository update event to BMC");
            break;
        }
    } while (false);

    return l_err;
}

/* @brief Finish the PDR exchange by waiting on the BMC to send a "PDR
 *        Repository Changed" notification to us, and then refetching their PDR
 *        repository.
 * @return errlHndl_t  Error if any, otherwise nullptr.
 */
static errlHndl_t finish_pdr_exchange()
{
    /* Wait on the BMC to notify us that it is ready for us to request its
     * new PDRs. */

    errlHndl_t l_err = nullptr;

    do
    {
        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "Awaiting PDR Repository Changed notification from the BMC");

        l_err = PLDM::thePdrManager().awaitBmcPdrRepoChanged(PLDM::PdrManager::TIMEOUT_NONE);

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"Failed to wait on PDR repository update event from BMC");
            break;
        }

        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "Received PDR Repository Changed notification from the BMC");

        /* Re-fetch the normalized PDRs from the BMC. */

        PLDM::thePdrManager().resetPdrs();

        l_err = PLDM::thePdrManager().addRemotePdrs();

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"Failed to re-add remote PDRs to PDR manager");
            break;
        }

        /* Assign the PLDM-aware targets their entity IDs */

        l_err = PLDM::assignTargetEntityIds();

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"Failed to set PLDM entity IDs for targets");
            break;
        }
    } while (false);


    return l_err;
}

#endif // CONFIG_PLDM

void* host_discover_targets( void *io_pArgs )
{
    TRACDCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
                "host_discover_targets entry" );

    errlHndl_t l_err(nullptr);
    ISTEP_ERROR::IStepError l_stepError;

    // Check whether we're in MPIPL mode
    TARGETING::Target* l_pTopLevel = nullptr;
    TARGETING::targetService().getTopLevelTarget( l_pTopLevel );
    assert(l_pTopLevel, "host_discover_targets: no TopLevelTarget");

#ifdef CONFIG_PLDM
    // This flag guards later portions of the PDR exchange (we don't want to do
    // subsequent steps if earlier steps failed).
    bool pdr_exchange_failed = false;
#endif

    if (l_pTopLevel->getAttr<TARGETING::ATTR_IS_MPIPL_HB>())
    {
        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "host_discover_targets: MPIPL mode, targeting"
                  "information has already been loaded from memory"
                  "when the targeting service started");
        do
        {
            // Need to power down the slave quads
            l_err = powerDownSlaveQuads();
            if (l_err)
            {
                break;
            }

            // Need to ensure slave SBE's scratch registers are
            // up to date prior to sending continueMPIPL op
            l_err = updateSlaveSbeScratchRegs();
            if (l_err)
            {
                break;
            }

            // Send continue mpipl op to slave procs
            l_err = sendContinueMpiplChipOp();
            if (l_err)
            {
                break;
            }

            // Mask off the OBUS FIRs (normally part of proc_chiplet_scominit
            // Make the FAPI call to p9_io_obus_firmask_save_restore

            // @TODO RTC 213022: Fix this when we implement the HWP
            bool l_success = true;
            /*
            bool l_success = ISTEP::fapiHWPCallWrapperHandler(
                                 ISTEP::P9_OBUS_FIRMASK_SAVE_RESTORE,
                                 l_stepError,
                                 ISTEP_COMP_ID,
                                 TARGETING::TYPE_PROC);
            */

            if( !l_success )
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          ERR_MRK"Error calling p9_io_obus_firmask_save_restore");
            }
        }while(0);

    }
    else
    {
        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                  "host_discover_targets: Normal IPL mode");

#if( defined(CONFIG_SUPPORT_EEPROM_CACHING) && !defined(CONFIG_SUPPORT_EEPROM_HWACCESS) )
        l_err = EEPROM::cacheEECACHEPartition();
#endif

#ifdef CONFIG_PLDM
        /* First step of the PDR exchange is to fetch remote PDRs and then cache
         * remote FRU VPD. Presence detection depends on this data. */

        if (!l_err)
        {
            do
            {
                l_err = fetch_remote_pdrs();

                if (l_err)
                {
                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                              ERR_MRK"Failed to fetch PDRs from the BMC");

                    pdr_exchange_failed = true;
                    captureError(l_err, l_stepError, ISTEP_COMP_ID);
                    break;
                }

                l_err = PLDM::cacheRemoteFruVpd();
                if (l_err)
                {
                    TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                              ERR_MRK"Failed to cache remote FRU info from the BMC");

                    captureError(l_err, l_stepError, ISTEP_COMP_ID);
                    break;
                }
            } while (false);
        }
#endif

        if(nullptr == l_err)
        {
            HWAS::HWASDiscovery l_HWASDiscovery;
            l_err = l_HWASDiscovery.discoverTargets();
        }

#ifdef CONFIG_PLDM
        /* Second step of the PDR exchange is to add local PDRs and notify the
         * BMC that we have done so. This will cause them to fetch the new PDRs
         * from us. This has to be done after presence detection. */

        if (!pdr_exchange_failed && !l_err)
        {
            l_err = exchange_pdrs();

            if (l_err)
            {
                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                          ERR_MRK"Failed to exchange PDRs with the BMC");

                pdr_exchange_failed = true;
                captureError(l_err, l_stepError, ISTEP_COMP_ID);
            }
        }
#endif
    }

#if (defined(CONFIG_MEMVPD_READ_FROM_HW)&&defined(CONFIG_MEMVPD_READ_FROM_PNOR))
    // Now that all targets have completed presence detect and vpd access,
    // invalidate PNOR::CENTAUR_VPD sections where all the targets sharing a
    // VPD_REC_NUM are invalid.
    if (nullptr == l_err) //discoverTargets worked
    {
        l_err = VPD::validateSharedPnorCache();
    }
#endif

    if (l_err)
    {
        captureError(l_err, l_stepError, ISTEP_COMP_ID);
    }

    // Put out some helpful messages that show which targets we actually found
    std::map<TARGETING::TYPE,uint64_t> l_presData;
    for (TARGETING::TargetIterator target = TARGETING::targetService().begin();
         target != TARGETING::targetService().end();
         ++target)
    {
        if (!(target->getAttr<TARGETING::ATTR_HWAS_STATE>().present))
        {
            continue;
        }
        TARGETING::TYPE l_type = target->getAttr<TARGETING::ATTR_TYPE>();
        TARGETING::ATTR_FAPI_POS_type l_pos = 0;
        if( target->tryGetAttr<TARGETING::ATTR_FAPI_POS>(l_pos) )
        {
            l_presData[l_type] |= (0x8000000000000000 >> l_pos);
        }
    }

    TARGETING::EntityPath l_epath; //use EntityPath's translation functions
    for( std::map<TARGETING::TYPE,uint64_t>::iterator itr = l_presData.begin();
         itr != l_presData.end();
         ++itr )
    {
        uint8_t l_type = itr->first;
        uint64_t l_val = itr->second;
        //Only want to display procs, dimms, and cores
        if((l_type != TARGETING::TYPE_DIMM) &&
           (l_type != TARGETING::TYPE_PROC) &&
           (l_type != TARGETING::TYPE_CORE))
        {
            continue;
        }
        TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                "PRESENT> %s[%.2X]=%.8X%.8X",
                l_epath.pathElementTypeAsString(itr->first),
                                                l_type,
                                                l_val>>32, l_val&0xFFFFFFFF);
#if (!defined(CONFIG_CONSOLE_OUTPUT_TRACE) && defined(CONFIG_CONSOLE))
        CONSOLE::displayf("HWAS", "PRESENT> %s[%.2X]=%.8X%.8X",
                l_epath.pathElementTypeAsString(itr->first),
                                                l_type,
                                                l_val>>32,
                                                l_val&0xFFFFFFFF );
#endif
    }

    // send DIMM/CORE/PROC sensor status to the BMC
    //SENSOR::updateBMCSensorStatus();

    // Retrieve the master processor chip
    TARGETING::TargetHandle_t l_pMasterProcChip(nullptr);
    TARGETING::targetService().masterProcChipTargetHandle(l_pMasterProcChip);
    if (l_pMasterProcChip)
    {
        // Make the PSU call to get and apply the SBE Capabilities

#ifdef CONFIG_SBE_PRESENT
        l_err = SBEIO::getPsuSbeCapabilities(l_pMasterProcChip);
#endif
        if (l_err)
        {
            // Commit Error
            errlCommit (l_err, ISTEP_COMP_ID);
        }
    }  // end if (l_pMasterProcChip)

#ifdef CONFIG_PRINT_SYSTEM_INFO
    print_system_info();
#endif

    // Now that we have all of the targets set up we can assign HBRT ids
    // to all of the targets. These are the IDs the Hypervisors use to ID
    // a given target. We set them up now because we want to make sure the
    // attribute is set long before HDAT code consumes them.
    l_err = RUNTIME::configureHbrtHypIds(TARGETING::is_phyp_load());
    if(l_err)
    {
        captureError(l_err, l_stepError, ISTEP_COMP_ID);
    }

#if CONFIG_PLDM
    if (!pdr_exchange_failed)
    {
        l_err = finish_pdr_exchange();

        if (l_err)
        {
            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                      ERR_MRK"PDR exchange failed");
            captureError(l_err, l_stepError, ISTEP_COMP_ID);
        }
    }
#endif // CONFIG_PLDM

    TRACFCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
               "host_discover_targets exit" );

    return l_stepError.getErrorHandle();
}

};
