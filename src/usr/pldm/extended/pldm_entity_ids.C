/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/pldm/extended/pldm_entity_ids.C $                     */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2020,2021                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

/* @file pldm_entity_ids.C
 *
 * @brief Implementation for interface in pldm_entity_ids.H
 */

// Targeting
#include <targeting/common/targetservice.H>
#include <targeting/common/utilFilter.H>

// PLDM
#include "../common/pldmtrace.H"
#include <pldm/extended/pldm_entity_ids.H>
#include <pldm/extended/pdr_manager.H>
#include <pldm/extended/hb_pdrs.H>
#include <pldm/extended/pldm_fru.H>
#include <pldm/pldm_reasoncodes.H>
#include <pldm/pldm_errl.H>

// Error logs
#include <errl/errlmanager.H>

// libpldm header from pldm subtree
#include <openbmc/pldm/libpldm/pdr.h>

using namespace ERRORLOG;

namespace
{

using namespace PLDM;
using namespace TARGETING;

// These are entities whose RSID is generated by Hostboot. We encode the RSID so
// that we can retrieve the Target instance associated with the entity.
const entity_type hb_entity_types[] =
{
    ENTITY_TYPE_PROCESSOR_MODULE,
    ENTITY_TYPE_DIMM
};

// These are entities whose RSID is NOT generated by Hostboot. We don't have a
// strategy yet to associate them with the right Target instance, so we are
// relying on them having one and only one instance and associating them that
// way.
struct unique_entity_info
{
    TARGETING::CLASS target_class;
    TARGETING::TYPE target_type;
    entity_type ent_type;
};

const unique_entity_info foreign_entity_types[] =
{
    { CLASS_ENC, TYPE_NODE, ENTITY_TYPE_BACKPLANE },
    { CLASS_SYS, TYPE_SYS,  ENTITY_TYPE_CHASSIS },
    { CLASS_SYS, TYPE_SYS,  ENTITY_TYPE_LOGICAL_SYSTEM },
    { CLASS_CHIP, TYPE_TPM, ENTITY_TYPE_TPM }
};

/* @brief Update the given target's PLDM_ENTITY_ID_INFO attribute
 *        with a PLDM entity ID
 *
 * @param[in] i_target  The target to update
 * @param[in] i_rsid    FRU Record Set ID to use for Entity ID info
 * @return errlHndl_t   Error if any, otherwise nullptr
 */
errlHndl_t updateTargetEntityIdAttribute(Target* const i_target,
                                         const fru_record_set_id_t i_rsid)
{
    errlHndl_t errl = nullptr;

    do
    {

    pldm_entity ent { };

    if (!thePdrManager().findEntityByFruRecordSetId(i_rsid, ent))
    {
        PLDM_ERR("Cannot find entity by FRU RSID 0x%04x", i_rsid);

        /*@
         * @errortype  ERRL_SEV_UNRECOVERABLE
         * @moduleid   MOD_PLDM_ENTITY_IDS
         * @reasoncode RC_NO_ENTITY_FROM_RSID
         * @userdata1  The Target HUID
         * @userdata2  The FRU Record Set ID
         * @devdesc    Software problem, cannot find Entity from FRU Record Set ID
         * @custdesc   A software error occurred during system boot
         */
        errl = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
                             MOD_PLDM_ENTITY_IDS,
                             RC_NO_ENTITY_FROM_RSID,
                             get_huid(i_target),
                             i_rsid,
                             ErrlEntry::ADD_SW_CALLOUT);

        addBmcErrorCallouts(errl);
        break;
    }

    PLDM_INF("Set PLDM_ENTITY_ID for HUID 0x%08x (%s) to 0x%04x/0x%04x/0x%04x",
             get_huid(i_target),
             attrToString<ATTR_TYPE>(i_target->getAttr<ATTR_TYPE>()),
             ent.entity_type,
             ent.entity_instance_num,
             ent.entity_container_id);

    // This union groups all PLDM entity ID information attributes into the
    // same storage location to be exploited below.  All PLDM entity ID
    // information attribute flavors need to move in lock step if they are ever
    // changed
    const union {
        TARGETING::ATTR_PLDM_ENTITY_ID_INFO_type         generic;
        TARGETING::ATTR_CHASSIS_PLDM_ENTITY_ID_INFO_type chassis;
        TARGETING::ATTR_SYSTEM_PLDM_ENTITY_ID_INFO_type  system;

    } entity_info = {

        // The attribute stores its values in little-endian
        .generic = {
            .entityType = static_cast<uint16_t>(htole16(ent.entity_type)),
            .entityInstanceNumber = static_cast<uint16_t>(htole16(ent.entity_instance_num)),
            .containerId = static_cast<uint16_t>(htole16(ent.entity_container_id))
         }
    };

    switch(ent.entity_type)
    {
        // System and chassis PLDM entity ID information map to specially named
        // attributes (with the same format as PLDM_ENTITY_ID_INFO) that reside
        // on the system target
        case ENTITY_TYPE_LOGICAL_SYSTEM:
            PLDM_INF("Writing logical system PLDM entity ID info");
            i_target->setAttr<ATTR_SYSTEM_PLDM_ENTITY_ID_INFO>(entity_info.system);
            break;
        case ENTITY_TYPE_CHASSIS:
            PLDM_INF("Writing chassis PLDM entity ID info");
            i_target->setAttr<ATTR_CHASSIS_PLDM_ENTITY_ID_INFO>(entity_info.chassis);
            break;
        default:
            i_target->setAttr<ATTR_PLDM_ENTITY_ID_INFO>(entity_info.generic);
            break;
    }

    } while (false);

    return errl;
}

}

errlHndl_t PLDM::assignTargetEntityIds()
{
    PLDM_ENTER("assignTargetEntityIds");

    errlHndl_t errl = nullptr;

    do
    {

    // These RSIDs are not produced by Hostboot so we can't decode them to
    // determine which Target it corresponds to. Instead we rely on the fact
    // that there is only one Target object on single-node machines. This block
    // deals with that.
    for (const auto& entity_info : foreign_entity_types)
    {
        const auto target_rsid = thePdrManager().findFruRecordSetIdsByType(entity_info.ent_type);

        // We don't have a way to associate multiple backplane RSIDs (which is
        // created by the BMC) with Targets at this point, so throw an error
        if (target_rsid.size() > 1)
        {
            PLDM_ERR("Got %llu targets of type %s, expected 0 or 1",
                     target_rsid.size(),
                     attrToString<ATTR_TYPE>(entity_info.target_type));

            /*@
             * @errortype  ERRL_SEV_UNRECOVERABLE
             * @moduleid   MOD_PLDM_ENTITY_IDS
             * @reasoncode RC_EXPECTED_UNIQUE_ENTITY
             * @userdata1  The number of targets found
             * @userdata2[0:31]  The class of target
             * @userdata2[32:63] The type of target
             * @devdesc    Software problem, wanted 0 or 1 target, got multiple
             * @custdesc   A software error occurred during system boot
             */
            errl = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
                                 MOD_PLDM_ENTITY_IDS,
                                 RC_EXPECTED_UNIQUE_ENTITY,
                                 target_rsid.size(),
                                 TWO_UINT32_TO_UINT64(entity_info.target_class,
                                                      entity_info.target_type),
                                 ErrlEntry::ADD_SW_CALLOUT);

            addBmcErrorCallouts(errl);
            break;
        }

        TargetHandleList target;

        getClassResources(target,
                          entity_info.target_class,
                          entity_info.target_type,
                          UTIL_FILTER_ALL);

        if (target.size() != target_rsid.size())
        {
            PLDM_ERR("Hostboot has %llu targets of type %s, but BMC has %llu PLDM entities of type %d",
                     target.size(),
                     attrToString<ATTR_TYPE>(entity_info.target_type),
                     target_rsid.size(),
                     entity_info.ent_type);

            /*@
             * @errortype        ERRL_SEV_INFORMATIONAL
             * @moduleid         MOD_PLDM_ENTITY_IDS
             * @reasoncode       RC_EXPECTED_UNIQUE_TARGET
             * @userdata1[0:31]  The number of targets found
             * @userdata1[32:63] The number of PLDM entities found
             * @userdata2[0:31]  The target class
             * @userdata2[32:63] The target type
             * @devdesc          Software problem, mismatching number of Targets and Entities
             * @custdesc         A software error occurred during system boot
             */
            errl = new ErrlEntry(ERRL_SEV_INFORMATIONAL,
                                 MOD_PLDM_ENTITY_IDS,
                                 RC_EXPECTED_UNIQUE_TARGET,
                                 TWO_UINT32_TO_UINT64(target.size(), target_rsid.size()),
                                 TWO_UINT32_TO_UINT64(entity_info.target_class, entity_info.target_type),
                                 ErrlEntry::ADD_SW_CALLOUT);

            addBmcErrorCallouts(errl);
            errlCommit(errl, PLDM_COMP_ID);
            continue;
        }

        if (!target.empty())
        {
            errl = updateTargetEntityIdAttribute(target[0], target_rsid[0]);

            if (errl)
            {
                break;
            }
        }
    }

    if (errl)
    {
        break;
    }

    // Now deal with records whose RSIDs Hostboot did encode with the
    // corresponding Target's class/type/instance.
    for (const entity_type ent_type : hb_entity_types)
    {
        const auto fru_rsids = thePdrManager().findFruRecordSetIdsByType(ent_type);

        for (const auto rsid : fru_rsids)
        {
            Target* const target = getTargetFromHostbootFruRecordSetID(rsid);

            // This means that either there was a programming error, or else the
            // BMC did not preserve our RSIDs when we sent our PDRs to them and
            // refetched them at the end of the PDR exchange.
            if (!target)
            {
                PLDM_ERR("Cannot find target from RSID 0x%04x", rsid);

                /*@
                 * @errortype  ERRL_SEV_UNRECOVERABLE
                 * @moduleid   MOD_PLDM_ENTITY_IDS
                 * @reasoncode RC_NO_TARGET_FROM_RSID
                 * @userdata1  The FRU Record Set ID that does not correspond to a Target
                 * @userdata2  The entity type of the corresponding Record Set
                 * @devdesc    Software problem, cannot find the Target from FRU Record Set ID
                 * @custdesc   A software error occurred during system boot
                 */
                errl = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
                                     MOD_PLDM_ENTITY_IDS,
                                     RC_NO_TARGET_FROM_RSID,
                                     rsid,
                                     ent_type,
                                     ErrlEntry::ADD_SW_CALLOUT);

                addBmcErrorCallouts(errl);
                break;
            }

            errl = updateTargetEntityIdAttribute(target, rsid);

            if (errl)
            {
                break;
            }
        }

        if (errl)
        {
            break;
        }
    }

    } while (false);

    PLDM_EXIT("assignTargetEntityIds");

    return errl;
}
