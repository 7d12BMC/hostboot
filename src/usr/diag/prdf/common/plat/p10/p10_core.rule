# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/p10/p10_core.rule $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2020
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

chip p10_core
{
    name        "P10 CORE target";
    targettype  TYPE_CORE;
    sigoff      0x0000;
    dump        DUMP_CONTENT_HW;
    scomlen     64;

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # P10 chip EQ_L3_FIR
    ############################################################################

    register EQ_L3_FIR
    {
        name        "P10 chip EQ_L3_FIR";
        scomaddr    0x20018600;
        reset       (&, 0x20018601);
        mask        (|, 0x20018605);
        capture     group default;
    };

    register EQ_L3_FIR_MASK
    {
        name        "P10 chip EQ_L3_FIR MASK";
        scomaddr    0x20018603;
        capture     group default;
    };

    register EQ_L3_FIR_ACT0
    {
        name        "P10 chip EQ_L3_FIR ACT0";
        scomaddr    0x20018606;
        capture     group default;
        capture     req nonzero("EQ_L3_FIR");
    };

    register EQ_L3_FIR_ACT1
    {
        name        "P10 chip EQ_L3_FIR ACT1";
        scomaddr    0x20018607;
        capture     group default;
        capture     req nonzero("EQ_L3_FIR");
    };

    ############################################################################
    # P10 chip EQ_NCU_FIR
    ############################################################################

    register EQ_NCU_FIR
    {
        name        "P10 chip EQ_NCU_FIR";
        scomaddr    0x20018640;
        reset       (&, 0x20018641);
        mask        (|, 0x20018645);
        capture     group default;
    };

    register EQ_NCU_FIR_MASK
    {
        name        "P10 chip EQ_NCU_FIR MASK";
        scomaddr    0x20018643;
        capture     group default;
    };

    register EQ_NCU_FIR_ACT0
    {
        name        "P10 chip EQ_NCU_FIR ACT0";
        scomaddr    0x20018646;
        capture     group default;
        capture     req nonzero("EQ_NCU_FIR");
    };

    register EQ_NCU_FIR_ACT1
    {
        name        "P10 chip EQ_NCU_FIR ACT1";
        scomaddr    0x20018647;
        capture     group default;
        capture     req nonzero("EQ_NCU_FIR");
    };

    ############################################################################
    # P10 chip EQ_L2_FIR
    ############################################################################

    register EQ_L2_FIR
    {
        name        "P10 chip EQ_L2_FIR";
        scomaddr    0x20028000;
        reset       (&, 0x20028001);
        mask        (|, 0x20028005);
        capture     group default;
    };

    register EQ_L2_FIR_MASK
    {
        name        "P10 chip EQ_L2_FIR MASK";
        scomaddr    0x20028003;
        capture     group default;
    };

    register EQ_L2_FIR_ACT0
    {
        name        "P10 chip EQ_L2_FIR ACT0";
        scomaddr    0x20028006;
        capture     group default;
        capture     req nonzero("EQ_L2_FIR");
    };

    register EQ_L2_FIR_ACT1
    {
        name        "P10 chip EQ_L2_FIR ACT1";
        scomaddr    0x20028007;
        capture     group default;
        capture     req nonzero("EQ_L2_FIR");
    };

    ############################################################################
    # P10 chip EQ_CORE_FIR
    ############################################################################

    register EQ_CORE_FIR
    {
        name        "P10 chip EQ_CORE_FIR";
        scomaddr    0x20028440;
        mask        (|, 0x20028445);
        capture     group default;
    };

    register EQ_CORE_FIR_MASK
    {
        name        "P10 chip EQ_CORE_FIR MASK";
        scomaddr    0x20028443;
        capture     group default;
    };

    register EQ_CORE_FIR_ACT0
    {
        name        "P10 chip EQ_CORE_FIR ACT0";
        scomaddr    0x20028446;
        capture     group default;
    };

    register EQ_CORE_FIR_ACT1
    {
        name        "P10 chip EQ_CORE_FIR ACT1";
        scomaddr    0x20028447;
        capture     group default;
    };

    register EQ_CORE_FIR_WOF
    {
        name        "P10 chip EQ_CORE_FIR WOF";
        scomaddr    0x20028448;
        reset       (|, 0x20028448);
        capture     group default;
    };

# Include registers not defined by the xml
.include "p10_core_regs.rule";

};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# Summary for CORE
################################################################################

rule rCORE
{
  CHECK_STOP:
    summary( 0, rEQ_L3_FIR ) |
    summary( 1, rEQ_NCU_FIR ) |
    summary( 2, rEQ_L2_FIR ) |
    summary( 3, rEQ_CORE_FIR );

  RECOVERABLE:
    summary( 0, rEQ_L3_FIR ) |
    summary( 1, rEQ_NCU_FIR ) |
    summary( 2, rEQ_L2_FIR ) |
    summary( 3, rEQ_CORE_FIR );

  UNIT_CS:
    summary( 3, rEQ_CORE_FIR );

};

group gCORE attntype CHECK_STOP, RECOVERABLE, UNIT_CS
    filter singlebit
{
    (rCORE, bit(0)) ? analyze(gEQ_L3_FIR);
    (rCORE, bit(1)) ? analyze(gEQ_NCU_FIR);
    (rCORE, bit(2)) ? analyze(gEQ_L2_FIR);
    (rCORE, bit(3)) ? analyze(gEQ_CORE_FIR);
};

################################################################################
# P10 chip EQ_L3_FIR
################################################################################

rule rEQ_L3_FIR
{
  CHECK_STOP:
    EQ_L3_FIR & ~EQ_L3_FIR_MASK & ~EQ_L3_FIR_ACT0 & ~EQ_L3_FIR_ACT1;
  RECOVERABLE:
    EQ_L3_FIR & ~EQ_L3_FIR_MASK & ~EQ_L3_FIR_ACT0 &  EQ_L3_FIR_ACT1;
};

group gEQ_L3_FIR
    filter singlebit,
           cs_root_cause
{
    /** EQ_L3_FIR[0]
     *  When this error occurs, no members are available f
     */
    (rEQ_L3_FIR, bit(0)) ? defaultMaskedError;

    /** EQ_L3_FIR[1]
     *  L3 attempted to master a CP (Castout/Push) command
     */
    (rEQ_L3_FIR, bit(1)) ? defaultMaskedError;

    /** EQ_L3_FIR[2]
     *  Access attempted to use invalid topology table ent
     */
    (rEQ_L3_FIR, bit(2)) ? defaultMaskedError;

    /** EQ_L3_FIR[3]
     *  This error indicates at least 1 CE and 1 UE have o
     */
    (rEQ_L3_FIR, bit(3)) ? defaultMaskedError;

    /** EQ_L3_FIR[4]
     *  CE detected along read dataflow. This may assert d
     */
    (rEQ_L3_FIR, bit(4)) ? defaultMaskedError;

    /** EQ_L3_FIR[5]
     *  UE detected along read dataflow. May assert due to
     */
    (rEQ_L3_FIR, bit(5)) ? defaultMaskedError;

    /** EQ_L3_FIR[6]
     *  SUE detected along read dataflow. May assert due t
     */
    (rEQ_L3_FIR, bit(6)) ? defaultMaskedError;

    /** EQ_L3_FIR[7]
     *  CE detected along write dataflow with data from Po
     */
    (rEQ_L3_FIR, bit(7)) ? defaultMaskedError;

    /** EQ_L3_FIR[8]
     *  UE detected along write dataflow with data from Po
     */
    (rEQ_L3_FIR, bit(8)) ? defaultMaskedError;

    /** EQ_L3_FIR[9]
     *  SUE detected along write dataflow with data from P
     */
    (rEQ_L3_FIR, bit(9)) ? defaultMaskedError;

    /** EQ_L3_FIR[10]
     *  CE detected along write dataflow with data from L2
     */
    (rEQ_L3_FIR, bit(10)) ? defaultMaskedError;

    /** EQ_L3_FIR[11]
     *  UE detected along write dataflow with data from L2
     */
    (rEQ_L3_FIR, bit(11)) ? defaultMaskedError;

    /** EQ_L3_FIR[12]
     *  SUE detected along write dataflow with data from L
     */
    (rEQ_L3_FIR, bit(12)) ? defaultMaskedError;

    /** EQ_L3_FIR[13]
     *  Directory CE Occured
     */
    (rEQ_L3_FIR, bit(13)) ? defaultMaskedError;

    /** EQ_L3_FIR[14]
     *  Directory UE Occured
     */
    (rEQ_L3_FIR, bit(14)) ? defaultMaskedError;

    /** EQ_L3_FIR[15]
     *  Directory error occured but no error found during 
     */
    (rEQ_L3_FIR, bit(15)) ? defaultMaskedError;

    /** EQ_L3_FIR[16]
     *  Received addr_error cresp on Snoop Machine or Cast
     */
    (rEQ_L3_FIR, bit(16)) ? defaultMaskedError;

    /** EQ_L3_FIR[17]
     *  Received addr_error cresp for Prefetch Operation
     */
    (rEQ_L3_FIR, bit(17)) ? defaultMaskedError;

    /** EQ_L3_FIR[18]
     *  Asserts when the L3 returns presp_rty_other to a P
     */
    (rEQ_L3_FIR, bit(18)) ? defaultMaskedError;

    /** EQ_L3_FIR[19]
     *  lru invalid count error. Violation of requirement 
     */
    (rEQ_L3_FIR, bit(19)) ? defaultMaskedError;

    /** EQ_L3_FIR[20]
     *  spare20
     */
    (rEQ_L3_FIR, bit(20)) ? defaultMaskedError;

    /** EQ_L3_FIR[21]
     *  spare21
     */
    (rEQ_L3_FIR, bit(21)) ? defaultMaskedError;

    /** EQ_L3_FIR[22]
     *  spare22
     */
    (rEQ_L3_FIR, bit(22)) ? defaultMaskedError;

    /** EQ_L3_FIR[23]
     *  Prefetcj or Write Inject machine PowerBus data han
     */
    (rEQ_L3_FIR, bit(23)) ? defaultMaskedError;

    /** EQ_L3_FIR[24]
     *  Hardware Control Error. See Hardware Control Error
     */
    (rEQ_L3_FIR, bit(24)) ? defaultMaskedError;

    /** EQ_L3_FIR[25]
     *  Cache Inhibited operation was hit in the L3 direct
     */
    (rEQ_L3_FIR, bit(25)) ? defaultMaskedError;

    /** EQ_L3_FIR[26]
     *  Snoop Machine or Read machine has performed a line
     */
    (rEQ_L3_FIR, bit(26)) ? defaultMaskedError;

    /** EQ_L3_FIR[27]
     *  Indicates that this l3 has snooped an incoming lco
     */
    (rEQ_L3_FIR, bit(27)) ? defaultMaskedError;

    /** EQ_L3_FIR[28]
     *  Indicates the LRU intended to victimize a line, bu
     */
    (rEQ_L3_FIR, bit(28)) ? defaultMaskedError;

    /** EQ_L3_FIR[29]
     *  All members are either column or line deleted in s
     */
    (rEQ_L3_FIR, bit(29)) ? defaultMaskedError;

    /** EQ_L3_FIR[30]
     *  Indicates that this l3 has snooped an incoming lco
     */
    (rEQ_L3_FIR, bit(30)) ? defaultMaskedError;

    /** EQ_L3_FIR[31]
     *  Received ack_dead or ed_ack_dead cresp on CO, SN o
     */
    (rEQ_L3_FIR, bit(31)) ? defaultMaskedError;

    /** EQ_L3_FIR[32]
     *  Received ack_dead or ed_ack_dead cresp on PF opera
     */
    (rEQ_L3_FIR, bit(32)) ? defaultMaskedError;

};

################################################################################
# P10 chip EQ_NCU_FIR
################################################################################

rule rEQ_NCU_FIR
{
  CHECK_STOP:
    EQ_NCU_FIR & ~EQ_NCU_FIR_MASK & ~EQ_NCU_FIR_ACT0 & ~EQ_NCU_FIR_ACT1;
  RECOVERABLE:
    EQ_NCU_FIR & ~EQ_NCU_FIR_MASK & ~EQ_NCU_FIR_ACT0 &  EQ_NCU_FIR_ACT1;
};

group gEQ_NCU_FIR
    filter singlebit,
           cs_root_cause
{
    /** EQ_NCU_FIR[0]
     *  H/W control error.
     */
    (rEQ_NCU_FIR, bit(0)) ? defaultMaskedError;

    /** EQ_NCU_FIR[1]
     *  TLBIE control error.
     */
    (rEQ_NCU_FIR, bit(1)) ? defaultMaskedError;

    /** EQ_NCU_FIR[2]
     *  TLBIE or SLBIEG received illegal fields from core.
     */
    (rEQ_NCU_FIR, bit(2)) ? defaultMaskedError;

    /** EQ_NCU_FIR[3]
     *  Store address machine received addr_err cresp.
     */
    (rEQ_NCU_FIR, bit(3)) ? defaultMaskedError;

    /** EQ_NCU_FIR[4]
     *  Load address machine received addr_err cresp.
     */
    (rEQ_NCU_FIR, bit(4)) ? defaultMaskedError;

    /** EQ_NCU_FIR[5]
     *  Topology table error - tried accessing invalid ent
     */
    (rEQ_NCU_FIR, bit(5)) ? defaultMaskedError;

    /** EQ_NCU_FIR[6]
     *  One the NCU machines triggerd PB into early hang r
     */
    (rEQ_NCU_FIR, bit(6)) ? defaultMaskedError;

    /** EQ_NCU_FIR[7]
     *  MSGSND received addr_err
     */
    (rEQ_NCU_FIR, bit(7)) ? defaultMaskedError;

    /** EQ_NCU_FIR[8]
     *  Store data parity error from regfile detected.
     */
    (rEQ_NCU_FIR, bit(8)) ? defaultMaskedError;

    /** EQ_NCU_FIR[9]
     *  Store timed out on PB.
     */
    (rEQ_NCU_FIR, bit(9)) ? defaultMaskedError;

    /** EQ_NCU_FIR[10]
     *  TLBIE master timed out on PB.
     */
    (rEQ_NCU_FIR, bit(10)) ? defaultMaskedError;

    /** EQ_NCU_FIR[11]
     *  TLBIE snooper timed out waiting for core.
     */
    (rEQ_NCU_FIR, bit(11)) ? defaultMaskedError;

    /** EQ_NCU_FIR[12]
     *  IMA received addr_err cresp.
     */
    (rEQ_NCU_FIR, bit(12)) ? defaultMaskedError;

    /** EQ_NCU_FIR[13]
     *  TLBIE/sync machine received addr_err cresp.
     */
    (rEQ_NCU_FIR, bit(13)) ? defaultMaskedError;

    /** EQ_NCU_FIR[14]
     *  PMISC received address error cresp.
     */
    (rEQ_NCU_FIR, bit(14)) ? defaultMaskedError;

    /** EQ_NCU_FIR[15]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(15)) ? defaultMaskedError;

    /** EQ_NCU_FIR[16]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(16)) ? defaultMaskedError;

    /** EQ_NCU_FIR[17]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(17)) ? defaultMaskedError;

    /** EQ_NCU_FIR[18]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(18)) ? defaultMaskedError;

    /** EQ_NCU_FIR[19]
     *  PPE write received ack_dead
     */
    (rEQ_NCU_FIR, bit(19)) ? defaultMaskedError;

    /** EQ_NCU_FIR[20]
     *  Darn ttype while darn not enabled.
     */
    (rEQ_NCU_FIR, bit(20)) ? defaultMaskedError;

    /** EQ_NCU_FIR[21]
     *  Darn Address Error cresp.
     */
    (rEQ_NCU_FIR, bit(21)) ? defaultMaskedError;

    /** EQ_NCU_FIR[22]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(22)) ? defaultMaskedError;

    /** EQ_NCU_FIR[23]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(23)) ? defaultMaskedError;

    /** EQ_NCU_FIR[24]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(24)) ? defaultMaskedError;

    /** EQ_NCU_FIR[25]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(25)) ? defaultMaskedError;

    /** EQ_NCU_FIR[26]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(26)) ? defaultMaskedError;

    /** EQ_NCU_FIR[27]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(27)) ? defaultMaskedError;

    /** EQ_NCU_FIR[28]
     *  Spare fir bits.
     */
    (rEQ_NCU_FIR, bit(28)) ? defaultMaskedError;

};

################################################################################
# P10 chip EQ_L2_FIR
################################################################################

rule rEQ_L2_FIR
{
  CHECK_STOP:
    EQ_L2_FIR & ~EQ_L2_FIR_MASK & ~EQ_L2_FIR_ACT0 & ~EQ_L2_FIR_ACT1;
  RECOVERABLE:
    EQ_L2_FIR & ~EQ_L2_FIR_MASK & ~EQ_L2_FIR_ACT0 &  EQ_L2_FIR_ACT1;
};

group gEQ_L2_FIR
    filter singlebit,
           cs_root_cause
{
    /** EQ_L2_FIR[0]
     *  H/W Trigger Mechanism at point cache read occurs t
     */
    (rEQ_L2_FIR, bit(0)) ? defaultMaskedError;

    /** EQ_L2_FIR[1]
     *  H/W Trigger Mechanism at point cache read occurs t
     */
    (rEQ_L2_FIR, bit(1)) ? defaultMaskedError;

    /** EQ_L2_FIR[2]
     *  H/W Trigger Mechanism at point cache read occurs t
     */
    (rEQ_L2_FIR, bit(2)) ? defaultMaskedError;

    /** EQ_L2_FIR[3]
     *  H/W intiated Line Delete occured (Id state injecte
     */
    (rEQ_L2_FIR, bit(3)) ? defaultMaskedError;

    /** EQ_L2_FIR[4]
     *  L2 Castout where L2 cache read detected UE/SUE and
     */
    (rEQ_L2_FIR, bit(4)) ? defaultMaskedError;

    /** EQ_L2_FIR[5]
     *  L2 Castout where L2 cache read detected UE/SUE and
     */
    (rEQ_L2_FIR, bit(5)) ? defaultMaskedError;

    /** EQ_L2_FIR[6]
     *  L2 corrected a CE in the L2 directory
     */
    (rEQ_L2_FIR, bit(6)) ? defaultMaskedError;

    /** EQ_L2_FIR[7]
     *  L2 detected a UE in the L2 directory
     */
    (rEQ_L2_FIR, bit(7)) ? defaultMaskedError;

    /** EQ_L2_FIR[8]
     *  L2 detected a SBCE in the L2 directory
     */
    (rEQ_L2_FIR, bit(8)) ? defaultMaskedError;

    /** EQ_L2_FIR[9]
     *  PEC attempted to repair and CO a SBCE condition bu
     */
    (rEQ_L2_FIR, bit(9)) ? defaultMaskedError;

    /** EQ_L2_FIR[10]
     *  DEPRICATED: THIS FIR BIT SHOULD ALWAYS BE MASKED. 
     */
    (rEQ_L2_FIR, bit(10)) ? defaultMaskedError;

    /** EQ_L2_FIR[11]
     *  LRU array has illegal valu in it(due to flipped bi
     */
    (rEQ_L2_FIR, bit(11)) ? defaultMaskedError;

    /** EQ_L2_FIR[12]
     *  RC timed out waiting for powerbus to return data.
     */
    (rEQ_L2_FIR, bit(12)) ? defaultMaskedError;

    /** EQ_L2_FIR[13]
     *  NCU timed out waiting for powerbus to return data.
     */
    (rEQ_L2_FIR, bit(13)) ? defaultMaskedError;

    /** EQ_L2_FIR[14]
     *  Internal h/w control error
     */
    (rEQ_L2_FIR, bit(14)) ? defaultMaskedError;

    /** EQ_L2_FIR[15]
     *  All members in a single congruence class has been 
     */
    (rEQ_L2_FIR, bit(15)) ? defaultMaskedError;

    /** EQ_L2_FIR[16]
     *  Cache Inhibited Ld/St hit a line in the L2 cache. 
     */
    (rEQ_L2_FIR, bit(16)) ? defaultMaskedError;

    /** EQ_L2_FIR[17]
     *  RC was doing a fabric op on behalf of a load and g
     */
    (rEQ_L2_FIR, bit(17)) ? defaultMaskedError;

    /** EQ_L2_FIR[18]
     *  RC was doing a fabric op on behalf of a store and 
     */
    (rEQ_L2_FIR, bit(18)) ? defaultMaskedError;

    /** EQ_L2_FIR[19]
     *  RC incoming Power Bus data had a CE error.
     */
    (rEQ_L2_FIR, bit(19)) ? defaultMaskedError;

    /** EQ_L2_FIR[20]
     *  RC incoming Power Bus data had a UE error.
     */
    (rEQ_L2_FIR, bit(20)) ? defaultMaskedError;

    /** EQ_L2_FIR[21]
     *  RC incoming Power Bus data had a SUE error.
     */
    (rEQ_L2_FIR, bit(21)) ? defaultMaskedError;

    /** EQ_L2_FIR[22]
     *  Targetted nodal request got rty_inc cresp.
     */
    (rEQ_L2_FIR, bit(22)) ? defaultMaskedError;

    /** EQ_L2_FIR[23]
     *  RC was doing a fabric op on behalf of a load and g
     */
    (rEQ_L2_FIR, bit(23)) ? defaultMaskedError;

    /** EQ_L2_FIR[24]
     *  RCDAT read parity error.
     */
    (rEQ_L2_FIR, bit(24)) ? defaultMaskedError;

    /** EQ_L2_FIR[25]
     *  CO or SNP was doing a fabric op on behalf of a sto
     */
    (rEQ_L2_FIR, bit(25)) ? defaultMaskedError;

    /** EQ_L2_FIR[26]
     *  LVDIR took a parity error.
     */
    (rEQ_L2_FIR, bit(26)) ? defaultMaskedError;

    /** EQ_L2_FIR[27]
     *  bad topology table config software error
     */
    (rEQ_L2_FIR, bit(27)) ? defaultMaskedError;

    /** EQ_L2_FIR[28]
     *  Darn timed out waiting for data.
     */
    (rEQ_L2_FIR, bit(28)) ? defaultMaskedError;

    /** EQ_L2_FIR[29]
     *  Early hang in L2.
     */
    (rEQ_L2_FIR, bit(29)) ? defaultMaskedError;

    /** EQ_L2_FIR[30]
     *  Unexpected cast-out or push during chip_contained 
     */
    (rEQ_L2_FIR, bit(30)) ? defaultMaskedError;

    /** EQ_L2_FIR[31]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(31)) ? defaultMaskedError;

    /** EQ_L2_FIR[32]
     *  PEC Phase3 timeout, recoverable problem, informati
     */
    (rEQ_L2_FIR, bit(32)) ? defaultMaskedError;

    /** EQ_L2_FIR[33]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(33)) ? defaultMaskedError;

    /** EQ_L2_FIR[34]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(34)) ? defaultMaskedError;

    /** EQ_L2_FIR[35]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(35)) ? defaultMaskedError;

    /** EQ_L2_FIR[36]
     *  Cache read CE and UE popped within a short hang pu
     */
    (rEQ_L2_FIR, bit(36)) ? defaultMaskedError;

    /** EQ_L2_FIR[37]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(37)) ? defaultMaskedError;

    /** EQ_L2_FIR[38]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(38)) ? defaultMaskedError;

    /** EQ_L2_FIR[39]
     *  L2 FIR Register
     */
    (rEQ_L2_FIR, bit(39)) ? defaultMaskedError;

};

################################################################################
# P10 chip EQ_CORE_FIR
################################################################################

rule rEQ_CORE_FIR
{
  CHECK_STOP:
    EQ_CORE_FIR & ~EQ_CORE_FIR_MASK & ~EQ_CORE_FIR_ACT0 & ~EQ_CORE_FIR_ACT1;
  RECOVERABLE:
    EQ_CORE_FIR_WOF & ~EQ_CORE_FIR_MASK & ~EQ_CORE_FIR_ACT0 &  EQ_CORE_FIR_ACT1;
  UNIT_CS:
    EQ_CORE_FIR & ~EQ_CORE_FIR_MASK &  EQ_CORE_FIR_ACT0 &  EQ_CORE_FIR_ACT1;
};

group gEQ_CORE_FIR
    filter priority(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,58,59,60,61,62,63,57),
           cs_root_cause
{
    /** EQ_CORE_FIR[0]
     *  IFU SRAM recoverable error (ICACHE parity error, e
     */
    (rEQ_CORE_FIR, bit(0)) ? defaultMaskedError;

    /** EQ_CORE_FIR[1]
     *  TC checkstop
     */
    (rEQ_CORE_FIR, bit(1)) ? defaultMaskedError;

    /** EQ_CORE_FIR[2]
     *  IFU RegFile recoverable error
     */
    (rEQ_CORE_FIR, bit(2)) ? defaultMaskedError;

    /** EQ_CORE_FIR[3]
     *  IFU RegFile core checkstop
     */
    (rEQ_CORE_FIR, bit(3)) ? defaultMaskedError;

    /** EQ_CORE_FIR[4]
     *  IFU logic recoverable error
     */
    (rEQ_CORE_FIR, bit(4)) ? defaultMaskedError;

    /** EQ_CORE_FIR[5]
     *  IFU logic core checkstop
     */
    (rEQ_CORE_FIR, bit(5)) ? defaultMaskedError;

    /** EQ_CORE_FIR[6]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(6)) ? defaultMaskedError;

    /** EQ_CORE_FIR[7]
     *  VSU Inference Accumulator recoverable error
     */
    (rEQ_CORE_FIR, bit(7)) ? defaultMaskedError;

    /** EQ_CORE_FIR[8]
     *  Recovery core checkstop
     */
    (rEQ_CORE_FIR, bit(8)) ? defaultMaskedError;

    /** EQ_CORE_FIR[9]
     *  VSU Slice Targeted File (STF) recoverable error
     */
    (rEQ_CORE_FIR, bit(9)) ? defaultMaskedError;

    /** EQ_CORE_FIR[10]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(10)) ? defaultMaskedError;

    /** EQ_CORE_FIR[11]
     *  ISU logic recoverable error
     */
    (rEQ_CORE_FIR, bit(11)) ? defaultMaskedError;

    /** EQ_CORE_FIR[12]
     *  ISU logic core checkstop
     */
    (rEQ_CORE_FIR, bit(12)) ? defaultMaskedError;

    /** EQ_CORE_FIR[13]
     *  ISU recoverable if not in MT window
     */
    (rEQ_CORE_FIR, bit(13)) ? defaultMaskedError;

    /** EQ_CORE_FIR[14]
     *  MCHK received while ME=0 - non recoverable
     */
    (rEQ_CORE_FIR, bit(14)) ? defaultMaskedError;

    /** EQ_CORE_FIR[15]
     *  UE from L2
     */
    (rEQ_CORE_FIR, bit(15)) ? defaultMaskedError;

    /** EQ_CORE_FIR[16]
     *  Number of UEs from L2 above threshold
     */
    (rEQ_CORE_FIR, bit(16)) ? defaultMaskedError;

    /** EQ_CORE_FIR[17]
     *  UE on CI load
     */
    (rEQ_CORE_FIR, bit(17)) ? defaultMaskedError;

    /** EQ_CORE_FIR[18]
     *  MMU TLB parity recoverable error
     */
    (rEQ_CORE_FIR, bit(18)) ? defaultMaskedError;

    /** EQ_CORE_FIR[19]
     *  MMU SLB parity recoverable error
     */
    (rEQ_CORE_FIR, bit(19)) ? defaultMaskedError;

    /** EQ_CORE_FIR[20]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(20)) ? defaultMaskedError;

    /** EQ_CORE_FIR[21]
     *  MMU CXT recoverable error
     */
    (rEQ_CORE_FIR, bit(21)) ? defaultMaskedError;

    /** EQ_CORE_FIR[22]
     *  MMU logic core checkstop
     */
    (rEQ_CORE_FIR, bit(22)) ? defaultMaskedError;

    /** EQ_CORE_FIR[23]
     *  MMU system checkstop
     */
    (rEQ_CORE_FIR, bit(23)) ? defaultMaskedError;

    /** EQ_CORE_FIR[24]
     *  VSU logic recoverable error
     */
    (rEQ_CORE_FIR, bit(24)) ? defaultMaskedError;

    /** EQ_CORE_FIR[25]
     *  VSU logic core checkstop
     */
    (rEQ_CORE_FIR, bit(25)) ? defaultMaskedError;

    /** EQ_CORE_FIR[26]
     *  Thread in maintenance mode and receives recovery r
     */
    (rEQ_CORE_FIR, bit(26)) ? defaultMaskedError;

    /** EQ_CORE_FIR[27]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(27)) ? defaultMaskedError;

    /** EQ_CORE_FIR[28]
     *  PC system checkstop - Recoverable error received w
     */
    (rEQ_CORE_FIR, bit(28)) ? defaultMaskedError;

    /** EQ_CORE_FIR[29]
     *  LSU SRAM recoverable error (DCACHE parity error, E
     */
    (rEQ_CORE_FIR, bit(29)) ? defaultMaskedError;

    /** EQ_CORE_FIR[30]
     *  LSU set deleted
     */
    (rEQ_CORE_FIR, bit(30)) ? defaultMaskedError;

    /** EQ_CORE_FIR[31]
     *  LSU RegFile recoverable error
     */
    (rEQ_CORE_FIR, bit(31)) ? defaultMaskedError;

    /** EQ_CORE_FIR[32]
     *  LSU RegFile core checkstop
     */
    (rEQ_CORE_FIR, bit(32)) ? defaultMaskedError;

    /** EQ_CORE_FIR[33]
     *  MMU TLB multi hit error occurred
     */
    (rEQ_CORE_FIR, bit(33)) ? defaultMaskedError;

    /** EQ_CORE_FIR[34]
     *  MMU SLB multi hit error occurred
     */
    (rEQ_CORE_FIR, bit(34)) ? defaultMaskedError;

    /** EQ_CORE_FIR[35]
     *  LSU ERAT multi hit error occurred
     */
    (rEQ_CORE_FIR, bit(35)) ? defaultMaskedError;

    /** EQ_CORE_FIR[36]
     *  PC forward progress error
     */
    (rEQ_CORE_FIR, bit(36)) ? defaultMaskedError;

    /** EQ_CORE_FIR[37]
     *  LSU logic recoverable error
     */
    (rEQ_CORE_FIR, bit(37)) ? defaultMaskedError;

    /** EQ_CORE_FIR[38]
     *  LSU logic core checkstop
     */
    (rEQ_CORE_FIR, bit(38)) ? defaultMaskedError;

    /** EQ_CORE_FIR[39]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(39)) ? defaultMaskedError;

    /** EQ_CORE_FIR[40]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(40)) ? defaultMaskedError;

    /** EQ_CORE_FIR[41]
     *  LSU system checkstop
     */
    (rEQ_CORE_FIR, bit(41)) ? defaultMaskedError;

    /** EQ_CORE_FIR[42]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(42)) ? defaultMaskedError;

    /** EQ_CORE_FIR[43]
     *  PC thread hang recoverable error
     */
    (rEQ_CORE_FIR, bit(43)) ? defaultMaskedError;

    /** EQ_CORE_FIR[44]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(44)) ? defaultMaskedError;

    /** EQ_CORE_FIR[45]
     *  PC logic checkstop
     */
    (rEQ_CORE_FIR, bit(45)) ? defaultMaskedError;

    /** EQ_CORE_FIR[46]
     *  PC TimeBase Facility checkstop
     */
    (rEQ_CORE_FIR, bit(46)) ? defaultMaskedError;

    /** EQ_CORE_FIR[47]
     *  PC TimeBase Facility checkstop
     */
    (rEQ_CORE_FIR, bit(47)) ? defaultMaskedError;

    /** EQ_CORE_FIR[48]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(48)) ? defaultMaskedError;

    /** EQ_CORE_FIR[49]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(49)) ? defaultMaskedError;

    /** EQ_CORE_FIR[50]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(50)) ? defaultMaskedError;

    /** EQ_CORE_FIR[51]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(51)) ? defaultMaskedError;

    /** EQ_CORE_FIR[52]
     *  Hang Recovery Failed
     */
    (rEQ_CORE_FIR, bit(52)) ? defaultMaskedError;

    /** EQ_CORE_FIR[53]
     *  Core Hang detected
     */
    (rEQ_CORE_FIR, bit(53)) ? defaultMaskedError;

    /** EQ_CORE_FIR[54]
     *  reserved
     */
    (rEQ_CORE_FIR, bit(54)) ? defaultMaskedError;

    /** EQ_CORE_FIR[55]
     *  Nest Hang detected
     */
    (rEQ_CORE_FIR, bit(55)) ? defaultMaskedError;

    /** EQ_CORE_FIR[56]
     *  Other Core Chiplet recoverable error
     */
    (rEQ_CORE_FIR, bit(56)) ? defaultMaskedError;

    /** EQ_CORE_FIR[57]
     *  Other Core Chiplet core checkstop
     */
    (rEQ_CORE_FIR, bit(57)) ? defaultMaskedError;

    /** EQ_CORE_FIR[58]
     *  Other Core Chiplet system checkstop
     */
    (rEQ_CORE_FIR, bit(58)) ? defaultMaskedError;

    /** EQ_CORE_FIR[59]
     *  SCOM satellite error detected
     */
    (rEQ_CORE_FIR, bit(59)) ? defaultMaskedError;

    /** EQ_CORE_FIR[60]
     *  Debug Trigger error inject
     */
    (rEQ_CORE_FIR, bit(60)) ? defaultMaskedError;

    /** EQ_CORE_FIR[61]
     *  SCOM or Firmware recoverable error inject
     */
    (rEQ_CORE_FIR, bit(61)) ? defaultMaskedError;

    /** EQ_CORE_FIR[62]
     *  Firmware checkstop error inject
     */
    (rEQ_CORE_FIR, bit(62)) ? defaultMaskedError;

    /** EQ_CORE_FIR[63]
     *  PHYP checkstop via SPRC/SPRD
     */
    (rEQ_CORE_FIR, bit(63)) ? defaultMaskedError;

};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the actions defined for this target
.include "p10_common_actions.rule";
.include "p10_core_actions.rule";

