#!/usr/bin/perl
# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/data/chip_data/build_chip_data_legacy $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2020
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

use warnings;
use strict;

use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case);
use File::Path qw(make_path);
use XML::Simple qw(:strict);

# Pull in from the lib directory
use FindBin qw($RealBin);
use FindBin qw($RealScript);
use lib "$RealBin/lib";

#-------------------------------------------------------------------------------
# Global Variables
#-------------------------------------------------------------------------------

# This is a map of all currently supported models/ECs and their IDs.
my $SUPPORTED_MODEL_EC =
{
    EXPLORER_10 => 0x00000000, # Explorer Chip DD1.0
    P10_10      => 0x00000000, # P10 Chip DD1.0
};

# All models/ECs that may exist in the XML, but no longer needs to be built.
# This is useful for build optimization and also help prevent build breaks when
# the XML still exists, but not needed anymore.
my $DEPRECATED_MODEL_EC = [];

#-------------------------------------------------------------------------------
# Help function
#-------------------------------------------------------------------------------

sub help()
{
    print <<EOF;
Usage: $RealScript -h
       $RealScript -i <input_dir> -o <output_dir>

Builds Chip Data Binary files from the input Chip Data XML.

Options:
 -h, --help     Prints this menu.
 -i, --input    Directory containing the Chip Data XML files.
 -o, --output   Directory that will contain the Chip Data Binary files.
EOF

    exit;
}

#-------------------------------------------------------------------------------
# Input
#-------------------------------------------------------------------------------

help() unless @ARGV; # print help if no arguments

# Get options
my ( $help, $src_dir, $dest_dir );
help() unless GetOptions( 'h|help'     => \$help,
                          'i|input=s'  => \$src_dir,
                          'o|output=s' => \$dest_dir );

help() if @ARGV; # print usage if there are extra arguments

# -h,--help
help() if ( $help );

# -i,--input
die "ERROR> Option -i required." unless ( defined $src_dir );
die "ERROR> '$src_dir' is not a directory" unless ( -d $src_dir );

# -o,--output
die "ERROR> Option -o required." unless ( defined $dest_dir );
make_path( $dest_dir, {error => \my $err} );
if ( @{$err} )
{
    my ( $file, $message ) = %{shift @{$err}};
    die "ERROR> $message: $file\n";
}

#-------------------------------------------------------------------------------
# Prototypes
#-------------------------------------------------------------------------------

sub importXML($);
sub normalizeXML($);
sub printData($$);

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

# Validate and import the XML.
my $chip_data_xml = importXML( $src_dir );

# There are some fields in the XML that are shorthand and need to be expanded
# before building the binary files.
my $normalized_data = normalizeXML( $chip_data_xml );

# The XML should now be in a format to start building the binary files.
printData( $dest_dir, $normalized_data );

#-------------------------------------------------------------------------------
# Import functions
#-------------------------------------------------------------------------------

# For each supported XML file in the given directory:
#   - Ensures the XML is well-formed.
#   - Ensures the XML validates against the schema.
#   - Imports the XML into Perl data structures.
sub importXML($)
{
    my ( $dir ) = @_;

    my $data = {};

    # Get a list of all the XML files.
    opendir DIR, $dir or die "Couldn't open dir '$dir': $!";
    my @files = grep { /^.+\.xml$/ } readdir DIR;
    closedir DIR;

    # Iterate each supported file type.
    for my $type ( "chip", "node" )
    {
        for my $file ( grep { /^$type\_.+\.xml$/ } @files )
        {
            my $path = "$dir/$file";

            # Ensure the XML is well-formed and validates against the schema.
            system( "xmllint --noout --schema $RealBin/$type.xsd $path" );
            if (0 != $?)
            {
                die "ERROR> RAS XML validation failed on $file\n";
            }

            # Import the XML.
            my $xml = XMLin( $path, KeyAttr => {}, ForceArray => 1 );

            # Add the file path to the XML for error output.
            $xml->{path} = $path;

            # Push each file's data to a list for each file type.
            push @{$data->{$type}}, $xml;
        }
    }

    return $data;
}

#-------------------------------------------------------------------------------
# Normalize functions
#-------------------------------------------------------------------------------

sub __getTarget($)
{
    my ( $fir ) = @_;

    my $map =
    {
        TP_LOCAL_FIR   => "PROC", # TP chiplet
        OCC_FIR        => "PROC", # TP chiplet
        PBAO_FIR       => "PROC", # TP chiplet
        N0_LOCAL_FIR   => "PROC", # N0 chiplet
        INT_CQ_FIR     => "PROC", # N0 chiplet
        NX_CQ_FIR      => "PROC", # N0 chiplet
        NX_DMA_ENG_FIR => "PROC", # N0 chiplet
        VAS_FIR        => "PROC", # N0 chiplet
        N1_LOCAL_FIR   => "PROC", # N1 chiplet
        HCA_FIR        => "PROC", # N1 chiplet
        LPC_FIR        => "PROC", # N1 chiplet
        MCD_FIR        => "PROC", # N1 chiplet
        PBAF_FIR       => "PROC", # N1 chiplet
        PB_EXT_FIR     => "PROC", # N1 chiplet
        PB_STATION_FIR => "PROC", # N1 chiplet
        PSIHB_FIR      => "PROC", # N1 chiplet
        NMMU_CQ_FIR    => "NMMU", # N0 and N1 chiplets
        NMMU_FIR       => "NMMU", # N0 and N1 chiplets
        PCI_LOCAL_FIR  => "PEC",  # PCI chiplet
        PCI_IOP_FIR    => "PEC",  # PCI chiplet
        PCI_NEST_FIR   => "PHB",  # N0 and N1 chiplets
        PCI_ETU_FIR    => "PHB",  # PCI chiplet
        PCI_FIR        => "PHB",  # PCI chiplet
        MC_LOCAL_FIR   => "MC",   # MC chiplet
        MC_FIR         => "MC",   # MC chiplet
        MC_MISC_FIR    => "MC",   # MC chiplet
        MC_DSTL_FIR    => "MCC",  # MC chiplet
        MC_USTL_FIR    => "MCC",  # MC chiplet
        MC_OMI_DL_FIR  => "OMIC", # MC chiplet
        PAU_LOCAL_FIR  => "PAUC", # PAU chiplet
        PAU_DL_FIR     => "PAUC", # PAU chiplet
        PAU_PHY_FIR    => "PAUC", # PAU chiplet
        PAU_PTL_FIR    => "PAUC", # PAU chiplet
        PAU_FIR_0      => "PAU",  # PAU chiplet
        PAU_FIR_1      => "PAU",  # PAU chiplet
        PAU_FIR_2      => "PAU",  # PAU chiplet
        IOHS_LOCAL_FIR => "IOHS", # IOHS chiplet
        IOHS_DLP_FIR   => "IOHS", # IOHS chiplet
        EQ_LOCAL_FIR   => "EQ",   # EQ chiplet
        EQ_QME_FIR     => "EQ",   # EQ chiplet
        EQ_CORE_FIR    => "CORE", # EQ chiplet
        EQ_L2_FIR      => "CORE", # EQ chiplet
        EQ_L3_FIR      => "CORE", # EQ chiplet
        EQ_NCU_FIR     => "CORE", # EQ chiplet
        EQ_SPATTN      => "CORE", # EQ chiplet
    };

    my $trgt = $map->{$fir};
    die "No target specified for FIR: $fir" unless ( defined $trgt );

    return $trgt;
}

#-------------------------------------------------------------------------------

sub __combineConsecutive($$;$$); # prototype because it is called recursively

sub __combineConsecutive($$;$$)
{
    my ( $in, $out, $first, $last ) = @_;

    # Check if there are any elements in the input list.
    if ( 0 < scalar @{$in} )
    {
        # Check if we have found any previous range elements.
        if ( defined $first )
        {
            if ( defined $last )
            {
                # We have at least two in a range. Check if the next one is in
                # the consecutive range.
                if ( $last + 1 == $in->[0] )
                {
                    $last = shift @{$in};
                }
                # This range is done. Add to the list and start the next range.
                else
                {
                    push @{$out}, "$first:$last";
                    $first = shift @{$in};
                    $last = undef;
                }
            }
            else
            {
                # Only the first element in the range so far. Check if the next
                # one is in the consecutive range.
                if ( $first + 1 == $in->[0] )
                {
                    $last = shift @{$in};
                }
                # This range is done. Add to the list and start the next range.
                else
                {
                    push @{$out}, "$first";
                    $first = shift @{$in};
                    $last = undef;
                }
            }
        }
        # No previous range elements. Get the first one.
        else
        {
            $first = shift @{$in};
            $last  = undef; # Just in case.
        }

        # Iterate again.
        __combineConsecutive($in, $out, $first, $last);
    }
    # Nothing else in the input list. Add any trailing range elements.
    elsif ( defined $first )
    {
        push @{$out}, "$first" . ((defined $last) ? ":$last" : "");
    }
}

sub __combine($)
{
    my $out = [];
    __combineConsecutive( shift @_, $out );
    return join( ',', @{$out} );
}

sub __getAddrs($$)
{
    my ( $insts, $config ) = @_;

    my $addrs = [];

    # Make a hash of each address that is shared between multiple chiplets.
    my $tmp1 = {};
    for ( @{$insts} )
    {
        my $i = int $_->{reg_inst};
        my $c = ((hex $_->{addr}) >> 24) & 0xff;
        my $a = (hex $_->{addr}) & 0xffffff;

        push @{$tmp1->{$a}}, { i => $i, c => $c };
    }

    # Sort the instances for each shared address.
    my $tmp2 = [];
    while ( my ($k,$v) = each %{$tmp1} )
    {
        @{$v} = sort { $a->{i} <=> $b->{i} } @{$v};
        push @{$tmp2}, { k => $k, v => $v };
    }

    # Sort the shared addresses by their first instance.
    @{$tmp2} = sort { $a->{v}->[0]->{i} <=> $b->{v}->[0]->{i} } @{$tmp2};

    # Normalize the instances, chiplets, and addresses.
    for my $t ( @{$tmp2} )
    {
        my $d = {};
        if ( 1 < @{$t->{v}} )
        {
            my ( $i, $c ) = ( [], [] );
            for ( @{$t->{v}} )
            {
                push @{$i}, $_->{i};
                push @{$c}, $_->{c};
            }
            $d->{i} = __combine($i);
            $d->{c} = __combine($c);
            $d->{a} = $t->{k};
        }
        else
        {
            $d->{i} = "$t->{v}->[0]->{i}";
            $d->{a} = $t->{v}->[0]->{c} << 24 | $t->{k};
        }

        # Get the addresses for the mask, action, wof, etc. registers.
        $d->{a} = [ $d->{a}, $d->{a}+1, $d->{a}+2,          # FIR, AND, OR
                    $d->{a}+3, $d->{a}+4, $d->{a}+5,        # MASK, AND, OR
                    $d->{a}+6, $d->{a}+7,                   # ACT0, ACT1,
                    ( $config =~ /W/ ) ? $d->{a}+8 : undef, # WOF
                    ( $config =~ /2/ ) ? $d->{a}+9 : undef, # ACT2
                  ];

        # Convert the adddresses to hex strings.
        for ( @{$d->{a}} )
        {
            next unless defined $_;
            $_ = sprintf( ((1 < @{$t->{v}}) ? "0x%06x" : "0x%08x"), $_ );
        }

        push @{$addrs}, $d;
    }

    return $addrs;
}

#-------------------------------------------------------------------------------

sub __getAttnType($)
{
    my ( $attn_type ) = @_;

    my $map = { CS  => "CS", RE => "RE", SPA => "SPA",
                UCS => "UNIT_CS", HA => "HOST_ATTN" };

    return $map->{$attn_type};
}

#-------------------------------------------------------------------------------

sub __normalizeLocalFirXML($$)
{
    my ( $fir, $local ) = @_;

    # Local FIR instances
    $fir->{addr} =__getAddrs( $local->{instance}, $local->{config} );

    # Default actions.
    $fir->{acts} = { "00" => '"NO_ACTION"', "10" => '"NO_ACTION"',
                     "01" => '"NO_ACTION"', "11" => '"NO_ACTION"', };

    # Local FIR actions
    if ( $local->{config} =~ /2/ ) # Three action registers
    {
        $fir->{acts} = { "000" => '"NO_ACTION"', "100" => '"NO_ACTION"',
                         "001" => '"NO_ACTION"', "101" => '"NO_ACTION"',
                         "010" => '"NO_ACTION"', "110" => '"NO_ACTION"',
                         "011" => '"NO_ACTION"', "111" => '"NO_ACTION"', };
    }
    for ( @{$local->{action}} )
    {
        my $tmp = '"' . __getAttnType($_->{attn_type}) . '"';

        # Hack to get things to align in the output.
        my $cnfg = $_->{config};
        unless ( grep { /^$cnfg$/ } ('01', '001', '011', '101') )
        {
            $tmp = sprintf( "%-11s", $tmp );
        }

        $fir->{acts}->{$cnfg} = $tmp;
    }
}

#-------------------------------------------------------------------------------

sub __special_case_EQ_SPATTN($$)
{
    my ( $fir, $node ) = @_;

    $fir->{type} = "attn_reg";
    $fir->{acts} = { "default" => "SPA" };

    for my $i ( 0..3 )
    {
        my $d = {};
        $d->{i} = join(',', (0+$i,4+$i,8+$i,12+$i,16+$i,20+$i,24+$i,28+$i) );
        $d->{c} = "32:39";

        my $a = 0x020499 | (0x8000 >> $i);
        $d->{a} = [ $a,    $a-1,  $a-2,         # FIR, AND, OR
                    $a+1,  undef, undef,        # MASK, AND, OR
                    undef, undef, undef, undef, # ACT0, ACT1, WOF, ACT2
                  ];

        # Convert the adddresses to hex strings.
        for ( @{$d->{a}} )
        {
            next unless defined $_;
            $_ = sprintf("0x%06x", $_);
        }

        push @{$fir->{addr}}, $d;
    }
}

#-------------------------------------------------------------------------------

sub __special_case_EQ_CORE_FIR($$)
{
    my ( $fir, $node ) = @_;

    $fir->{acts} = { "00" => '"CS"       ', "01" => '"RE"',
                     "10" => '"NO_ACTION"', "11" => '"UNIT_CS"', };

    for my $i ( 0..3 )
    {
        my $d = {};
        $d->{i} = join(',', (0+$i,4+$i,8+$i,12+$i,16+$i,20+$i,24+$i,28+$i) );
        $d->{c} = "32:39";

        my $a = 0x020440 | (0x8000 >> $i);
        $d->{a} = [ $a,   $a+1, $a+2,         # FIR, AND, OR
                    $a+3, $a+4, $a+5,        # MASK, AND, OR
                    $a+6, $a+7, $a+8, undef, # ACT0, ACT1, WOF, ACT2
                  ];

        # Convert the adddresses to hex strings.
        for ( @{$d->{a}} )
        {
            next unless defined $_;
            $_ = sprintf("0x%06x", $_);
        }

        push @{$fir->{addr}}, $d;
    }
}

#-------------------------------------------------------------------------------

sub normalizeXML($)
{
    my ( $xml ) = @_;

    my $data = [];

    # Iterate each node file.
    for my $n ( @{$xml->{node}} )
    {
        # Skip global and chiplet FIRs.
        next if ( $n->{name} =~ /^[C|G]FIR_/ );

        # Skip intermim node for EQ_SPATTN.
        next if ( $n->{name} =~ /^EQ_CORE_THREAD_STATE$/ );

        # Skip redundant EQ_SPATTN_FUSED.
        next if ( $n->{name} =~ /^EQ_SPATTN_FUSED$/ );

        # Normalize name of EQ_SPATTN_NORMAL.
        $n->{name} = "EQ_SPATTN" if ( $n->{name} =~ /^EQ_SPATTN_NORMAL$/ );

        # Data for this FIR.
        my $f = {};
        $f->{type}     = "local_fir";
        $f->{name}     = $n->{name};
        $f->{desc}     = "P10 chip $n->{name}";
        $f->{model_ec} = $n->{model_ec};
        $f->{target}   = __getTarget($n->{name});

        # SPECIAL CASE
        if ( $n->{name} =~ /^EQ_SPATTN$/ )
        {
            __special_case_EQ_SPATTN($f,$n);
        }
        # SPECIAL CASE
        elsif ( $n->{name} =~ /^EQ_CORE_FIR$/ )
        {
            __special_case_EQ_CORE_FIR($f,$n);
        }
        # Default case
        else
        {
            # <local_fir> must exist.
            unless ( $n->{local_fir} )
            {
                die "<local_fir> required: $n->{path}";
            }
            # Should only be one <local_fir>.
            if ( 1 < @{$n->{local_fir}} )
            {
                die "Multiple <local_fir> defined: $n->{path}";
            }

            # Normalize the <local_fir> data.
            __normalizeLocalFirXML($f, $n->{local_fir}->[0]);
        }

        # <bit> elements.
        for ( @{$n->{bit}} )
        {
            my $desc = $_->{content};

            # Fix special characters.
            $desc =~ s/&/&amp;/sg;
            $desc =~ s/</&lt;/sg;
            $desc =~ s/>/&gt;/sg;
            $desc =~ s/"/&quot;/sg;

            push @{$f->{bits}}, { pos  => $_->{pos},
                                  desc => $desc };
        }

        # Add this FIR to the list.
        push @{$data}, { path => "fir_". lc $f->{name} .".xml", data => $f };
    }

    return $data;
}

#-------------------------------------------------------------------------------
# Output functions
#-------------------------------------------------------------------------------

sub printData($$)
{
    my ( $dir, $data ) = @_;

    for my $f ( @{$data} )
    {
        my $p = "$dir/$f->{path}";
        my $d = $f->{data};

        open(FILE, ">", $p) or die "Cannot open $p: $!\n";

        # Start with the header stuff.
        print FILE <<EOF;
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="xsl/fir.xsl"?>

EOF

        if ( 'attn_reg' eq $d->{type} )
        {
            print FILE <<EOF;
<attn_reg name="$d->{name}" desc="$d->{desc}"
          model_ec="$d->{model_ec}"
          default_callout_type="$d->{target}" default_dump_type="HW"
          default_attn_type="$d->{acts}->{default}">

EOF
        }
        elsif ( 'local_fir' eq $d->{type} )
        {
            print FILE <<EOF;
<local_fir name="$d->{name}" desc="$d->{desc}"
           model_ec="$d->{model_ec}"
           default_callout_type="$d->{target}" default_dump_type="HW"
EOF

            # Add the action configs.
            if ( 4 == keys %{$d->{acts}} )
            {
                print FILE <<EOF;
           action_00=$d->{acts}->{'00'} action_01=$d->{acts}->{'01'}
           action_10=$d->{acts}->{'10'} action_11=$d->{acts}->{'11'}>

EOF
            }
            else
            {
                print FILE <<EOF;
           action_000=$d->{acts}->{'000'} action_001=$d->{acts}->{'001'}
           action_010=$d->{acts}->{'010'} action_011=$d->{acts}->{'011'}
           action_100=$d->{acts}->{'100'} action_101=$d->{acts}->{'101'}
           action_110=$d->{acts}->{'110'} action_111=$d->{acts}->{'111'}>

EOF
            }
        }

        # Add the addresses.
        for ( @{$d->{addr}} )
        {
            my $i = $_->{i};
            my $c = $_->{c} ? " chiplet=\"$_->{c}\"" : "";
            my $a = $_->{a};

            my $o = <<EOF;
    <addr instance="$i"$c
EOF

            my $reg_names = [ "fir_addr     ", "fir_and_addr ", "fir_or_addr  ",
                              "mask_addr    ", "mask_and_addr", "mask_or_addr ",
                              "act0_addr    ", "act1_addr    ", "wof_addr     ",
                              "act2_addr    " ];
            for ( 0..9 )
            {
                next unless ( defined $a->[$_] );
                $o .= <<EOF;
          $reg_names->[$_]=\"$a->[$_]\"
EOF
            }

            chomp $o;

            print FILE "$o />\n\n";
        }

        # Add each bit.
        for my $b ( @{$d->{bits}} )
        {
            print FILE <<EOF;
    <bit pos="$b->{pos}" attn_type="MASKED"
         desc="$b->{desc}">
    </bit>

EOF
        }

        # Finally, the end.
        print FILE <<EOF;
</$d->{type}>

EOF

        close FILE;
    }
}

