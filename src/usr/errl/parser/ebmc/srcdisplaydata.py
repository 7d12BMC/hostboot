# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/errl/parser/ebmc/srcdisplaydata.py $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2020
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG
""" Copy of file automatically genterated by Hostboot's genErrlParsers.pl
The generated file is created in obj/genfiles/plugins/srcdisplaydata.py

The following dictionary is used by bsrc.py to parse SRC data.

"""

srcInfo = {
            0x1B0100: {    "devdesc": "Kernel has asserted",
                          "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                        "reasoncode": "KERNEL::RC_ASSERT",
                         "userdata1": "Failing address",
                         "userdata2": "<unused>",
                      },
            0x1B0200: {    "devdesc": "Kernel encountered an unhandled exception.",
                          "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                        "reasoncode": "KERNEL::RC_SHUTDOWN",
                         "userdata1": "Failing address",
                         "userdata2": "<unused>",
                      },
            0x1B0300: {    "devdesc": "Kernel encountered an unhandled exception.",
                          "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                        "reasoncode": "KERNEL::RC_UNHANDLED_EX",
                         "userdata1": "Exception type",
                         "userdata2": "<unused>",
                      },
            0x1B9900: {    "devdesc": "Unknown TI from Hostboot",
                          "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                        "reasoncode": "KERNEL::RC_EARLY_BOOT_FAIL",
                         "userdata1": "<unused>",
                         "userdata2": "<unused>",
                      },
            0x230200: {    "devdesc": "Invalid GPIO device type",
                          "moduleid": "GPIO_PERFORM_OP",
                        "reasoncode": "GPIO_I2C_TARGET_NOT_FOUND",
                         "userdata1": "Device type",
                         "userdata2": "HUID of target",
                      },
            0x230300: {    "devdesc": "Invalid GPIO device type",
                          "moduleid": "GPIO_PERFORM_OP",
                        "reasoncode": "GPIO_INVALID_OP",
                         "userdata1": "OP type",
                         "userdata2": "HUID of target",
                      },
            0x262500: {    "devdesc": "OCCs were not loaded/started successfully",
                          "moduleid": "HTMGT_MOD_LOAD_START_STATUS",
                        "reasoncode": "HTMGT_RC_OCC_START_FAIL",
                         "userdata1": "Failing OCC HUID",
                         "userdata2": "",
                      },
            0x265500: {    "devdesc": "No OCC master was found",
                          "moduleid": "HTMGT_MOD_LOAD_START_STATUS",
                        "reasoncode": "HTMGT_RC_OCC_MASTER_NOT_FOUND",
                         "userdata1": "number of OCCs",
                         "userdata2": "",
                      },
            0x10201: {    "devdesc": "User Details unit test - create string user detail data.",
                          "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                        "reasoncode": "ERRL_TEST_STRING_UD",
                         "userdata1": "Test data 1",
                         "userdata2": "Test data 2",
                      },
            0x10401: {    "devdesc": "User Details unit test - create string user detail data.",
                          "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                        "reasoncode": "ERRL_TEST_ATTRIBUTE_UD",
                         "userdata1": "Test data 1",
                         "userdata2": "Test data 2",
                      },
            0x10501: {    "devdesc": "User Details unit test - create log register user detail data.",
                          "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                        "reasoncode": "ERRL_TEST_LOGREGISTER_UD",
                         "userdata1": "Test data 1",
                         "userdata2": "Test data 2",
                      },
            0x20201: {    "devdesc": "A device driver operation was attempted for which no driver has been registered.",
                          "moduleid": "DEVFW_MOD_ASSOCIATOR",
                        "reasoncode": "DEVFW_RC_NO_ROUTE_FOUND",
                         "userdata1": "(OpType << 32) | (AccessType)",
                         "userdata2": "(SCOM_SWITCHES << 32) | TargetType",
                      },
            0x20301: {    "devdesc": "A device driver operation on a NULL target.",
                          "moduleid": "DEVFW_MOD_ASSOCIATOR",
                        "reasoncode": "DEVFW_RC_NULL_TARGET",
                         "userdata1": "OpType",
                         "userdata2": "AccessType",
                      },
            0x20401: {    "devdesc": "A double registration was attempted with the routing framework.",
                          "moduleid": "DEVFW_MOD_ASSOCIATOR",
                        "reasoncode": "DEVFW_RC_DOUBLE_REGISTRATION",
                         "userdata1": "OpType",
                         "userdata2": "AccessType",
                      },
            0x50101: {    "devdesc": "Initialization Service failed to start a task.",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "START_TASK_FAILED",
                         "userdata1": "0",
                         "userdata2": "task id or task return code",
                      },
            0x50201: {    "devdesc": "Initialization Service attempted to start a function within a module but the function failed to launch",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "START_FN_FAILED",
                         "userdata1": "task return code",
                         "userdata2": "0",
                      },
            0x50401: {    "devdesc": "Could not FLUSH virtual memory.",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "SHUTDOWN_FLUSH_FAILED",
                         "userdata1": "returncode from mm_remove_pages()",
                         "userdata2": "0",
                      },
            0x50501: {    "devdesc": "Initialization Service launched a task and the task returned an error.",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "WAIT_TASK_FAILED",
                         "userdata1": "task id or task return code",
                         "userdata2": "returned status from task",
                      },
            0x50601: {    "devdesc": "Initialization Service launched a function and the task returned an error.",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "WAIT_FN_FAILED",
                         "userdata1": "task id or task return code",
                         "userdata2": "returned status from task",
                      },
            0x50701: {    "devdesc": "Initialization Service failed to load a module needed to load a function or task. UserDetails will contain the name of the function or task.",
                          "moduleid": "BASE_INITSVC_MOD_ID",
                        "reasoncode": "INITSVC_LOAD_MODULE_FAILED",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x60101: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                          "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_INVALID_MESSAGE_TYPE",
                         "userdata1": "Message type",
                         "userdata2": "Requested Virtual Address",
                      },
            0x60201: {    "devdesc": "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range",
                          "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "Virtual Address",
                         "userdata2": "Base PNOR Address",
                      },
            0x60601: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                          "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_INVALID_ASYNC_MESSAGE",
                         "userdata1": "Message type",
                         "userdata2": "Requested Virtual Address",
                      },
            0x70201: {    "devdesc": "Invalid operation type.",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_OP_TYPE",
                         "userdata1": "i_opType",
                         "userdata2": "Offset Length",
                      },
            0x70701: {    "devdesc": "Master Sentinel chip was used as a target for an I2C operation.  This is not permitted.",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_MASTER_SENTINEL_TARGET",
                         "userdata1": "Operation Type requested",
                         "userdata2": "<UNUSED>",
                      },
            0x70D01: {    "devdesc": "I2C read/write interface not linked.",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_RUNTIME_INTERFACE_ERR",
                         "userdata1": "0",
                         "userdata2": "Op type",
                      },
            0x70E01: {    "devdesc": "I2C access error",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_RUNTIME_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "Op type",
                      },
            0x70F01: {    "devdesc": "I2C offset length is invalid",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_RUNTIME_INVALID_OFFSET_LENGTH",
                         "userdata1": "Offset length",
                         "userdata2": "Operation Type",
                      },
            0x71201: {    "devdesc": "I2C master encountered an error while trying to unlock the eepromPage",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_FAILURE_UNLOCKING_EEPROM_PAGE",
                         "userdata1": "Target Huid",
                         "userdata2": "<UNUSED>",
                      },
            0x71801: {    "devdesc": "Invalid input buffer length for send byte request",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_SEND_BYTE_LENGTH",
                         "userdata1": "Size of request",
                         "userdata2": "",
                      },
            0x71901: {    "devdesc": "Invalid input buffer length for write byte or write word request",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_WRITE_BYTE_OR_WORD_LENGTH",
                         "userdata1": "Size of request",
                         "userdata2": "Sub-op",
                      },
            0x71A01: {    "devdesc": "Invalid input buffer length for block write request",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_BLOCK_WRITE_LENGTH",
                         "userdata1": "Size of request",
                         "userdata2": "",
                      },
            0x71B01: {    "devdesc": "Invalid input buffer length for read byte or read word request",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_READ_BYTE_OR_WORD_LENGTH",
                         "userdata1": "Size of request",
                         "userdata2": "Sub-op",
                      },
            0x71C01: {    "devdesc": "Invalid input buffer length for block read request",
                          "moduleid": "I2C_PERFORM_OP",
                        "reasoncode": "I2C_INVALID_BLOCK_READ_LENGTH",
                         "userdata1": "Size of request",
                         "userdata2": "",
                      },
            0x80101: {    "devdesc": "Could not load/unload module.",
                          "moduleid": "VFS_MODULE_ID",
                        "reasoncode": "VFS_LOAD_FAILED",
                         "userdata1": "returncode from msg_sendrecv()",
                         "userdata2": "VfsMessages type [LOAD | UNLOAD]",
                      },
            0x80301: {    "devdesc": "Could not allocate virtual memory.",
                          "moduleid": "VFS_MODULE_ID",
                        "reasoncode": "VFS_ALLOC_VMEM_FAILED",
                         "userdata1": "returncode from mm_alloc_block()",
                         "userdata2": "Size of memory to allocate",
                      },
            0x80401: {    "devdesc": "Could not set permissions on virtual memory.",
                          "moduleid": "VFS_MODULE_ID",
                        "reasoncode": "VFS_PERMS_VMEM_FAILED",
                         "userdata1": "returncode from mm_set_permission()",
                         "userdata2": "message type (LOAD or UNLOAD)",
                      },
            0x80501: {    "devdesc": "Requested module does not exist.",
                          "moduleid": "VFS_MODULE_ID",
                        "reasoncode": "VFS_MODULE_DOES_NOT_EXIST",
                         "userdata1": "first 8 bytes of module name",
                         "userdata2": "next 8 bytes of module name",
                      },
            0x80601: {    "devdesc": "Module is not a data module",
                          "moduleid": "VFS_MODULE_ID",
                        "reasoncode": "VFS_INVALID_DATA_MODULE",
                         "userdata1": "First 8 bytes of module name",
                         "userdata2": "Next 8 bytes of module name",
                      },
            0x90101: {    "devdesc": "InitFile HW Procedure requested an invalid attribute",
                          "moduleid": "MOD_FAPI_RC_TO_ERRL",
                        "reasoncode": "RC_INVALID_ATTR_GET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90201: {    "devdesc": "Request for EC features on an attribute without EC features",
                          "moduleid": "MOD_FAPI_RC_TO_ERRL",
                        "reasoncode": "RC_INVALID_CHIP_EC_FEATURE_GET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90f01: {    "devdesc": "HW Procedure generated error. See User Data.",
                          "moduleid": "MOD_FAPI2_RC_TO_ERRL",
                        "reasoncode": "RC_HWP_GENERATED_ERROR",
                         "userdata1": "RC value from HWP",
                         "userdata2": "<unused>",
                      },
            0xB0101: {    "devdesc": "User Details unit test - create target user detail data",
                          "moduleid": "TARG_MOD_TEST",
                        "reasoncode": "TARG_RC_TEST_TARGET_FFDC",
                         "userdata1": "Test data 1",
                         "userdata2": "Test data 2",
                      },
            0xC0101: {    "devdesc": "Attempt to deconfigure a target that is not deconfigurable or not present.",
                          "moduleid": "HWAS::MOD_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_TARGET_NOT_DECONFIGURABLE",
                         "userdata1": "HUID of input target",
                         "userdata2": "GARD errlog EID",
                      },
            0xD0101: {    "devdesc": "fsiScomPerformOp> Error returned from SCOM Engine after write",
                          "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                        "reasoncode": "FSISCOM::RC_WRITE_ERROR",
                         "userdata1": "SCOM Addr",
                         "userdata2": "Target HUID",
                      },
            0xD0201: {    "devdesc": "fsiScomPerformOp> Error returned from SCOM Engine after read.",
                          "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                        "reasoncode": "FSISCOM::RC_READ_ERROR",
                         "userdata1": "SCOM Addr",
                         "userdata2": "Target HUID",
                      },
            0xD0301: {    "devdesc": "fsiScomPerformOp> Invalid data length (!= 8 bytes)",
                          "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                        "reasoncode": "FSISCOM::RC_INVALID_LENGTH",
                         "userdata1": "SCOM Address",
                         "userdata2": "Data Length",
                      },
            0xD0401: {    "devdesc": "fsiScomPerformOp> Address contains more than 31 bits.",
                          "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                        "reasoncode": "FSISCOM::RC_INVALID_ADDRESS",
                         "userdata1": "SCOM Address",
                         "userdata2": "Target HUID",
                      },
            0xD0501: {    "devdesc": "fsiScomPerformOp> Unsupported Operation Type specified",
                          "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                        "reasoncode": "FSISCOM::RC_INVALID_OPTYPE",
                         "userdata1": "Operation Type (i_opType) : 0=READ, 1=WRITE",
                         "userdata2": "Input scom address",
                      },
            0xE0101: {    "devdesc": "Invalid operation type.",
                          "moduleid": "EEPROM_PERFORM_OP",
                        "reasoncode": "EEPROM_INVALID_OPERATION",
                         "userdata1": "Operation Type",
                         "userdata2": "Chip to Access",
                      },
            0xE0801: {    "devdesc": "I2C Buffer Length + Offset > Max Size",
                          "moduleid": "EEPROM_PERFORM_OP",
                        "reasoncode": "EEPROM_OVERFLOW_ERROR",
                         "userdata1": "Offset",
                         "userdata2": "Buffer Length",
                      },
            0xF0301: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_ENABLE",
                        "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                         "userdata1": "MSG_INTR_ENABLE",
                         "userdata2": "0",
                      },
            0x101201: {    "devdesc": "MDMT could not be chosen for the supplied topology type",
                          "moduleid": "TOD_PICK_MDMT",
                        "reasoncode": "TOD_MASTER_TARGET_NOT_FOUND",
                         "userdata1": "TOD topology type",
                         "userdata2": "",
                      },
            0x120201: {    "devdesc": "Invalid address and size returned from HDAT",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_NO_HDAT_ADDR",
                         "userdata1": "Address returned",
                         "userdata2": "Table type Requested",
                      },
            0x120401: {    "devdesc": "Cannot unmap the source table section",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_CANNOT_UNMAP_SRC",
                         "userdata1": "VA address of the MDST to unmap",
                         "userdata2": "rc value from unmap",
                      },
            0x120501: {    "devdesc": "Cannot unmap the source table section",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_CANNOT_UNMAP_DEST",
                         "userdata1": "VA address of the MDDT to unmap",
                         "userdata2": "rc value from unmap",
                      },
            0x120701: {    "devdesc": "MDRT table is not big enough to hold all entries",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_MDRT_INSUFFICIENT_SPACE",
                         "userdata1": "Index into the MDRT",
                         "userdata2": "max entries allowed given space allocated",
                      },
            0x120901: {    "devdesc": "MDDT table is not big enough to hold all src entries",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_MDDT_INSUFFICIENT_SPACE",
                         "userdata1": "Source Entires bytes left to copy",
                         "userdata2": "Index into the MDST table",
                      },
            0x120A01: {    "devdesc": "MDDT table is not big enough to hold all src entries",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_MDDT_INSUFFICIENT_ENTRIES",
                         "userdata1": "Source Entires bytes left to copy",
                         "userdata2": "Index into the MDST table",
                      },
            0x120B01: {    "devdesc": "MDST table entry with page aligned is greater than 32GB",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_MDST_INVALID_TABLE_SIZE",
                         "userdata1": "Size of Source Table Entry",
                         "userdata2": "Size of Page Aligned Source Table Entry",
                      },
            0x120C01: {    "devdesc": "MDDT table entry with page aligned is greater than 32GB",
                          "moduleid": "DUMP::DUMP_COLLECT",
                        "reasoncode": "DUMP::DUMP_MDDT_INVALID_TABLE_SIZE",
                         "userdata1": "Size of Destination Table Entry",
                         "userdata2": "Size of Page Aligned Destination Table Entry",
                      },
            0x130101: {    "devdesc": "Unexpected data from LPC-UART interface.",
                          "moduleid": "CONSOLE::MOD_CONSOLE_UART_PUTC",
                        "reasoncode": "CONSOLE::RC_INVALID_DATA",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x130201: {    "devdesc": "Timeout from LPC-UART interface.",
                          "moduleid": "CONSOLE::MOD_CONSOLE_UART_PUTC",
                        "reasoncode": "CONSOLE::RC_TIMEOUT",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x140101: {    "devdesc": "A maint command HW timed out",
                          "moduleid": "MDIA::PROCESS_COMMAND_TIMEOUT",
                        "reasoncode": "MDIA::MAINT_COMMAND_HW_TIMED_OUT",
                         "userdata1": "Associated memory diag work item",
                         "userdata2": "Target HUID",
                      },
            0x140201: {    "devdesc": "A maint command SW timed out",
                          "moduleid": "MDIA::PROCESS_COMMAND_TIMEOUT",
                        "reasoncode": "MDIA::MAINT_COMMAND_SW_TIMED_OUT",
                         "userdata1": "Associated memory diag work item",
                         "userdata2": "Target HUID",
                      },
            0x160201: {    "devdesc": "Bad memory pointer received.",
                          "moduleid": "Util::UTIL_MOD_MEM_READ",
                        "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                         "userdata1": "Task ID.",
                         "userdata2": "End of File (boolean)",
                      },
            0x160301: {    "devdesc": "End of file reached.",
                          "moduleid": "Util::UTIL_MOD_MEM_READ",
                        "reasoncode": "Util::UTIL_ERC_EOF",
                         "userdata1": "Task ID.",
                         "userdata2": "End of File (boolean)",
                      },
            0x170301: {    "devdesc": "IStep failed, see other log(s) with the same PLID for reason.",
                          "moduleid": "MOD_REPORTING_ERROR",
                        "reasoncode": "RC_FAILURE",
                         "userdata1": "eid of first error",
                         "userdata2": "Reason code of first error",
                      },
            0x180101: {    "devdesc": "ATTN test case failed",
                          "moduleid": "ATTN_TEST_FAKE_CALL_PRD",
                        "reasoncode": "ATTN_TEST_ATTN_FAIL",
                         "userdata1": "Input attention list size",
                         "userdata2": "Expected attention list size",
                      },
            0x1F0101: {    "devdesc": "IPC service provider received an unexpected message.",
                          "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                        "reasoncode": "IPC::RC_INVALID_MSG_TYPE",
                         "userdata1": "Message type",
                         "userdata2": "Data word 0 of message",
                      },
            0x210101: {    "devdesc": "Devtree libfdt operation returned error",
                          "moduleid": "HANDLE_DEVTREE_ERRORS",
                        "reasoncode": "LIBFDT_ERROR_RC",
                         "userdata1": "Return Code",
                         "userdata2": "HUID",
                      },
            0x220601: {    "devdesc": "SBE partition contains unsupported version of Table of Contents",
                          "moduleid": "SBE_FIND_IN_PNOR",
                        "reasoncode": "SBE_UNSUPPORTED_TOC",
                         "userdata1": "CHIP EC",
                         "userdata2": "Expected TOC Version",
                      },
            0x220701: {    "devdesc": "Unsupported EYE-CATCHER found in TOC",
                          "moduleid": "SBE_FIND_IN_PNOR",
                        "reasoncode": "SBE_INVALID_EYECATCHER",
                         "userdata1": "SBE TOC EYE-CATCHER",
                         "userdata2": "Expected EYE-CATCHER",
                      },
            0x220801: {    "devdesc": "SBE image for current chip EC was not found in PNOR",
                          "moduleid": "SBE_FIND_IN_PNOR",
                        "reasoncode": "SBE_EC_NOT_FOUND",
                         "userdata1": "CHIP EC",
                         "userdata2": "PNOR Section ID",
                      },
            0x220D01: {    "devdesc": "Unsupported Target Type passed in",
                          "moduleid": "SBE_FIND_IN_PNOR",
                        "reasoncode": "SBE_INVALID_INPUT",
                         "userdata1": "Target Unit Id",
                         "userdata2": "Target Type",
                      },
            0x221D01: {    "devdesc": "EC level says 0, which is invalid",
                          "moduleid": "SBE_FIND_IN_PNOR",
                        "reasoncode": "SBE_UNSUPPORTED_EC",
                         "userdata1": "Target Huid",
                         "userdata2": "unused",
                      },
            0x240101: {    "devdesc": "LpcDD> LPC invalid address",
                          "moduleid": "LPC::MOD_LPCDD_CHECKADDR",
                        "reasoncode": "LPC::RC_INVALID_ADDR",
                         "userdata1": "LPC Address",
                         "userdata2": "LPC Transaction Type",
                      },
            0x250201: {    "devdesc": "msg_sendrecv() failed",
                          "moduleid": "IPMI::MOD_IPMISRV_SEND",
                        "reasoncode": "IPMI::RC_INVALID_SENDRECV",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "",
                      },
            0x250301: {    "devdesc": "msg_send() failed",
                          "moduleid": "IPMI::MOD_IPMISRV_SEND",
                        "reasoncode": "IPMI::RC_INVALID_SEND",
                         "userdata1": "rc from msq_send()",
                         "userdata2": "",
                      },
            0x270101: {    "devdesc": "Invalid operation type.",
                          "moduleid": "TPMDD_PERFORM_OP",
                        "reasoncode": "TPM_INVALID_OPERATION",
                         "userdata1": "TPM",
                         "userdata2": "Operation Type",
                      },
            0x270801: {    "devdesc": "TPM buffer length > 4 for read vendor op",
                          "moduleid": "TPMDD_PERFORM_OP",
                        "reasoncode": "TPM_OVERFLOW_ERROR",
                         "userdata1": "TPM",
                         "userdata2": "Operation",
                      },
            0x270B01: {    "devdesc": "Invalid operation type.",
                          "moduleid": "TPMDD_PERFORM_OP",
                        "reasoncode": "TPM_DISABLED_VIA_MRW",
                         "userdata1": "TPM",
                         "userdata2": "Operation Type",
                      },
            0x280101: {    "devdesc": "Timeout waiting for PSU command to complete",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_PSU_RESPONSE_TIMEOUT",
                         "userdata1": "Primary Status in mbox4",
                         "userdata2": "Secondary Status",
                      },
            0x280201: {    "devdesc": "Unexpected sequence number or non zero primary or secondary status",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_PSU_RESPONSE_ERROR",
                         "userdata1": "Indirect size or 9 for direct command",
                         "userdata2": "Request Sequence ID",
                      },
            0x280301: {    "devdesc": "SBE PSU device driver not ready to receive next command.",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_PSU_NOT_READY",
                         "userdata1": "Reserved",
                         "userdata2": "Request Control Flags",
                      },
            0x280401: {    "devdesc": "Timeout waiting for PSU command to complete",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_PSU_FFDC_MISSING",
                         "userdata1": "Primary Status in mbox4",
                         "userdata2": "Sequence Id in mbox4",
                      },
            0x285F01: {    "devdesc": "Call to PSU Chip Op returned an unexpected message type.",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_RECEIVED_UNEXPECTED_MSG",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested command class",
                      },
            0x286101: {    "devdesc": "Could not register mailbox message queue",
                          "moduleid": "SBEIO_PSU",
                        "reasoncode": "SBEIO_RC_KERNEL_REG_FAILED",
                         "userdata1": "rc from msq_q_register",
                         "userdata2": "",
                      },
            0x340301: {    "devdesc": "Exception occurred during execution of HBBL",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                        "reasoncode": "Bootloader::RC_STD_EXCEPTION",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340401: {    "devdesc": "Exception occurred during execution of HBBL",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                        "reasoncode": "Bootloader::RC_STD_EX_W_DSISR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340501: {    "devdesc": "Exception occurred during execution of HBBL",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                        "reasoncode": "Bootloader::RC_STD_EX_W_SRR1",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340601: {    "devdesc": "Exception occurred during execution of HBBL",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                        "reasoncode": "Bootloader::RC_HYPE_EXCEPTION",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x350101: {    "devdesc": "Invalid operation type.",
                          "moduleid": "NVDIMM_PERFORM_OP",
                        "reasoncode": "NVDIMM_INVALID_OPERATION",
                         "userdata1": "Operation Type",
                         "userdata2": "Chip to Access",
                      },
            0x350801: {    "devdesc": "I2C Buffer Length + Offset > Max Size",
                          "moduleid": "NVDIMM_PERFORM_OP",
                        "reasoncode": "NVDIMM_OVERFLOW_ERROR",
                         "userdata1": "Offset",
                         "userdata2": "Buffer Length",
                      },
            0x360101: {    "devdesc": "validateInputs> Invalid data length (!= 8 bytes)",
                          "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                        "reasoncode": "EXPSCOM::RC_INVALID_LENGTH",
                         "userdata1": "SCOM Address",
                         "userdata2": "Data Length",
                      },
            0x360201: {    "devdesc": "validateInputs> Invalid target type (!= OCMB_CHIP)",
                          "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                        "reasoncode": "EXPSCOM::RC_INVALID_MODEL_TYPE",
                         "userdata1": "SCOM Address",
                         "userdata2": "Model Type",
                      },
            0x360301: {    "devdesc": "validateInputs> Invalid OP type (!= READ or WRITE)",
                          "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                        "reasoncode": "EXPSCOM::RC_INVALID_OPTYPE",
                         "userdata1": "SCOM Address",
                         "userdata2": "Access Type",
                      },
            0x360401: {    "devdesc": "validateInputs> Invalid scom address, first 4 bytes should be 0's",
                          "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                        "reasoncode": "EXPSCOM::RC_INVALID_ADDRESS",
                         "userdata1": "SCOM Address",
                         "userdata2": "Target HUID",
                      },
            0x370B01: {    "devdesc": "Mismatch between calculated map value and what is in attribute xml",
                          "moduleid": "MMIO::MOD_MMIO_SETUP",
                        "reasoncode": "MMIO::RC_BAR_OFFSET_MISMATCH",
                         "userdata1": "Calculated Bar Offset",
                         "userdata2": "Bar offset from attribute",
                      },
            0x390101: {    "devdesc": "nvram_check failed during an attempt to read the NVRAM PNOR partition.",
                          "moduleid": "NVRAM::MOD_NVRAM_READ",
                        "reasoncode": "NVRAM::RC_NVRAM_CHECK_FAILED",
                         "userdata1": "rc from nvram_check",
                         "userdata2": "NVRAM virtual address",
                      },
            0x390201: {    "devdesc": "A nullptr was passed for i_key to nvramRead",
                          "moduleid": "NVRAM::MOD_NVRAM_READ",
                        "reasoncode": "NVRAM::RC_NVRAM_READ_NULL_KEY",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x410101: {    "devdesc": "A device read from the UCD didn't read the expected number of bytes.",
                          "moduleid": "UCD_RC::MOD_UCD_INIT",
                        "reasoncode": "UCD_RC::RC_DEVICE_READ_UNEXPECTED_SIZE_DEVICE_ID",
                         "userdata1": "Expected read size",
                         "userdata2": "Actual read size",
                      },
            0x410201: {    "devdesc": "A device read from the UCD didn't read the expected number of bytes.",
                          "moduleid": "UCD_RC::MOD_UCD_INIT",
                        "reasoncode": "UCD_RC::RC_DEVICE_READ_UNEXPECTED_SIZE_MFR_REVISION",
                         "userdata1": "Expected read size",
                         "userdata2": "Actual read size",
                      },
            0x450101: {    "devdesc": "The length of the buffer to write/read changed from the expected length.",
                          "moduleid": "SPI::SPI_OP_READ",
                        "reasoncode": "SPI::SPI_BUFFER_SIZE_MISMATCH",
                         "userdata1": "Target HUID of the SPI Master",
                         "userdata2": "Length of the request",
                      },
            0x460101: {    "devdesc": "Initialization of MCTP protocol between Host and BMC failed",
                          "moduleid": "MOD_MCTP_CHANNEL_INIT",
                        "reasoncode": "RC_CHANNEL_INACTIVE",
                         "userdata1": "kcs status register value",
                         "userdata2": "mctp version (should not have been set but might be useful)",
                      },
            0x900101: {    "devdesc": "Input Target Pointer is NULL",
                          "moduleid": "HDAT::MOD_UTIL_IS_FUNCTIONAL",
                        "reasoncode": "HDAT::RC_INVALID_OBJECT",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x10302: {    "devdesc": "Errl test. Error with non-decoded string and lots of trace buffers.",
                          "moduleid": "ERRORLOG::ERRL_TEST_MOD_ID",
                        "reasoncode": "ERRORLOG::ERRL_TEST_REASON_CODE",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x40402: {    "devdesc": "Read back value doesn't match write",
                          "moduleid": "XSCOM::XSCOM_TEST_XSCOM1",
                        "reasoncode": "XSCOM::XSCOM_DATA_UNMATCHED",
                         "userdata1": "Write value",
                         "userdata2": "Read back value",
                      },
            0x70302: {    "devdesc": "Timed out waiting for data in FIFO to read",
                          "moduleid": "I2C_READ",
                        "reasoncode": "I2C_FIFO_TIMEOUT",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x80502: {    "devdesc": "Module does not exist",
                          "moduleid": "VFS_RT_MODULE_ID",
                        "reasoncode": "VFS_MODULE_DOES_NOT_EXIST",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x80602: {    "devdesc": "Module is not a data module",
                          "moduleid": "VFS_RT_MODULE_ID",
                        "reasoncode": "VFS_INVALID_DATA_MODULE",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x90802: {    "devdesc": "When coverting from FAPI2::target to Targeting::target the resulting                                     Targeting::target's was incorrect",
                          "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                        "reasoncode": "RC_MISMATCHED_FAPI_TARG_TARGET",
                         "userdata1": "Actual Type",
                         "userdata2": "Expected Type",
                      },
            0x90902: {    "devdesc": "HB target found with unknown model attribute",
                          "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                        "reasoncode": "RC_UNKNOWN_MODEL",
                         "userdata1": "FAPI2 Type",
                         "userdata2": "HB Target HUID",
                      },
            0x90A02: {    "devdesc": "Unable to resolve FapiTarget from input",
                          "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                        "reasoncode": "RC_NULL_FAPI_TARGET",
                         "userdata1": "Fapi2 Expected Type",
                         "userdata2": "<unused>",
                      },
            0xB0702: {    "devdesc": "The attribute synchronization code on the FSP side was unable to complete the sync operation successfully.",
                          "moduleid": "TARG_MOD_ATTR_SYNC",
                        "reasoncode": "TARG_RC_ATTR_SYNC_TO_FSP_FAIL",
                         "userdata1": "return code from FSP attribute sync",
                         "userdata2": "page count for this section",
                      },
            0xB0802: {    "devdesc": "The attribute synchronization code on the FSP side was unable to fulfill the sync to HostBoot request.",
                          "moduleid": "TARG_MOD_ATTR_SYNC",
                        "reasoncode": "TARG_RC_ATTR_SYNC_REQUEST_TO_HB_FAIL",
                         "userdata1": "return code from FSP",
                         "userdata2": "section to sync",
                      },
            0xB0902: {    "devdesc": "The attribute synchronization from the FSP failed.",
                          "moduleid": "TARG_MOD_ATTR_SYNC",
                        "reasoncode": "TARG_RC_ATTR_SYNC_TO_HB_FAIL",
                         "userdata1": "return code",
                         "userdata2": "section to sync",
                      },
            0xC0302: {    "devdesc": "Invalid target encountered in processing of HW callout",
                          "moduleid": "HWAS::MOD_PROCESS_CALLOUT",
                        "reasoncode": "HWAS::RC_INVALID_TARGET",
                         "userdata1": "callout errlog PLID",
                         "userdata2": "",
                      },
            0xD0602: {    "devdesc": "Hypervisor firmware request interface not linked",
                          "moduleid": "MOD_FSISCOM_RT_SEND_SCOM_TO_FSP",
                        "reasoncode": "RC_RT_INTERFACE_ERR",
                         "userdata1": "target's HUID",
                         "userdata2": "SCOM address",
                      },
            0xD0702: {    "devdesc": "Unable to allocate firmware request messages",
                          "moduleid": "MOD_FSISCOM_RT_SEND_SCOM_TO_FSP",
                        "reasoncode": "RC_RT_NULL_FW_MSG_PTR",
                         "userdata1": "target's HUID",
                         "userdata2": "SCOM address",
                      },
            0xF0302: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_DISABLE",
                        "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                         "userdata1": "MSG_INTR_DISABLE",
                         "userdata2": "0",
                      },
            0x100202: {    "devdesc": "MDMT could not find a functional node",
                          "moduleid": "TOD_BUILD_TOD_DRAWERS",
                        "reasoncode": "TOD_NO_FUNC_NODE_AVAILABLE",
                         "userdata1": "system target's HUID",
                         "userdata2": "",
                      },
            0x100302: {    "devdesc": "No TOD drawer could be configured for this topology type",
                          "moduleid": "TOD_BUILD_TOD_DRAWERS",
                        "reasoncode": "TOD_NO_DRAWERS",
                         "userdata1": "TOD configuration",
                         "userdata2": "",
                      },
            0x110102: {    "devdesc": "MboxDD::write> Invalid data length (> msg_t size)",
                          "moduleid": "MBOX::MOD_MBOXDD_WRITE",
                        "reasoncode": "MBOX::RC_INVALID_LENGTH",
                         "userdata1": "Target ID String...",
                         "userdata2": "Data Length",
                      },
            0x110402: {    "devdesc": "MboxDD::write> Message still pending",
                          "moduleid": "MBOX::MOD_MBOXDD_WRITE",
                        "reasoncode": "MBOX::RC_MSG_PENDING",
                         "userdata1": "Target ID String...",
                         "userdata2": "Status/Control Register",
                      },
            0x120202: {    "devdesc": "Invalid address and size returned from HDAT",
                          "moduleid": "DUMP::DUMP_SEND_MBOX_MSG",
                        "reasoncode": "DUMP::DUMP_NO_HDAT_ADDR",
                         "userdata1": "Address returned",
                         "userdata2": "Table type Requested",
                      },
            0x140302: {    "devdesc": "MDIA monitor task crashed",
                          "moduleid": "MONITOR_MAIN_THREAD",
                        "reasoncode": "MONITOR_THREAD_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "Task Id that crashed",
                      },
            0x160202: {    "devdesc": "Bad memory pointer received.",
                          "moduleid": "Util::UTIL_MOD_MEM_WRITE",
                        "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                         "userdata1": "Task ID.",
                         "userdata2": "End of File (boolean)",
                      },
            0x160302: {    "devdesc": "End of file reached.",
                          "moduleid": "Util::UTIL_MOD_MEM_WRITE",
                        "reasoncode": "Util::UTIL_ERC_EOF",
                         "userdata1": "Task ID.",
                         "userdata2": "End of File (boolean)",
                      },
            0x170402: {    "devdesc": "System target was NULL!",
                          "moduleid": "MOD_START_PAYLOAD_CALL_SHUTDOWN",
                        "reasoncode": "RC_TARGET_NULL",
                         "userdata1": "<UNUSED>",
                         "userdata2": "<UNUSED>",
                      },
            0x173702: {    "devdesc": "Write of HID SPR failed",
                          "moduleid": "MOD_START_PAYLOAD_CALL_SHUTDOWN",
                        "reasoncode": "RC_FAILED_WRITE_SPR",
                         "userdata1": "current value of HID",
                         "userdata2": "write value attempted to HID",
                      },
            0x190102: {    "devdesc": "ScanDD::scanPerformOp> Invalid ringlength",
                          "moduleid": "SCAN::MOD_SCANDD_DOPIBSCAN",
                        "reasoncode": "SCAN::RC_INVALID_LENGTH",
                         "userdata1": "SCAN Ring Address",
                         "userdata2": "SCAN ring length",
                      },
            0x190202: {    "devdesc": "ScanDD::scanPerformOp> Invalid Ring Address",
                          "moduleid": "SCAN::MOD_SCANDD_DOPIBSCAN",
                        "reasoncode": "SCAN::RC_INVALID_RING_ADDRESS",
                         "userdata1": "SCAN Ring Address",
                         "userdata2": "TARGET",
                      },
            0x190302: {    "devdesc": "ScanDD::scanPerformOp> Invalid operation type",
                          "moduleid": "SCAN::MOD_SCANDD_DOPIBSCAN",
                        "reasoncode": "SCAN::RC_INVALID_OPERATION",
                         "userdata1": "SCAN Address",
                         "userdata2": "Operation Type (i_opType)",
                      },
            0x190402: {    "devdesc": "ScanDD::scanPerformOp> Invalid IObuf length",
                          "moduleid": "SCAN::MOD_SCANDD_DOPIBSCAN",
                        "reasoncode": "SCAN::RC_INVALID_BUF_SIZE",
                         "userdata1": "SCAN IO buffer length",
                         "userdata2": "SCAN ring length",
                      },
            0x190c02: {    "devdesc": "ScanDD::scanDoPibScan> Got a data mismatch when reading back the header",
                          "moduleid": "SCAN::MOD_SCANDD_DOPIBSCAN",
                        "reasoncode": "SCAN::RC_HEADER_DATA_MISMATCH",
                         "userdata1": "SCAN Ring Address",
                         "userdata2": "Operation Type (i_opType)",
                      },
            0x1E0502: {    "devdesc": "mm_set_permission(EXECUTABLE) failed for Secure ROM",
                          "moduleid": "SECUREBOOT::MOD_SECURE_ROM_INIT",
                        "reasoncode": "SECUREBOOT::RC_SET_PERMISSION_FAIL_EXE",
                         "userdata1": "l_rc",
                         "userdata2": "iv_securerom",
                      },
            0x1E0B02: {    "devdesc": "Valid securerom not present",
                          "moduleid": "SECUREBOOT::MOD_SECURE_ROM_INIT",
                        "reasoncode": "SECUREBOOT::RC_SECROM_INVALID",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x210202: {    "devdesc": "Invalid attribute size of 0",
                          "moduleid": "DEVTREE_SYNC_ATTRS",
                        "reasoncode": "TARGET_ATTR_ZERO_SIZE",
                         "userdata1": "HUID",
                         "userdata2": "Attribute ID",
                      },
            0x210302: {    "devdesc": "Error reading targeting attribute",
                          "moduleid": "DEVTREE_SYNC_ATTRS",
                        "reasoncode": "GET_TARGET_ATTR_FAILED",
                         "userdata1": "HUID",
                         "userdata2": "Attribute ID",
                      },
            0x220402: {    "devdesc": "updateProcessorSbeSeeproms> mm_remove_pages RELEASE failed",
                          "moduleid": "SBE_UPDATE_SEEPROMS",
                        "reasoncode": "SBE_REMOVE_PAGES_FOR_EC",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x221B02: {    "devdesc": "SBE update is being skipped during MPIPL",
                          "moduleid": "SBE_UPDATE_SEEPROMS",
                        "reasoncode": "SBE_UPDATE_DURING_MPIPL",
                         "userdata1": "Target huid id",
                         "userdata2": "Update actions",
                      },
            0x240302: {    "devdesc": "LpcDD::_readLPC> Invalid buffer size requested (>4 bytes)",
                          "moduleid": "LPC::MOD_LPCDD_READLPC",
                        "reasoncode": "LPC::RC_BAD_ARG",
                         "userdata1": "LPC Address",
                         "userdata2": "LPC Transaction Type",
                      },
            0x250102: {    "devdesc": "msg_respond() failed",
                          "moduleid": "IPMI::MOD_IPMISRV_REPLY",
                        "reasoncode": "IPMI::RC_INVALID_QRESPONSE",
                         "userdata1": "rc from msg_respond()",
                         "userdata2": "",
                      },
            0x250902: {    "devdesc": "an async completion code was not CC_OK",
                          "moduleid": "IPMI::MOD_IPMISRV_REPLY",
                        "reasoncode": "IPMI::RC_READ_EVENT_FAILURE",
                         "userdata1": "command of message",
                         "userdata2": "completion code",
                      },
            0x260502: {    "devdesc": "OCC not ready for target state",
                          "moduleid": "HTMGT_MOD_WAIT_FOR_OCC_READY",
                        "reasoncode": "HTMGT_RC_OCC_NOT_READY",
                         "userdata1": "OCC instance",
                         "userdata2": "poll attempts",
                      },
            0x281002: {    "devdesc": "Timeout waiting for upstream FIFO to have room to write",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_UPSTREAM_TIMEOUT",
                         "userdata1": "Timeout in NS",
                         "userdata2": "",
                      },
            0x281102: {    "devdesc": "EOT not received before downstream buffer full.",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_NO_DOWNSTREAM_EOT",
                         "userdata1": "FIFO command class and command",
                         "userdata2": "Response buffer size",
                      },
            0x281202: {    "devdesc": "The distance to the status header is not within the response buffer.",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_INVALID_STATUS_DISTANCE",
                         "userdata1": "FIFO command class and command",
                         "userdata2": "Distance to status in words",
                      },
            0x281302: {    "devdesc": "Status header does not start with magic number or non-zero primary or secondary status",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_RESPONSE_ERROR",
                         "userdata1": "FIFO command class and command",
                         "userdata2": "Should be magic value 0xC0DE",
                      },
            0x281402: {    "devdesc": "Timeout waiting for downstream FIFO to have data to receive",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_DOWNSTREAM_TIMEOUT",
                         "userdata1": "Timeout in NS",
                         "userdata2": "FIFO Status",
                      },
            0x281502: {    "devdesc": "Request length must be 8 bytes",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_INVALID_LENGTH",
                         "userdata1": "Request Address",
                         "userdata2": "Invalid request length",
                      },
            0x281602: {    "devdesc": "Invalide operation. Read and Write supported.",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_INVALID_OPERATION",
                         "userdata1": "Request Address",
                         "userdata2": "Request operation",
                      },
            0x281702: {    "devdesc": "Null target passed",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_NULL_TARGET",
                         "userdata1": "Request Address",
                         "userdata2": "",
                      },
            0x281802: {    "devdesc": "Master Proc is not supported",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_MASTER_TARGET",
                         "userdata1": "Request Address",
                         "userdata2": "HUID of master proc",
                      },
            0x281902: {    "devdesc": "Master Sentinel target is not supported",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_FIFO_SENTINEL_TARGET",
                         "userdata1": "Request Address",
                         "userdata2": "",
                      },
            0x285F02: {    "devdesc": "Call to FIFO Chip Op returned an unexpected message type.",
                          "moduleid": "SBEIO_FIFO",
                        "reasoncode": "SBEIO_RECEIVED_UNEXPECTED_MSG",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested command class",
                      },
            0x2BA002: {    "devdesc": "TPM_Startup operation failure.",
                          "moduleid": "MOD_TPM_CMD_STARTUP",
                        "reasoncode": "RC_TPM_START_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "0",
                      },
            0x2BBF02: {    "devdesc": "SBE failed to setup the TPM",
                          "moduleid": "MOD_TPM_CMD_STARTUP",
                        "reasoncode": "RC_TPM_START_SBE_SETUP_FAILED",
                         "userdata1": "responseCode",
                         "userdata2": "TPM",
                      },
            0x334202: {    "devdesc": "HB OCMB_CHIP target found with unknown model based on ATTR_CHIP_ID",
                          "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                        "reasoncode": "RC_UNKNOWN_OCMB_CHIP_TYPE",
                         "userdata1": "FAPI2 Type",
                         "userdata2": "HB Target HUID",
                      },
            0x340702: {    "devdesc": "Uncorrectable ECC error found in HBB",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_MAIN",
                        "reasoncode": "Bootloader::RC_REMOVE_ECC_FAIL",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340F02: {    "devdesc": "Not enough memory to load boot firmware",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_MAIN",
                        "reasoncode": "Bootloader::RC_BAD_WORK_LEN",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x370802: {    "devdesc": "OCMB MMIO read failed",
                          "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                        "reasoncode": "MMIO::RC_BAD_MMIO_READ",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370902: {    "devdesc": "OCMB MMIO write failed",
                          "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                        "reasoncode": "MMIO::RC_BAD_MMIO_WRITE",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370C02: {    "devdesc": "OCMB MMIO read failed due to channel checkstop",
                          "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                        "reasoncode": "MMIO::RC_MMIO_CHAN_CHECKSTOP",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x410302: {    "devdesc": "The UCD flash image's eyecatcher did not match the expected value",
                          "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                        "reasoncode": "UCD_RC::UCD_INVALID_EYECATCHER",
                         "userdata1": "Expected eyecatcher",
                         "userdata2": "Actual eyecatcher",
                      },
            0x410402: {    "devdesc": "The UCD flash image's major version number is not supported.",
                          "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                        "reasoncode": "UCD_RC::UCD_INVALID_MAJOR_VER",
                         "userdata1": "Current major version supported",
                         "userdata2": "Advertised major version",
                      },
            0x410502: {    "devdesc": "The UCD flash image's TOC entry size is smaller than expected.",
                          "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                        "reasoncode": "UCD_RC::UCD_TOC_ENTRY_TOO_SMALL",
                         "userdata1": "Minimum required TOC entry size",
                         "userdata2": "Advertised TOC entry size",
                      },
            0x410602: {    "devdesc": "The UCD device's device ID did not match the expected device ID from the UCD sub-flash image.  This likely implies an escape of new parts into systems that are not supported by firmware.  UCD will be marked as non-functional.",
                          "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                        "reasoncode": "UCD_RC::UCD_UNSUPPORTED_DEVICE_ID",
                         "userdata1": "UCD's HUID",
                         "userdata2": "",
                      },
            0x410702: {    "devdesc": "Advertised UCD sub-flash image offset+size would pass the end of the UCD flash image.",
                          "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                        "reasoncode": "UCD_RC::UCD_EOF",
                         "userdata1": "UCD's HUID",
                         "userdata2": "",
                      },
            0x450102: {    "devdesc": "The length of the buffer to write/read changed from the expected length.",
                          "moduleid": "SPI::SPI_OP_WRITE",
                        "reasoncode": "SPI::SPI_BUFFER_SIZE_MISMATCH",
                         "userdata1": "Target HUID of the SPI Master",
                         "userdata2": "Length of the request",
                      },
            0x900202: {    "devdesc": "Top level target not found",
                          "moduleid": "HDAT::MOD_PCIA_LOAD",
                        "reasoncode": "HDAT::RC_TOP_LVL_TGT_NOT_FOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x10303: {    "devdesc": "Errl test. Error with non-decoded string and lots of trace buffers.",
                          "moduleid": "ERRORLOG::ERRL_RT_TEST_MOD_ID",
                        "reasoncode": "ERRORLOG::ERRL_TEST_REASON_CODE",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x40503: {    "devdesc": "mmio_dev_unmap() returns error",
                          "moduleid": "XSCOM_GET_TARGET_VIRT_ADDR",
                        "reasoncode": "XSCOM_MMIO_UNMAP_ERR",
                         "userdata1": "Return Code",
                         "userdata2": "Unmap address",
                      },
            0x50803: {    "devdesc": "Request to send Istep Complete msg to Fsp, but no outstanding message from Fsp found.",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "NO_MSG_PRESENT",
                         "userdata1": "Current Istep",
                         "userdata2": "Current SubStep",
                      },
            0x50903: {    "devdesc": "IStep failed and HW deconfigured. Looped back to an earlier istep (Reconfigure loop).",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_RECONFIG_LOOP_ENTERED",
                         "userdata1": "Istep that failed",
                         "userdata2": "Substep that failed",
                      },
            0x50a03: {    "devdesc": "Hostboot has requested a reconfig loop due to a hardware error.  Causes could be: - deconfiguration during an istep outside of the the reconfig loop - deconfiguration while running in istep mode - deconfiguration in mfg mode - exceeded the number of allowed reconfig attempts - recoverable hardware error that requires a reboot to clear out",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_FAILED_DUE_TO_DECONFIG",
                         "userdata1": "Istep that failed",
                         "userdata2": "SubStep that failed",
                      },
            0x50b03: {    "devdesc": "Received shutdown request from FSP",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "SHUTDOWN_REQUESTED_BY_FSP",
                         "userdata1": "Current IStep",
                         "userdata2": "Current SubStep",
                      },
            0x50c03: {    "devdesc": "handleProcFabIovalidMsg called during MPIPL, which is illegal.",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_INVALID_ON_MPIPL",
                         "userdata1": "MPIPL State",
                         "userdata2": "N/A",
                      },
            0x50d03: {    "devdesc": "Istep messaged received by non-master node.",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_NON_MASTER_NODE_MSG",
                         "userdata1": "Istep Requested",
                         "userdata2": "Substep Requested",
                      },
            0x51003: {    "devdesc": "Received shutdown request due to deconfigure outside of reconfig loop",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "SHUTDOWN_NOT_RECONFIG_LOOP",
                         "userdata1": "Current IStep",
                         "userdata2": "Current SubStep",
                      },
            0x51103: {    "devdesc": "Istep skip prevented in secure mode",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_SKIP_ATTEMPTED",
                         "userdata1": "istep requested",
                         "userdata2": "substep requested",
                      },
            0x51203: {    "devdesc": "Istep processing has terminated due to normal shutdown activity, secure boot key transition, or terminating error",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_PROCESSING_DISABLED",
                         "userdata1": "Istep Requested",
                         "userdata2": "Substep Requested",
                      },
            0x51603: {    "devdesc": "sendAttnMonitorChipIdMsg failed at the FSP level.  Potential checkstops may not be properly handled.",
                          "moduleid": "ISTEP_INITSVC_MOD_ID",
                        "reasoncode": "ISTEP_ATTN_MONITOR_MSG_FAILED",
                         "userdata1": "PLID of failure on FSP",
                         "userdata2": "Number of huids in msg",
                      },
            0x60303: {    "devdesc": "PnorRP::getSectionInfo> Invalid Address for read/write or prohibited by secureboot",
                          "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                        "reasoncode": "PNOR::RC_INVALID_SECTION",
                         "userdata1": "Size of section",
                         "userdata2": "TOC used",
                      },
            0x60503: {    "devdesc": "PnorRP::getSectionInfo> RP not properly initialized",
                          "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                        "reasoncode": "PNOR::RC_STARTUP_FAIL",
                         "userdata1": "Requested Section",
                         "userdata2": "Startup RC",
                      },
            0x61D03: {    "devdesc": "Protected Payload Size is 0",
                          "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                        "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                         "userdata1": "PNOR section",
                         "userdata2": "Section's secure flag",
                      },
            0x70303: {    "devdesc": "Timed out waiting for space to write into FIFO.",
                          "moduleid": "I2C_WRITE",
                        "reasoncode": "I2C_FIFO_TIMEOUT",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x80703: {    "devdesc": "VFS RP Task crashed.",
                          "moduleid": "VFS_WATCHER",
                        "reasoncode": "VFS_TASK_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "task Rc",
                      },
            0xB0c03: {    "devdesc": "Targeting target's type not supported by runtime code",
                          "moduleid": "TARG_RT_GET_RT_TARGET",
                        "reasoncode": "TARG_RT_TARGET_TYPE_NOT_SUPPORTED",
                         "userdata1": "Target's HUID",
                         "userdata2": "target's targeting type",
                      },
            0xC0403: {    "devdesc": "Insufficient hardware to continue.",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_INSUFFICIENT_HW",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0xC0503: {    "devdesc": "checkMinimumHardware found no functional processor cores on the master proc",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_NO_CORES_FUNC",
                         "userdata1": "HUID of node",
                         "userdata2": "HUID of master proc",
                      },
            0xC0603: {    "devdesc": "checkMinimumHardware found no functional dimm cards.",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_NO_MEMORY_FUNC",
                         "userdata1": "HUID of node",
                         "userdata2": "number of present, non-functional dimms",
                      },
            0xC0703: {    "devdesc": "checkMinimumHardware found no functional master processor on this node",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_NO_PROCS_FUNC",
                         "userdata1": "HUID of node",
                         "userdata2": "number of present procs",
                      },
            0xC0803: {    "devdesc": "checkMinimumHardware found no functional nodes on the system",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_NO_NODES_FUNC",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0xC0B03: {    "devdesc": "checkCriticalResources found a critical resource to be deconfigured",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_MISSING_CRITICAL_RESOURCE",
                         "userdata1": "Number of critical resources",
                         "userdata2": "HUID of first critical resource found",
                      },
            0xC0E03: {    "devdesc": "checkMinimumHardware found no functional NX chiplets",
                          "moduleid": "MOD_CHECK_MIN_HW",
                        "reasoncode": "RC_SYSAVAIL_NO_NX_FUNC",
                         "userdata1": "HUID of node",
                         "userdata2": "number of present nonfunctional NX chiplets",
                      },
            0xD0303: {    "devdesc": "Multi-SCOM read did not return correct SCOMs",
                          "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                        "reasoncode": "RC_INVALID_LENGTH",
                         "userdata1": "target's HUID",
                         "userdata2": "# of SCOMs requested",
                      },
            0xD0603: {    "devdesc": "Hypervisor firmware request interface not linked",
                          "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                        "reasoncode": "RC_RT_INTERFACE_ERR",
                         "userdata1": "target's HUID",
                         "userdata2": "# of SCOMs to read",
                      },
            0xD0703: {    "devdesc": "Unable to allocate firmware request messages",
                          "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                        "reasoncode": "RC_RT_NULL_FW_MSG_PTR",
                         "userdata1": "target's HUID",
                         "userdata2": "# of SCOMs to read",
                      },
            0xE0903: {    "devdesc": "I2C write page size is zero.",
                          "moduleid": "EEPROM_WRITE",
                        "reasoncode": "EEPROM_I2C_WRITE_PAGE_SIZE_ZERO",
                         "userdata1": "HUID of target",
                         "userdata2": "Chip to Access",
                      },
            0xF0203: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_REGISTER",
                        "reasoncode": "INTR::RC_REGISTRY_NOT_READY",
                         "userdata1": "Interrupt type to register",
                         "userdata2": "0",
                      },
            0x101303: {    "devdesc": "No valid MDMT found on either topology",
                          "moduleid": "TOD_QUERY_ACTIVE_CONFIG",
                        "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x101403: {    "devdesc": "MDMT not found on active toplology",
                          "moduleid": "TOD_QUERY_ACTIVE_CONFIG",
                        "reasoncode": "TOD_NO_MDMT_ON_ACTIVE_CONFIG",
                         "userdata1": "Active configuration",
                         "userdata2": "",
                      },
            0x110503: {    "devdesc": "Invalid message or message queue",
                          "moduleid": "MBOX::MOD_MBOXSRV_SEND",
                        "reasoncode": "MBOX::RC_INVALID_QUEUE",
                         "userdata1": "returncode from msg_sendrecv()",
                         "userdata2": "",
                      },
            0x110D03: {    "devdesc": "Host boot mailbox service is not available at this time.",
                          "moduleid": "MBOX::MOD_MBOXSRV_SEND",
                        "reasoncode": "MBOX::RC_MBOX_SERVICE_NOT_READY",
                         "userdata1": "The destination message queue id",
                         "userdata2": "",
                      },
            0x120D03: {    "devdesc": "Invalid address and size returned from HDAT",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_PDAT_INVALID_ADDR",
                         "userdata1": "Table address returned",
                         "userdata2": "Table size returned",
                      },
            0x120E03: {    "devdesc": "Cannot unmap the PDAT Source Array Address",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_PDAT_CANNOT_UNMAP_SRC_ADDR",
                         "userdata1": "VA address of Source Array Address for PDAT",
                         "userdata2": "rc value from unmap",
                      },
            0x120F03: {    "devdesc": "Cannot unmap the PDAT Destinatin Array Addr",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_PDAT_CANNOT_UNMAP_DST_ADDR",
                         "userdata1": "VA of Destination Array Address for PDAT",
                         "userdata2": "rc value from unmap",
                      },
            0x121003: {    "devdesc": "Insufficient space to copy architected registers",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_PDAT_INSUFFICIENT_SPACE",
                         "userdata1": "Hypervisor reserved memory size",
                         "userdata2": "Memory needed to copy architected register data",
                      },
            0x121103: {    "devdesc": "Mismatch between the version of structure supported by both SBE and HB.",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_PDAT_VERSION_MISMATCH",
                         "userdata1": "Structure version obtained from SBE",
                         "userdata2": "Structure version supported by HB",
                      },
            0x121203: {    "devdesc": "SBE failed to collect architected register (ref userdata 1)",
                          "moduleid": "DUMP::DUMP_ARCH_REGS",
                        "reasoncode": "DUMP::DUMP_INVALID_ARCH_REG_DATA",
                         "userdata1": "PIR value",
                         "userdata2": "Register Address/Offset",
                      },
            0x160403: {    "devdesc": "The LID transfer code on the FSP side was unable to fulfill the LID SEND_TO_HB request.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLID",
                        "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                         "userdata1": "return code from FSP",
                         "userdata2": "LID ID",
                      },
            0x160503: {    "devdesc": "DMA message contains data for wrong LID.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLID",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_DATA",
                         "userdata1": "received LID ID",
                         "userdata2": "expected LID ID",
                      },
            0x160603: {    "devdesc": "Insufficient space provided for LID by calling function.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLID",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                         "userdata1": "Allocated Size",
                         "userdata2": "Size needed for current data page",
                      },
            0x160703: {    "devdesc": "Invalid Message type received from FSP when transferring LID pages.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLID",
                        "reasoncode": "Util::UTIL_LIDMGR_UNSUP_MSG",
                         "userdata1": "LID ID",
                         "userdata2": "Message Type",
                      },
            0x174E03: {    "devdesc": "Kernel returned error when trying to activate core.",
                          "moduleid": "MOD_HOST_ACTIVATE_SECONDARY_CORES",
                        "reasoncode": "RC_SECONDARY_CORE_WAKEUP_ERROR",
                         "userdata1": "PIR of failing core.",
                         "userdata2": "HUID of failing core.",
                      },
            0x180303: {    "devdesc": "PRD task crashed",
                          "moduleid": "ATTN_PRD_TASK_MODULE",
                        "reasoncode": "ATTN_PRD_TASK_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "Task Id that crashed",
                      },
            0x1A0203: {    "devdesc": "HDAT Header data not as expected",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_CHECK_HEADER",
                        "reasoncode": "RUNTIME::RC_BAD_HDAT_HEADER",
                         "userdata1": "Actual Header: id",
                         "userdata2": "Actual Header: version",
                      },
            0x1E0703: {    "devdesc": "ROM_verify() Call Failed",
                          "moduleid": "SECUREBOOT::MOD_SECURE_ROM_VERIFY",
                        "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                         "userdata1": "l_rc",
                         "userdata2": "l_hw_parms.log",
                      },
            0x210403: {    "devdesc": "Error reading devtree data",
                          "moduleid": "DEBUG_READ_CMP_DATA",
                        "reasoncode": "TARGET_DTREE_SIZE_MISMATCH",
                         "userdata1": "HUID",
                         "userdata2": "Attribute ID",
                      },
            0x220A03: {    "devdesc": "SB Keyword in MVPD has invalid size",
                          "moduleid": "SBE_GETSET_MVPD_VERSION",
                        "reasoncode": "SBE_MVPD_LEN_INVALID",
                         "userdata1": "Discovered VPD Size",
                         "userdata2": "Expected VPD Size",
                      },
            0x230003: {    "devdesc": "Invalid GPIO device type",
                          "moduleid": "GPIO_READATTRIBUTES",
                        "reasoncode": "GPIO_INVALID_DEVICE_TYPE",
                         "userdata1": "Device type",
                         "userdata2": "HUID of target",
                      },
            0x230103: {    "devdesc": "GPIO device attribute was not found",
                          "moduleid": "GPIO_READATTRIBUTES",
                        "reasoncode": "GPIO_ATTR_INFO_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "GPIO device type",
                      },
            0x250403: {    "devdesc": "Command not valid for this sensor.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_CMD",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "bytes [0-1]sensor name bytes [2-3]sensor number bytes [4-7]HUID of target.",
                      },
            0x250503: {    "devdesc": "Set sensor reading command failed.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_SETTABLE",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "bytes [0-1]sensor name bytes [2-3]sensor number bytes [4-7]HUID of target.",
                      },
            0x250603: {    "devdesc": "Set sensor reading command failed.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_EVENT_DATA_NOT_SETTABLE",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "bytes[0-3]sensor number bytes[4-7]HUID of target.",
                      },
            0x250703: {    "devdesc": "Requested sensor is not present.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_PRESENT",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "bytes [0-1]sensor name bytes [2-3]sensor number bytes [4-7]HUID of target.",
                      },
            0x250803: {    "devdesc": "Set sensor reading command failed.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_SET_SENSOR_FAILURE",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "bytes [0-1]sensor name bytes [2-3]sensor number bytes [4-7]HUID of target.",
                      },
            0x250b03: {    "devdesc": "Set sensor reading command failed.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_SENSOR_READING_NOT_AVAIL",
                         "userdata1": "sensor status indicating reason for reading not available",
                         "userdata2": "sensor number",
                      },
            0x250c03: {    "devdesc": "Request to get sensor type form the bmc failed.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_GET_SENSOR_TYPE_CMD_FAILED",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "",
                      },
            0x250d03: {    "devdesc": "Requested sensor attribute not found.",
                          "moduleid": "IPMI::MOD_IPMISENSOR",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_FOUND",
                         "userdata1": "Returned sensor number.",
                         "userdata2": "bytes [0-3]sensor name bytes [4-7]HUID of target.",
                      },
            0x281A03: {    "devdesc": "If the size of the FFDC package exceeds our allocated buffer size, we log it.",
                          "moduleid": "SBEIO_FFDC_PARSER",
                        "reasoncode": "SBEIO_FFDC_PARSER_BUFF_OVERFLOW",
                         "userdata1": "size of FFDC package that overflows the buffer",
                         "userdata2": "",
                      },
            0x2BA203: {    "devdesc": "Command failure reading TPM FW version.",
                          "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                        "reasoncode": "RC_TPM_GETCAP_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "0",
                      },
            0x2BA303: {    "devdesc": "Command failure reading TPM FW version.",
                          "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                        "reasoncode": "RC_TPM_GETCAP_FW_INVALID_RESP",
                         "userdata1": "capability",
                         "userdata2": "property",
                      },
            0x2BA403: {    "devdesc": "Command failure reading TPM FW version.",
                          "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                        "reasoncode": "RC_TPM_GETCAP2_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "0",
                      },
            0x2BA503: {    "devdesc": "Command failure reading TPM FW version.",
                          "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                        "reasoncode": "RC_TPM_GETCAP2_FW_INVALID_RESP",
                         "userdata1": "capability",
                         "userdata2": "property",
                      },
            0x340903: {    "devdesc": "FFS header checksum error",
                          "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                        "reasoncode": "Bootloader::RC_HDR_CHECKSUM_ERR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340A03: {    "devdesc": "Check FFS header error(s)",
                          "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                        "reasoncode": "Bootloader::RC_CHECK_HEADER_ERR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x340B03: {    "devdesc": "Parse FFS entries error",
                          "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                        "reasoncode": "Bootloader::RC_PARSE_ENTRIES_ERR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x350903: {    "devdesc": "I2C write page size is zero.",
                          "moduleid": "NVDIMM_WRITE",
                        "reasoncode": "NVDIMM_I2C_WRITE_PAGE_SIZE_ZERO",
                         "userdata1": "HUID of target",
                         "userdata2": "",
                      },
            0x370A03: {    "devdesc": "Unable to find parent processor for target.",
                          "moduleid": "MMIO::MOD_MMIO_GET_PROC_SCOM",
                        "reasoncode": "MMIO::RC_PROC_NOT_FOUND",
                         "userdata1": "Target huid",
                         "userdata2": "SCOM address",
                      },
            0x410803: {    "devdesc": "The UCD flash image commandline is not supported",
                          "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                        "reasoncode": "UCD_RC::UCD_UNSUPPORTED_OPERATION_REQUEST",
                         "userdata1": "HUID of UCD Target",
                         "userdata2": "The order of the operation",
                      },
            0x410903: {    "devdesc": "A 'new line' character was not found while processing this UCD flash image's command line",
                          "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                        "reasoncode": "UCD_RC::UCD_INVALID_COMMANDLINE",
                         "userdata1": "HUID of UCD Target",
                         "userdata2": "The order of this operation",
                      },
            0x410D03: {    "devdesc": "There was an error while parsing a field in this UCD flash image's command line",
                          "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                        "reasoncode": "UCD_RC::UCD_FIELD_PARSE_ERROR",
                         "userdata1": "HUID of UCD Target",
                         "userdata2": "The Field Location of the parse error",
                      },
            0x450203: {    "devdesc": "The combination of the offset and amount to copy given would have caused a buffer overrun.",
                          "moduleid": "SPI::SPI_COPY_TO_BUFFER",
                        "reasoncode": "SPI::SPI_INVALID_PARAMETERS",
                         "userdata1": "The offset from which to begin copying data",
                         "userdata2": "The amount of data to copy to the destination",
                      },
            0x900103: {    "devdesc": "Input Target Pointer is NULL",
                          "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                        "reasoncode": "HDAT::RC_INVALID_OBJECT",
                         "userdata1": "Index of proc target",
                         "userdata2": "",
                      },
            0x900303: {    "devdesc": "Invalid input target attribute",
                          "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                        "reasoncode": "HDAT::RC_INVALID_TGT_ATTR",
                         "userdata1": "Index of proc target",
                         "userdata2": "Target HUID",
                      },
            0x900603: {    "devdesc": "Target List is Empty",
                          "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                        "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x30504: {    "devdesc": "Indirect SCOM Read error",
                          "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                        "reasoncode": "SCOM::SCOM_INDIRECT_READ_FAIL",
                         "userdata1": "Address",
                         "userdata2": "Indirect Scom Status Register",
                      },
            0x30604: {    "devdesc": "Indirect SCOM complete bit did not come on",
                          "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                        "reasoncode": "SCOM::SCOM_INDIRECT_READ_TIMEOUT",
                         "userdata1": "Address",
                         "userdata2": "Indirect Scom Status Register",
                      },
            0x30704: {    "devdesc": "Indirect SCOM Write failed for this address",
                          "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                        "reasoncode": "SCOM::SCOM_INDIRECT_WRITE_FAIL",
                         "userdata1": "Address",
                         "userdata2": "Indirect Scom Status Register",
                      },
            0x30804: {    "devdesc": "Indirect SCOM complete bit did not come on",
                          "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                        "reasoncode": "SCOM::SCOM_INDIRECT_WRITE_TIMEOUT",
                         "userdata1": "Address",
                         "userdata2": "Indirect Scom Status Register",
                      },
            0x30E04: {    "devdesc": "Unsupported indirect scom form",
                          "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                        "reasoncode": "SCOM::SCOM_INVALID_FORM",
                         "userdata1": "Address",
                         "userdata2": "HUID of Target",
                      },
            0x40404: {    "devdesc": "Read back value doesn't match write",
                          "moduleid": "XSCOM::XSCOM_TEST_XSCOM2",
                        "reasoncode": "XSCOM::XSCOM_DATA_UNMATCHED",
                         "userdata1": "Write value",
                         "userdata2": "Read back value",
                      },
            0x50304: {    "devdesc": "One or more CxxTest Unit Tests failed.",
                          "moduleid": "CXXTEST_MOD_ID",
                        "reasoncode": "CXXTEST_FAILED_TEST",
                         "userdata1": "number of failed tests",
                         "userdata2": "<UNUSED>",
                      },
            0x60204: {    "devdesc": "PnorRP::computeSection> Invalid Address",
                          "moduleid": "PNOR::MOD_PNORRP_COMPUTESECTION",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "Requested Virtual Address",
                         "userdata2": "<unused>",
                      },
            0x80704: {    "devdesc": "VFS Task crashed.",
                          "moduleid": "VFS_MODULE_LOAD_MONITOR",
                        "reasoncode": "VFS_TASK_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "Task Status",
                      },
            0xA0404: {    "devdesc": "FsiDD::handleOpbErrors> Error during FSI access",
                          "moduleid": "FSI::MOD_FSIDD_HANDLEOPBERRORS",
                        "reasoncode": "FSI::RC_OPB_ERROR",
                         "userdata1": "Relative FSI Address",
                         "userdata2": "Absolute FSI Address",
                      },
            0xC0A04: {    "devdesc": "Gard record(s) not applied due to a lack of resources.",
                          "moduleid": "MOD_DECONFIG_TARGETS_FROM_GARD",
                        "reasoncode": "RC_RESOURCE_RECOVERED",
                         "userdata1": "Number of gard records not applied",
                         "userdata2": "0",
                      },
            0xE0204: {    "devdesc": "The Device type not supported (addrSize)",
                          "moduleid": "EEPROM_PREPAREADDRESS",
                        "reasoncode": "EEPROM_INVALID_DEVICE_TYPE",
                         "userdata1": "Address Size (aka Device Type)",
                         "userdata2": "EEPROM chip",
                      },
            0x100104: {    "devdesc": "No master proc set for this drawer",
                          "moduleid": "TOD_FIND_MASTER_PROC",
                        "reasoncode": "TOD_NO_MASTER_PROC",
                         "userdata1": "TOD drawer id",
                         "userdata2": "",
                      },
            0x101204: {    "devdesc": "Either processor or drawer object was not found for the  MDMT found by reading the processor registers.",
                          "moduleid": "TOD_FIND_MASTER_PROC",
                        "reasoncode": "TOD_MASTER_TARGET_NOT_FOUND",
                         "userdata1": "1 = Master proc was not found , zero otherwise",
                         "userdata2": "1 = Master drawer was not found, zero otherwise",
                      },
            0x110904: {    "devdesc": "Retry failed. Bad status indicated in PIB status reg.",
                          "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                        "reasoncode": "MBOX::RC_ILLEGAL_OP",
                         "userdata1": "Status from MB device driver",
                         "userdata2": "",
                      },
            0x110A04: {    "devdesc": "Mailbox Data Write attempted before ACK.",
                          "moduleid": "MOD_MBOXSRV_HNDLR",
                        "reasoncode": "RC_DATA_WRITE_ERR",
                         "userdata1": "Status from MB device driver",
                         "userdata2": "",
                      },
            0x110B04: {    "devdesc": "Mailbox Hardware detected parity error.",
                          "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                        "reasoncode": "MBOX::RC_PARITY_ERR",
                         "userdata1": "Status from MB device driver",
                         "userdata2": "",
                      },
            0x110C04: {    "devdesc": "Invalid message type sent to mailbox msgQ",
                          "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                        "reasoncode": "MBOX::RC_INVALID_MBOX_MSG_TYPE",
                         "userdata1": "Message type",
                         "userdata2": "",
                      },
            0x111304: {    "devdesc": "IPC Message data corrupted",
                          "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                        "reasoncode": "MBOX::RC_IPC_INVALID_DATA",
                         "userdata1": "IPC Data Area MSG Queue ID",
                         "userdata2": "",
                      },
            0x160404: {    "devdesc": "The LID transfer code on the FSP side was unable to fulfill the LID GET_INFO request.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLIDSIZE",
                        "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                         "userdata1": "return code from FSP",
                         "userdata2": "LID ID",
                      },
            0x170504: {    "devdesc": "The proc_stop_save_cpureg procedure failed.",
                          "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                        "reasoncode": "ISTEP::RC_BAD_RC",
                         "userdata1": "Hi 32 bits: return code from proc_stop_save_cpureg Lo 32 bits: SPR number being processed",
                         "userdata2": "Hi 32 bits: ID of core Lo 32 bits: Thread id",
                      },
            0x170704: {    "devdesc": "mm_block_unmap() returns error",
                          "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                        "reasoncode": "ISTEP::RC_MM_UNMAP_ERR",
                         "userdata1": "Return Code",
                         "userdata2": "Unmap address",
                      },
            0x175004: {    "devdesc": "Could not unmap unsecure HOMER's virtual address",
                          "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                        "reasoncode": "ISTEP::RC_MM_UNMAP_FAILED",
                         "userdata1": "Unsecure HOMER addr",
                         "userdata2": "RC from mm_block_unmap",
                      },
            0x180404: {    "devdesc": "PRD task crashed",
                          "moduleid": "ATTN_INTR_TASK_MODULE",
                        "reasoncode": "ATTN_INTR_TASK_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "Task Id that crashed",
                      },
            0x1A0304: {    "devdesc": "Tuple is unallocated",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_CHECK_TUPLE",
                        "reasoncode": "RUNTIME::RC_BAD_HDAT_TUPLE",
                         "userdata1": "Absolute address",
                         "userdata2": "Allocated Count",
                      },
            0x220B04: {    "devdesc": "Image Version not found in PNOR SBE image.",
                          "moduleid": "SBE_READ_PNOR_VERSION",
                        "reasoncode": "SBE_VERSION_NOT_FOUND",
                         "userdata1": "Not Used",
                         "userdata2": "Not Used",
                      },
            0x240404: {    "devdesc": "LpcDD::checkLpcErrors> Error(s) found in OPB Status Register",
                          "moduleid": "LPC::MOD_LPCDD_CHECKFORLPCERRORS",
                        "reasoncode": "LPC::RC_OPB_ERROR",
                         "userdata1": "OPBM Error Status Register",
                         "userdata2": "Reset Level",
                      },
            0x240A04: {    "devdesc": "LpcDD::checkForLpcErrors> Error(s) found in LPCHC Status Register",
                          "moduleid": "LPC::MOD_LPCDD_CHECKFORLPCERRORS",
                        "reasoncode": "LPC::RC_LPCHC_ERROR",
                         "userdata1": "LPCHC Error Status Register",
                         "userdata2": "Reset Level",
                      },
            0x250104: {    "devdesc": "Request to get DCMI Capabilities information failed",
                          "moduleid": "IPMI::MOD_IPMIDCMI",
                        "reasoncode": "IPMI::RC_INVALID_QRESPONSE",
                         "userdata1": "Response data length.",
                         "userdata2": "",
                      },
            0x250a04: {    "devdesc": "Request to get power limit information failed",
                          "moduleid": "IPMI::MOD_IPMIDCMI",
                        "reasoncode": "IPMI::RC_DCMI_CMD_FAILED",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "",
                      },
            0x251104: {    "devdesc": "Request to get DCMI Capabilities information failed",
                          "moduleid": "IPMI::MOD_IPMIDCMI",
                        "reasoncode": "IPMI::RC_GET_DCMI_CAP_CMD_FAILED",
                         "userdata1": "BMC IPMI Completion code.",
                         "userdata2": "",
                      },
            0x260104: {    "devdesc": "Unable to set state of master OCC",
                          "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                        "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x262304: {    "devdesc": "Invalid OCC state requested",
                          "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                        "reasoncode": "HTMGT_RC_INVALID_DATA",
                         "userdata1": "requested state",
                         "userdata2": "",
                      },
            0x262604: {    "devdesc": "OCC did not change to requested state",
                          "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                        "reasoncode": "HTMGT_RC_OCC_UNEXPECTED_STATE",
                         "userdata1": "requested state",
                         "userdata2": "OCC state",
                      },
            0x281904: {    "devdesc": "Attempted FIFO chip op on Master Proc",
                          "moduleid": "SBEIO_FIFO_CONTINUE_MPIPL",
                        "reasoncode": "SBEIO_FIFO_SENTINEL_TARGET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x2BA604: {    "devdesc": "Unsupported command code during marshal",
                          "moduleid": "MOD_TPM_MARSHALCMDDATA",
                        "reasoncode": "RC_TPM_MARSHAL_INVALID_CMD",
                         "userdata1": "Command Code",
                         "userdata2": "0",
                      },
            0x2BA704: {    "devdesc": "Marshaling error detected",
                          "moduleid": "MOD_TPM_MARSHALCMDDATA",
                        "reasoncode": "RC_TPM_MARSHALING_FAIL",
                         "userdata1": "stage",
                         "userdata2": "0",
                      },
            0x340C04: {    "devdesc": "Invalid flash address for HBB",
                          "moduleid": "Bootloader::MOD_PNORACC_GETHBBSECT",
                        "reasoncode": "Bootloader::RC_NO_HBB_IN_TOC",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x350204: {    "devdesc": "The Device type not supported (addrSize)",
                          "moduleid": "NVDIMM_PREPAREADDRESS",
                        "reasoncode": "NVDIMM_INVALID_DEVICE_TYPE",
                         "userdata1": "Address Size (aka Device Type)",
                         "userdata2": "",
                      },
            0x370A04: {    "devdesc": "Unable to find parent processor for target.",
                          "moduleid": "MMIO::MOD_MMIO_SET_PROC_SCOM",
                        "reasoncode": "MMIO::RC_PROC_NOT_FOUND",
                         "userdata1": "Target huid",
                         "userdata2": "SCOM address",
                      },
            0x410A04: {    "devdesc": "The store default all operation, which commits configuration changes to the UCD flash, completed but with errors",
                          "moduleid": "UCD_RC::MOD_VERIFY_UPDATE",
                        "reasoncode": "UCD_RC::UCD_ERROR_STORING_TO_FLASH",
                         "userdata1": "MFR_STATUS value",
                         "userdata2": "HUID of the UCD",
                      },
            0x410B04: {    "devdesc": "The store default all operation, which commits configuration changes to the UCD flash, did not complete",
                          "moduleid": "UCD_RC::MOD_VERIFY_UPDATE",
                        "reasoncode": "UCD_RC::UCD_TIMEDOUT_STORING_TO_FLASH",
                         "userdata1": "MFR_STATUS value",
                         "userdata2": "HUID of the UCD",
                      },
            0x450304: {    "devdesc": "The SPI engine mutex requested couldn't be retrieved.",
                          "moduleid": "SPI::SPI_ENGINE_LOCK_OP",
                        "reasoncode": "SPI::SPI_FAILED_TO_RETRIEVE_ENGINE_MUTEX",
                         "userdata1": "Target HUID of the SPI Master",
                         "userdata2": "Requested SPI Engine",
                      },
            0x470504: {    "devdesc": "PLDM message from BMC is too small to process",
                          "moduleid": "MOD_ROUTE_MESSAGES",
                        "reasoncode": "RC_INVALID_LENGTH",
                         "userdata1": "actual length",
                         "userdata2": "minimum length",
                      },
            0x470804: {    "devdesc": "Error sending message to PLDM message q",
                          "moduleid": "MOD_ROUTE_MESSAGES",
                        "reasoncode": "RC_SEND_FAIL",
                         "userdata1": "rc from msg_send",
                         "userdata2": "ptr to message as uint64_t",
                      },
            0x900104: {    "devdesc": "Input Target Pointer is NULL",
                          "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                        "reasoncode": "HDAT::RC_INVALID_OBJECT",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x900404: {    "devdesc": "Target is not currently supported",
                          "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                        "reasoncode": "HDAT::RC_TARGET_UNSUPPORTED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x900604: {    "devdesc": "Target list is empty",
                          "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                        "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x50f05: {    "devdesc": "This error log was intentionally created in order to induce a reconfigure loop for testing purposes.",
                          "moduleid": "RECONFIG_LOOP_TEST_ID",
                        "reasoncode": "RECONFIG_LOOP_TEST_RC",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x60405: {    "devdesc": "PnorRP::initDaemon> Error from mm_alloc_block",
                          "moduleid": "PNOR::MOD_PNORRP_INITDAEMON",
                        "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_alloc_block",
                      },
            0x70505: {    "devdesc": "Timed out waiting for command complete.",
                          "moduleid": "I2C_WAIT_FOR_CMD_COMP",
                        "reasoncode": "I2C_CMD_COMP_TIMEOUT",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x80705: {    "devdesc": "VFS Task crashed.",
                          "moduleid": "VFS_MODULE_EXEC_MONITOR",
                        "reasoncode": "VFS_TASK_CRASHED",
                         "userdata1": "tidRc",
                         "userdata2": "task Rc",
                      },
            0xA0105: {    "devdesc": "FsiDD::ddOp> Invalid data length (!= 4,2,1 bytes)",
                          "moduleid": "FSI::MOD_FSIDD_DDOP",
                        "reasoncode": "FSI::RC_INVALID_LENGTH",
                         "userdata1": "FSI Address",
                         "userdata2": "Data Length",
                      },
            0xA0805: {    "devdesc": "FsiDD::ddOp> Invalid operation type",
                          "moduleid": "FSI::MOD_FSIDD_DDOP",
                        "reasoncode": "FSI::RC_INVALID_OPERATION",
                         "userdata1": "FSI Address",
                         "userdata2": "Operation Type (i_opType)",
                      },
            0xA0905: {    "devdesc": "FsiDD::ddOp> Target is NULL",
                          "moduleid": "FSI::MOD_FSIDD_DDOP",
                        "reasoncode": "FSI::RC_NULL_TARGET",
                         "userdata1": "FSI Address",
                         "userdata2": "Operation Type (i_opType) : 0=READ, 1=WRITE",
                      },
            0xA0A05: {    "devdesc": "FsiDD::ddOp> Target is unsupported Master Sentinel",
                          "moduleid": "FSI::MOD_FSIDD_DDOP",
                        "reasoncode": "FSI::RC_MASTER_TARGET",
                         "userdata1": "FSI Address",
                         "userdata2": "Operation Type (i_opType) : 0=READ, 1=WRITE",
                      },
            0xB0d05: {    "devdesc": "AttrOverrideSection too big to fit in remaining chunk of pnor section",
                          "moduleid": "TARG_GET_ATTR_OVER",
                        "reasoncode": "TARG_RC_ATTR_OVER_PNOR_SEC_SPACE_FAIL",
                         "userdata1": "PNOR Section specified",
                         "userdata2": "Size of AttrOverrideSection",
                      },
            0xB0e05: {    "devdesc": "Serialized attribute override chunk too big to fit in remaining chunck of pnor section",
                          "moduleid": "TARG_GET_ATTR_OVER",
                        "reasoncode": "TARG_RC_ATTR_OVER_ATTR_DATA_SIZE_FAIL",
                         "userdata1": "PNOR Section specified",
                         "userdata2": "Size of Serialized attribute override",
                      },
            0xB1105: {    "devdesc": "Attribute override is in the wrong pnor section needs to be moved to the section associated with its attribute tank layer",
                          "moduleid": "TARG_GET_ATTR_OVER",
                        "reasoncode": "TARG_RC_WRITE_ATTR_OVER_WRONG_PNOR_SEC",
                         "userdata1": "Tank Layer of attribute",
                         "userdata2": "PNOR Section specified",
                      },
            0xB1205: {    "devdesc": "No tank layer was specified for attribute override.",
                          "moduleid": "TARG_GET_ATTR_OVER",
                        "reasoncode": "TARG_RC_WRITE_ATTR_OVER_NO_TANK_LAYER",
                         "userdata1": "PNOR Section specified",
                         "userdata2": "Chunk location with no tank layer",
                      },
            0xB1905: {    "devdesc": "Attribute override is in the FAPI Tank which is not supported",
                          "moduleid": "TARG_GET_ATTR_OVER",
                        "reasoncode": "TARG_RC_ATTR_OVER_FAPI_TANK_NOT_SUPPORTED",
                         "userdata1": "Tank Layer of attribute",
                         "userdata2": "PNOR Section specified",
                      },
            0xC0F05: {    "devdesc": "Found a slave processor whose EC level did not match the master",
                          "moduleid": "MOD_VALIDATE_EC_LEVELS",
                        "reasoncode": "RC_EC_MISMATCH",
                         "userdata1": "HUID of slave chip",
                         "userdata2": "EC level of slave chip",
                      },
            0xC1005: {    "devdesc": "Found one or more slave processor whose EC level did not match the master",
                          "moduleid": "MOD_VALIDATE_EC_LEVELS",
                        "reasoncode": "RC_FAILED_EC_VALIDATION",
                         "userdata1": "Number of Procs",
                         "userdata2": "",
                      },
            0xE0305: {    "devdesc": "EEPROM attribute was not found",
                          "moduleid": "EEPROM_READATTRIBUTES",
                        "reasoncode": "EEPROM_ATTR_INFO_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "EEPROM chip",
                      },
            0xE0405: {    "devdesc": "Invalid EEPROM chip to access",
                          "moduleid": "EEPROM_READATTRIBUTES",
                        "reasoncode": "EEPROM_INVALID_CHIP",
                         "userdata1": "EEPROM Chip",
                         "userdata2": "HUID of target",
                      },
            0xE0705: {    "devdesc": "Invalid address offset size",
                          "moduleid": "EEPROM_READATTRIBUTES",
                        "reasoncode": "EEPROM_INVALID_ADDR_OFFSET_SIZE",
                         "userdata1": "HUID of target",
                         "userdata2": "Address Offset Size",
                      },
            0xF0105: {    "devdesc": "Interrupt type already registered",
                          "moduleid": "INTR::MOD_INTRRP_REGISTERINTERRUPT",
                        "reasoncode": "INTR::RC_ALREADY_REGISTERED",
                         "userdata1": "XISR",
                         "userdata2": "0",
                      },
            0x110205: {    "devdesc": "Message from FSP. Message type is not within a valid range. Message dropped.",
                          "moduleid": "MBOX::MOD_MBOXSRV_RCV",
                        "reasoncode": "MBOX::RC_INVALID_MESSAGE_TYPE",
                         "userdata1": "msg queue",
                         "userdata2": "msg type",
                      },
            0x111205: {    "devdesc": "Invalid msg or msg queue",
                          "moduleid": "MBOX::MOD_MBOXSRV_RCV",
                        "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                         "userdata1": "rc from msg_send()",
                         "userdata2": "msg queue id",
                      },
            0x160605: {    "devdesc": "Insufficient space provided for LID by calling function.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLIDPNOR",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                         "userdata1": "LID size found in Ext Img",
                         "userdata2": "Reserved space provided",
                      },
            0x160805: {    "devdesc": "Insufficient space provided for LID by calling function.",
                          "moduleid": "Util::UTIL_LIDMGR_GETLIDPNOR",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE_PNOR",
                         "userdata1": "LID size found in pnor",
                         "userdata2": "Reserved space provided",
                      },
            0x1E0705: {    "devdesc": "ROM verification failed",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY",
                        "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x1E0B05: {    "devdesc": "Valid securerom not present",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY",
                        "reasoncode": "SECUREBOOT::RC_SECROM_INVALID",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x240505: {    "devdesc": "LpcDD::hwReset> Unsupported Reset Level requested",
                          "moduleid": "LPC::MOD_LPCDD_HWRESET",
                        "reasoncode": "LPC::RC_UNSUPPORTED_OPERATION",
                         "userdata1": "Unsupported Reset Level Parameter",
                         "userdata2": "<unused>",
                      },
            0x250205: {    "devdesc": "ipmi_msg() failed",
                          "moduleid": "IPMI::MOD_IPMIRT",
                        "reasoncode": "IPMI::RC_INVALID_SENDRECV",
                         "userdata1": "rc from ipmi_msg()",
                         "userdata2": "netfn of failing msg",
                      },
            0x260105: {    "devdesc": "Set state only allowed on master OCC",
                          "moduleid": "HTMGT_MOD_OCC_SET_STATE",
                        "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                         "userdata1": "OCC instance",
                         "userdata2": "Requested state",
                      },
            0x261B05: {    "devdesc": "Set of OCC state failed",
                          "moduleid": "HTMGT_MOD_OCC_SET_STATE",
                        "reasoncode": "HTMGT_RC_OCC_CMD_FAIL",
                         "userdata1": "OCC instance",
                         "userdata2": "Requested state",
                      },
            0x270305: {    "devdesc": "SPI_TPM_INFO attribute was not found for the requested target",
                          "moduleid": "TPMDD_READATTRIBUTES",
                        "reasoncode": "TPM_ATTR_INFO_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "Type of target",
                      },
            0x271005: {    "devdesc": "TPM_MODEL attribute was not found for the requested target",
                          "moduleid": "TPMDD_READATTRIBUTES",
                        "reasoncode": "TPM_ATTR_MODEL_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "Type of target",
                      },
            0x271105: {    "devdesc": "TPM_MODEL attribute was set to a value that is not currently supported",
                          "moduleid": "TPMDD_READATTRIBUTES",
                        "reasoncode": "TPM_ATTR_INVALID_MODEL",
                         "userdata1": "TPM Model of target",
                         "userdata2": "HUID of target",
                      },
            0x271305: {    "devdesc": "TPM_ENABLED attribute was not found for the requested target",
                          "moduleid": "TPMDD_READATTRIBUTES",
                        "reasoncode": "TPM_ATTR_TPM_ENABLED_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "Type of target",
                      },
            0x283105: {    "devdesc": "SBEIO RT Process Pass-through command function not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_FUNCTION_NOT_SET",
                         "userdata1": "Processor HUID",
                         "userdata2": "Request Command",
                      },
            0x283205: {    "devdesc": "SBEIO RT Process Pass-through command response data size too large.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_RSP_DATA_TOO_LARGE",
                         "userdata1": "Processor HUID",
                         "userdata2": "Request Command",
                      },
            0x283305: {    "devdesc": "SBEIO RT Read Pass-through command invalid version.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_INVALID_VERSION",
                         "userdata1": "SBE Header version",
                         "userdata2": "Command Header version",
                      },
            0x283405: {    "devdesc": "SBEIO RT Read Pass-through command message size is too large.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_MSG_SIZE_TOO_LARGE",
                         "userdata1": "Processor HUID",
                         "userdata2": "Message Size",
                      },
            0x283505: {    "devdesc": "SBEIO RT Read Pass-through command data offset is too small.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_DATA_OFFSET_TOO_SMALL",
                         "userdata1": "Processor HUID",
                         "userdata2": "Data Offset",
                      },
            0x283605: {    "devdesc": "SBEIO RT Read Pass-through command data offset is too large.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_DATA_TOO_LARGE",
                         "userdata1": "Processor HUID",
                         "userdata2": "Data Offset",
                      },
            0x283705: {    "devdesc": "SBEIO RT Check Pass-through command response field was altered.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_RSP_FIELD_ALTERED",
                         "userdata1": "Processor HUID",
                         "userdata2": "Request Command",
                      },
            0x283805: {    "devdesc": "SBEIO RT Process Pass-through command SBE Communication buffer not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_NO_SBE_COMM_BUFFER",
                         "userdata1": "Processor HUID",
                         "userdata2": "Reserved",
                      },
            0x283905: {    "devdesc": "SBEIO RT Process Pass-through command function not found.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_FUNCTION_NOT_FOUND",
                         "userdata1": "Processor HUID",
                         "userdata2": "Request Command",
                      },
            0x283A05: {    "devdesc": "SBEIO RT Process Pass-through command Runtime Interface pointer not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_NO_INTERFACE_POINTER",
                         "userdata1": "Processor HUID",
                         "userdata2": "Reserved",
                      },
            0x283B05: {    "devdesc": "SBEIO RT Process Pass-through command Runtime Interface function pointer not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME",
                        "reasoncode": "SBEIO::SBEIO_RT_NO_INTERFACE_FUNCTION",
                         "userdata1": "Processor HUID",
                         "userdata2": "Reserved",
                      },
            0x2BA805: {    "devdesc": "Unsupported command code during unmarshal",
                          "moduleid": "MOD_TPM_UNMARSHALRESPDATA",
                        "reasoncode": "RC_TPM_UNMARSHAL_INVALID_CMD",
                         "userdata1": "commandcode",
                         "userdata2": "stage",
                      },
            0x2BA905: {    "devdesc": "Unmarshaling error detected",
                          "moduleid": "MOD_TPM_UNMARSHALRESPDATA",
                        "reasoncode": "RC_TPM_UNMARSHALING_FAIL",
                         "userdata1": "Stage",
                         "userdata2": "Remaining response buffer size",
                      },
            0x332305: {    "devdesc": "Could not find the parent PERV of this unit target or the pervasive did not map to expected PROC",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_PARENT_TEST",
                        "reasoncode": "fapi2::RC_UNIT_NO_PERV_FOUND",
                         "userdata1": "Actual PROC HUID",
                         "userdata2": "Actual PERV HUID",
                      },
            0x350305: {    "devdesc": "NVDIMM attribute was not found",
                          "moduleid": "NVDIMM_READATTRIBUTES",
                        "reasoncode": "NVDIMM_ATTR_INFO_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "",
                      },
            0x350705: {    "devdesc": "Invalid address offset size",
                          "moduleid": "NVDIMM_READATTRIBUTES",
                        "reasoncode": "NVDIMM_INVALID_ADDR_OFFSET_SIZE",
                         "userdata1": "HUID of target",
                         "userdata2": "Address Offset Size",
                      },
            0x370105: {    "devdesc": "A MMIO operation was attempted before MMIO was initialized.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INVALID_SETUP",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370205: {    "devdesc": "Invalid data buffer for a MMIO operation.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INVALID_BUFFER",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370305: {    "devdesc": "Data buffer too small for a MMIO operation.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INSUFFICIENT_BUFFER",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370405: {    "devdesc": "Buffer length not a multiple of access limit.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INCORRECT_BUFFER_LENGTH",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370505: {    "devdesc": "Invalid offset, requested address was out of range for a MMIO operation.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INVALID_OFFSET",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370605: {    "devdesc": "Requested MMIO address was not aligned properly for the associated device.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INVALID_OFFSET_ALIGNMENT",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370705: {    "devdesc": "Specified access limit was invalid for a MMIO operation.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_INVALID_ACCESS_LIMIT",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                      },
            0x370D05: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                          "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                        "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                         "userdata1": "OCMB HUID",
                         "userdata2": "OCMB chip ID",
                      },
            0x410C05: {    "devdesc": "A combination of arguments passed to ucdDeviceOp were not able to form a valid deviceOp() call.",
                          "moduleid": "UCD_RC::MOD_PERFORM_DEVICE_OP",
                        "reasoncode": "UCD_RC::UCD_INVALID_DEVICE_OP",
                         "userdata1": "command or 0x0 if none provided",
                         "userdata2": "smbus operation type",
                      },
            0x450405: {    "devdesc": "The requested op type is not supported.",
                          "moduleid": "SPI::SPI_PERFORM_OP",
                        "reasoncode": "SPI::SPI_UNKNOWN_OP_TYPE",
                         "userdata1": "Target HUID of the SPI Master",
                         "userdata2": "op type",
                      },
            0x450505: {    "devdesc": "The length of the buffer to write/read must be greater than zero.",
                          "moduleid": "SPI::SPI_PERFORM_OP",
                        "reasoncode": "SPI::SPI_INVALID_BUFFER_SIZE",
                         "userdata1": "Target HUID of the SPI Master",
                         "userdata2": "",
                      },
            0x30F06: {    "devdesc": "Bits 0:11 in user supplied data is not zero",
                          "moduleid": "SCOM::SCOM_DO_FORM_1_INDIRECT_SCOM",
                        "reasoncode": "SCOM::SCOM_FORM_1_INVALID_DATA",
                         "userdata1": "Address",
                         "userdata2": "User supplied data",
                      },
            0x31006: {    "devdesc": "No read op on form 1 indirect scom.",
                          "moduleid": "SCOM::SCOM_DO_FORM_1_INDIRECT_SCOM",
                        "reasoncode": "SCOM::SCOM_FORM_1_READ_REQUEST",
                         "userdata1": "Address",
                         "userdata2": "Operation Type",
                      },
            0x62306: {    "devdesc": "Could not set permissions of the given PNOR section to WRITABLE/WRITE_TRACKED",
                          "moduleid": "PNOR::MOD_PNORRP_READTOC",
                        "reasoncode": "PNOR::RC_WRITE_TRACKED_PERM_FAIL",
                         "userdata1": "PNOR section id",
                         "userdata2": "PNOR section vaddr",
                      },
            0x62B06: {    "devdesc": "Expected buffer to have contents of TOC, instead was NULL",
                          "moduleid": "PNOR::MOD_PNORRP_READTOC",
                        "reasoncode": "PNOR::RC_NULL_TOC_BUFFER",
                         "userdata1": "Address of toc buffer",
                         "userdata2": "Error code",
                      },
            0x63D06: {    "devdesc": "Could not set permissions of the given PNOR section to READ_ONLY",
                          "moduleid": "PNOR::MOD_PNORRP_READTOC",
                        "reasoncode": "PNOR::RC_READ_ONLY_PERM_FAIL",
                         "userdata1": "PNOR section id",
                         "userdata2": "PNOR section vaddr",
                      },
            0x80806: {    "devdesc": "Secureboot page verify failure.",
                          "moduleid": "VFS_VERIFY_PAGE",
                        "reasoncode": "VFS_PAGE_VERIFY_FAILED",
                         "userdata1": "Kernel RC",
                         "userdata2": "virtual address accessed",
                      },
            0xA0306: {    "devdesc": "FsiDD::pollForComplete> Error during FSI access",
                          "moduleid": "FSI::MOD_FSIDD_POLLFORCOMPLETE",
                        "reasoncode": "FSI::RC_OPB_TIMEOUT",
                         "userdata1": "Relative FSI Address",
                         "userdata2": "Absolute FSI Address",
                      },
            0xA0606: {    "devdesc": "FsiDD::pollForComplete> Read valid never came on",
                          "moduleid": "FSI::MOD_FSIDD_POLLFORCOMPLETE",
                        "reasoncode": "FSI::RC_OPB_NO_READ_VALID",
                         "userdata1": "Relative FSI Address",
                         "userdata2": "Absolute FSI Address",
                      },
            0xB0f06: {    "devdesc": "Failure applying given attribute override on given target",
                          "moduleid": "TARG_WRITE_PERM_ATTR",
                        "reasoncode": "TARG_RC_WRITE_PERM_ATTR_FAIL",
                         "userdata1": "Target specified",
                         "userdata2": "Attribute specified",
                      },
            0xB1006: {    "devdesc": "Given target does not have given attribute to apply override",
                          "moduleid": "TARG_WRITE_PERM_ATTR",
                        "reasoncode": "TARG_RC_WRITE_PERM_ATTR_TARGET_FAIL",
                         "userdata1": "Target specified",
                         "userdata2": "Attribute specified",
                      },
            0xC0306: {    "devdesc": "Target is neiter TYPE_EQ, TYPE_FC nor TYPE_CORE",
                          "moduleid": "MOD_RUNTIME_DECONFIG",
                        "reasoncode": "RC_INVALID_TARGET",
                         "userdata1": "target huid",
                         "userdata2": "",
                      },
            0xC1106: {    "devdesc": "Caller passed invalid deconfigure action",
                          "moduleid": "MOD_RUNTIME_DECONFIG",
                        "reasoncode": "RC_INVALID_PARAM",
                         "userdata1": "HUID of the target",
                         "userdata2": "Target type",
                      },
            0xC1206: {    "devdesc": "deconfigureTargetAtRuntime is currently only supported in hostboot runtime, this error indicates the function was called outside of the hostboot runtime context.",
                          "moduleid": "MOD_RUNTIME_DECONFIG",
                        "reasoncode": "RC_NOT_AT_RUNTIME",
                         "userdata1": "HUID of the target",
                         "userdata2": "deconfig reason - either error log id, or DeconfigGard::DECONFIGURED_BY_PRD",
                      },
            0xC1306: {    "devdesc": "Target is NULL",
                          "moduleid": "MOD_RUNTIME_DECONFIG",
                        "reasoncode": "RC_NULL_TARGET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0xE0506: {    "devdesc": "I2C master entity path doesn't exist.",
                          "moduleid": "EEPROM_GET_MASTERTARGET",
                        "reasoncode": "EEPROM_MASTER_PATH_ERROR",
                         "userdata1": "Attribute Chip Type Enum",
                         "userdata2": "HUID of target",
                      },
            0xE0606: {    "devdesc": "Master path target is null.",
                          "moduleid": "EEPROM_GET_MASTERTARGET",
                        "reasoncode": "EEPROM_TARGET_NULL",
                         "userdata1": "Eeprom role",
                         "userdata2": "HUID of target",
                      },
            0xF0306: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_ENABLE_PSI_INTR",
                        "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                         "userdata1": "MSG_INTR_ENABLE_PSI_INTR",
                         "userdata2": "0",
                      },
            0x101306: {    "devdesc": "MDMT could not be found",
                          "moduleid": "TOD_SAVEREGS_HWP",
                        "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                         "userdata1": "Topology type (primary/secondary)",
                         "userdata2": "",
                      },
            0x110706: {    "devdesc": "Message queue already registered with mailbox using a different queue.",
                          "moduleid": "MBOX::MOD_MBOXREGISTER",
                        "reasoncode": "MBOX::RC_ALREADY_REGISTERED",
                         "userdata1": "queue_id_t queueId",
                         "userdata2": "0",
                      },
            0x110D06: {    "devdesc": "Mailbox service is not available now.",
                          "moduleid": "MBOX::MOD_MBOXREGISTER",
                        "reasoncode": "MBOX::RC_MBOX_SERVICE_NOT_READY",
                         "userdata1": "queue_id_t queueId",
                         "userdata2": "0",
                      },
            0x160406: {    "devdesc": "Unable to load LID via host interface.",
                          "moduleid": "Util::UTIL_LIDMGR_RT",
                        "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                         "userdata1": "Return code from lid_load call.",
                         "userdata2": "Lid number",
                      },
            0x160906: {    "devdesc": "Unable to unload LID via host interface.",
                          "moduleid": "Util::UTIL_LIDMGR_RT",
                        "reasoncode": "Util::UTIL_LIDMGR_UNLOAD_RC_FAIL",
                         "userdata1": "Return code from lid_unload call.",
                         "userdata2": "",
                      },
            0x160A06: {    "devdesc": "Unable to find Lid.",
                          "moduleid": "Util::UTIL_LIDMGR_RT",
                        "reasoncode": "Util::UTIL_LIDMGR_NOT_FOUND",
                         "userdata1": "Lid number",
                         "userdata2": "Lid is in reserved memory",
                      },
            0x170606: {    "devdesc": "cpu_master_winkle returned an error",
                          "moduleid": "MOD_HOST_ACTIVATE_BOOT_CORE",
                        "reasoncode": "RC_FAIL_BOOT_CORE_WINKLE",
                         "userdata1": "return code from cpu_master_winkle",
                         "userdata2": "Fused core indicator",
                      },
            0x171F06: {    "devdesc": "activate_boot_core> Could not find a target for the boot-fused core",
                          "moduleid": "ISTEP::MOD_HOST_ACTIVATE_BOOT_CORE",
                        "reasoncode": "ISTEP::RC_NO_FUSED_CORE_TARGET",
                         "userdata1": "Master-fused core id",
                         "userdata2": "Master-fused processor chip huid",
                      },
            0x1A0406: {    "devdesc": "Section is not valid in standalone mode",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GET_STANDALONE_SECTION",
                        "reasoncode": "RUNTIME::RC_INVALID_STANDALONE",
                         "userdata1": "Section ID",
                         "userdata2": "Section Instance Number",
                      },
            0x1E0906: {    "devdesc": "Invalid target used to read security switch register.",
                          "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                        "reasoncode": "SECUREBOOT::RC_SECURE_BAD_TARGET",
                         "userdata1": "Target pointer value",
                         "userdata2": "Target's HUID or 0 if null target pointer.",
                      },
            0x1E1006: {    "devdesc": "Processor security register read too early",
                          "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                        "reasoncode": "SECUREBOOT::RC_PROC_NOT_SCOMABLE",
                         "userdata1": "Use XSCOM bool",
                         "userdata2": "Target's HUID",
                      },
            0x1E1106: {    "devdesc": "Processor security register read too early",
                          "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                        "reasoncode": "SECUREBOOT::RC_DEVICE_READ_ERR",
                         "userdata1": "Actual size read",
                         "userdata2": "Expected size read",
                      },
            0x220106: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_alloc_block",
                          "moduleid": "SBE_CREATE_TEST_SPACE",
                        "reasoncode": "SBE_ALLOC_BLOCK_FAIL",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_alloc_block",
                      },
            0x220206: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_set_permission on creation",
                          "moduleid": "SBE_CREATE_TEST_SPACE",
                        "reasoncode": "SBE_SET_PERMISSION_FAIL",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_set_permission",
                      },
            0x240606: {    "devdesc": "create_altmaster_objects> Alt-master object already exists",
                          "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                        "reasoncode": "LPC::RC_ALTMASTER_EXISTS",
                         "userdata1": "Requested proc",
                         "userdata2": "<unused>",
                      },
            0x240706: {    "devdesc": "create_altmaster_objects> Cannot create another object using master proc",
                          "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                        "reasoncode": "LPC::RC_CANT_USE_MASTER",
                         "userdata1": "<unused>",
                         "userdata2": "<unused>",
                      },
            0x240806: {    "devdesc": "create_altmaster_objects> Cannot create another object using master sentinel",
                          "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                        "reasoncode": "LPC::RC_CANT_USE_SENTINEL",
                         "userdata1": "<unused>",
                         "userdata2": "<unused>",
                      },
            0x250306: {    "devdesc": "msg_send() failed",
                          "moduleid": "IPMI::MOD_IPMISRV_POSTEVENT",
                        "reasoncode": "IPMI::RC_INVALID_SEND",
                         "userdata1": "rc from msq_send()",
                         "userdata2": "",
                      },
            0x264506: {    "devdesc": "No OCC target found for proc Target,",
                          "moduleid": "HTMGT_MOD_PROCESS_OCC_RESET",
                        "reasoncode": "HTMGT_RC_INVALID_PARAMETER",
                         "userdata1": "Processor HUID",
                         "userdata2": "",
                      },
            0x285006: {    "devdesc": "Unsecure Memory Region Does Not Exist",
                          "moduleid": "SBEIO_MEM_REGION",
                        "reasoncode": "SBEIO_MEM_REGION_DOES_NOT_EXIST",
                         "userdata1": "Starting Address of Unsecure Memory Region",
                         "userdata2": "Number of Unsecure Memory Regions",
                      },
            0x285106: {    "devdesc": "Attempt To Open Too Many Unsecure Memory Regions",
                          "moduleid": "SBEIO_MEM_REGION",
                        "reasoncode": "SBEIO_EXCEEDS_MAXIMUM_MEM_REGIONS",
                         "userdata1": "Current Count of Unsecure Memory Regions",
                         "userdata2": "Maximum Number of Unsecure Memomory Regions",
                      },
            0x2BAD06: {    "devdesc": "The system (or node, if multi-node system) is configured in the hardware (via processor secure jumpers) to enable Secure Boot, and the system's/node's TPM required policy is configured to require at least one functional boot processor TPM in order to boot with Trusted Boot enabled. Therefore, the system (or node, if multi-node system) will terminate due to lack of functional boot processor TPM.",
                          "moduleid": "MOD_TPM_VERIFYFUNCTIONAL",
                        "reasoncode": "RC_TPM_NOFUNCTIONALTPM_FAIL",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x332206: {    "devdesc": "Invalid amount of child cores found on a proc",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_CHILDREN_TEST",
                        "reasoncode": "fapi2::RC_INVALID_CHILD_COUNT",
                         "userdata1": "Expected Child Count",
                         "userdata2": "Actual Child Count",
                      },
            0x350506: {    "devdesc": "I2C master entity path doesn't exist.",
                          "moduleid": "NVDIMM_GETI2CMASTERTARGET",
                        "reasoncode": "NVDIMM_I2C_MASTER_PATH_ERROR",
                         "userdata1": "HUID of target",
                         "userdata2": "Compressed Entity Path",
                      },
            0x350606: {    "devdesc": "I2C master path target is null.",
                          "moduleid": "NVDIMM_GETI2CMASTERTARGET",
                        "reasoncode": "NVDIMM_TARGET_NULL",
                         "userdata1": "HUID of target",
                         "userdata2": "Compressed Entity Path",
                      },
            0x410D06: {    "devdesc": "There was an error while parsing a field in this UCD flash image's command line",
                          "moduleid": "UCD_RC::MOD_CONVERT_STRING_TO_OP",
                        "reasoncode": "UCD_RC::UCD_FIELD_PARSE_ERROR",
                         "userdata1": "HUID of UCD Target",
                         "userdata2": "The Field Location of the parse error",
                      },
            0x900506: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_PCIA_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x31D07: {    "devdesc": "Invalid mode parm for wakeup operation.",
                          "moduleid": "SCOM_HANDLE_SPECIAL_WAKEUP",
                        "reasoncode": "SCOM_INVALID_WAKEUP_PARM",
                         "userdata1": "Wakeup Argument",
                         "userdata2": "Input Target",
                      },
            0x40107: {    "devdesc": "XSCom access error",
                          "moduleid": "XSCOM_DO_OP",
                        "reasoncode": "XSCOM_STATUS_ERR",
                         "userdata1": "HMER value (piberr in bits 21:23)",
                         "userdata2": "XSCom address",
                      },
            0x70607: {    "devdesc": "Error was found in I2C status register. Check userdata to determine what the error was.",
                          "moduleid": "I2C_CHECK_FOR_ERRORS",
                        "reasoncode": "I2C_HW_ERROR_FOUND",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x70B07: {    "devdesc": "a NACK Error was found in the I2C status register.",
                          "moduleid": "I2C_CHECK_FOR_ERRORS",
                        "reasoncode": "I2C_NACK_ONLY_FOUND",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x70C07: {    "devdesc": "Bus Arbitration Lost Error was found in the I2C status register.",
                          "moduleid": "I2C_CHECK_FOR_ERRORS",
                        "reasoncode": "I2C_ARBITRATION_LOST_ONLY_FOUND",
                         "userdata1": "Status Register Value",
                         "userdata2": "Master Target",
                      },
            0x90707: {    "devdesc": "verifyCfamAccessTarget> Attempt to access CFAM on the master processor",
                          "moduleid": "fapi2::MOD_FAPI2_VERIFYCFAMACCESSTARGET",
                        "reasoncode": "fapi2::RC_INVALID_TARG_TARGET",
                         "userdata1": "CFAM Address",
                         "userdata2": "HUID of input target",
                      },
            0xB0207: {    "devdesc": "The eyecatch value observed in PNOR does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute PNOR section are unable to be parsed.",
                          "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                        "reasoncode": "TARG_RC_BAD_EYECATCH",
                         "userdata1": "Observed Header Eyecatch Value",
                         "userdata2": "Expected Eyecatch Value",
                      },
            0xB1307: {    "devdesc": "While attempting to map a phys addr to a virtual addr for our targeting information the kernel returned an error",
                          "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                        "reasoncode": "TARG_RC_MM_BLOCK_MAP_FAIL",
                         "userdata1": "physical address of target info",
                         "userdata2": "size we tried to map",
                      },
            0xB1507: {    "devdesc": "While attempting to unmap a virtual addr for our targeting information the kernel returned an error",
                          "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                        "reasoncode": "TARG_RC_MM_BLOCK_UNMAP_FAIL",
                         "userdata1": "return code",
                         "userdata2": "Unmap virtual address",
                      },
            0xE0507: {    "devdesc": "buildEepromRecordHeader invalid master target",
                          "moduleid": "EEPROM_CACHE_EEPROM",
                        "reasoncode": "EEPROM_MASTER_PATH_ERROR",
                         "userdata1": "HUID of target we want to cache",
                         "userdata2": "Type of EEPROM we are caching",
                      },
            0xE0C07: {    "devdesc": "buildEepromRecordHeader invalid mux target",
                          "moduleid": "EEPROM_CACHE_EEPROM",
                        "reasoncode": "EEPROM_I2C_MUX_PATH_ERROR",
                         "userdata1": "HUID of target we want to cache",
                         "userdata2": "Type of EEPROM we are caching",
                      },
            0xE1407: {    "devdesc": "Attempting to overwrite eeprom cache with a buffer that is larger than the eeprom device itself",
                          "moduleid": "EEPROM_CACHE_EEPROM",
                        "reasoncode": "EEPROM_INVALID_LENGTH",
                         "userdata1": "Size of buffer",
                         "userdata2": "HUID of Master",
                      },
            0x100507: {    "devdesc": "Error: Unsupported bus type was detected Possible Causes: Invalid bus configuration in targeting, or getBusPort method has not been updated to support all the bus type on a given system. Resolution:Development team should be contacted.",
                          "moduleid": "TOD_LOG_UNSUPPORTED_BUSTYPE",
                        "reasoncode": "TOD_UNSUPPORTED_BUSTYPE",
                         "userdata1": "Bus type that is not currently supported",
                         "userdata2": "",
                      },
            0x110207: {    "devdesc": "Message from FSP to HB MBOX of an unknown type",
                          "moduleid": "MBOX::MOD_MBOXSRV_FSP_MSG",
                        "reasoncode": "MBOX::RC_INVALID_MESSAGE_TYPE",
                         "userdata1": "msg type",
                         "userdata2": "msg queue id",
                      },
            0x110507: {    "devdesc": "Message from FSP. An invalid message queue ID or mesage type was sent to the FSP.",
                          "moduleid": "MOD_MBOXSRV_FSP_MSG",
                        "reasoncode": "RC_INVALID_QUEUE",
                         "userdata1": "msg queue",
                         "userdata2": "msg type",
                      },
            0x160B07: {    "devdesc": "Error returned from mm_remove_pages when evicting lid from memory.",
                          "moduleid": "Util::UTIL_LIDMGR_CLEANUP",
                        "reasoncode": "Util::UTIL_LIDMGR_MM_FAIL",
                         "userdata1": "LID ID",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x1A0807: {    "devdesc": "There is no host data for specified kind of payload",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                        "reasoncode": "RUNTIME::RC_INVALID_PAYLOAD_KIND",
                         "userdata1": "ATTR_PAYLOAD_KIND",
                         "userdata2": "Requested Section",
                      },
            0x1A0C07: {    "devdesc": "Unknown section requested",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                        "reasoncode": "RUNTIME::RC_INVALID_SECTION",
                         "userdata1": "Section Id",
                         "userdata2": "<unused>",
                      },
            0x1A2007: {    "devdesc": "Invalid instance requested for Reserved Hostboot Memory section",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                        "reasoncode": "RUNTIME::RC_INVALID_RHB_INSTANCE",
                         "userdata1": "Requested instance (reserved mem array index)",
                         "userdata2": "maximum array index allowed",
                      },
            0x1E0707: {    "devdesc": "Container component ID verification failed.",
                          "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY_COMP_ID",
                        "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x1E0907: {    "devdesc": "Invalid target used to write security register.",
                          "moduleid": "SECUREBOOT::MOD_SECURE_WRITE_REG",
                        "reasoncode": "SECUREBOOT::RC_SECURE_BAD_TARGET",
                         "userdata1": "Target pointer value",
                         "userdata2": "Target's HUID or 0 if NULL target pointer",
                      },
            0x1E0F07: {    "devdesc": "Device write did not return expected size",
                          "moduleid": "SECUREBOOT::MOD_SECURE_WRITE_REG",
                        "reasoncode": "SECUREBOOT::RC_DEVICE_WRITE_ERR",
                         "userdata1": "Actual size written",
                         "userdata2": "Expected size written",
                      },
            0x220207: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_set_permission on cleanup",
                          "moduleid": "SBE_CLEANUP_TEST_SPACE",
                        "reasoncode": "SBE_SET_PERMISSION_FAIL",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_set_permission",
                      },
            0x220307: {    "devdesc": "updateProcessorSbeSeeproms> mm_remove_pages RELEASE failed",
                          "moduleid": "SBE_CLEANUP_TEST_SPACE",
                        "reasoncode": "SBE_REMOVE_PAGES_FAIL",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x240907: {    "devdesc": "readLPC> Unexpected target",
                          "moduleid": "LPC::MOD_READLPC",
                        "reasoncode": "LPC::RC_BAD_TARGET",
                         "userdata1": "Requested target",
                         "userdata2": "Current alt target",
                      },
            0x250e07: {    "devdesc": "VPD data is invalid size",
                          "moduleid": "IPMI::MOD_IPMIFRU_INV",
                        "reasoncode": "IPMI::RC_INVALID_VPD_DATA",
                         "userdata1": "Size of vpd data",
                         "userdata2": "",
                      },
            0x261607: {    "devdesc": "OCC reset threshold reached. Leaving OCCs in reset state",
                          "moduleid": "HTMGT_MOD_OCC_RESET",
                        "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                         "userdata1": "return code triggering safe mode",
                         "userdata2": "OCC instance",
                      },
            0x270A07: {    "devdesc": "Timeout waiting for TPM to enter command ready state.",
                          "moduleid": "TPMDD_POLLFORCOMMMANDREADY",
                        "reasoncode": "TPM_TIMEOUT",
                         "userdata1": "TPM",
                         "userdata2": "STS Reg",
                      },
            0x283A07: {    "devdesc": "SBEIO RT Process Pass-through command RuntimeRT Interface pointer not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME_ATTR_OVERRIDE",
                        "reasoncode": "SBEIO::SBEIO_RT_NO_INTERFACE_POINTER",
                         "userdata1": "Processor HUID",
                         "userdata2": "Reserved",
                      },
            0x283C07: {    "devdesc": "SBEIO RT Process Pass-through command RuntimeRT Interface pointer for apply_attr_override not set.",
                          "moduleid": "SBEIO::SBEIO_RUNTIME_ATTR_OVERRIDE",
                        "reasoncode": "SBEIO::SBEIO_RT_NO_APPLY_ATTR_FUNCTION",
                         "userdata1": "Processor HUID",
                         "userdata2": "Reserved",
                      },
            0x2BAE07: {    "devdesc": "Command failure performing PCR extend.",
                          "moduleid": "MOD_TPM_CMD_PCREXTEND",
                        "reasoncode": "RC_TPM_COMMAND_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "dataSize",
                      },
            0x2BAF07: {    "devdesc": "PCR Extend invalid arguments detected",
                          "moduleid": "MOD_TPM_CMD_PCREXTEND",
                        "reasoncode": "RC_TPM_INVALID_ARGS",
                         "userdata1": "Digest Ptr",
                         "userdata2": "Full Digest Size 1",
                      },
            0x350A07: {    "devdesc": "NVDIMM register offset out of bound",
                          "moduleid": "NVDIMM_CROSSESNVDIMMPAGEBOUNDARY",
                        "reasoncode": "NVDIMM_INVALID_OFFSET",
                         "userdata1": "Offset attempting to access",
                         "userdata2": "Requested buffer length",
                      },
            0x370D07: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                          "moduleid": "MMIO::MOD_CHECK_OCMB_ERROR",
                        "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                         "userdata1": "OCMB HUID",
                         "userdata2": "OCMB chip ID",
                      },
            0xB0508: {    "devdesc": "The attribute resource provider was unable to satisfy a message request from the VMM portion of the kernel.  This was either due to an address outside a valid range or a message request that is invalid for the attribute section containing the address.",
                          "moduleid": "TARG_MSG_SERVICE_TASK",
                        "reasoncode": "TARG_RC_ATTR_MSG_FAIL",
                         "userdata1": "Virtual Address",
                         "userdata2": "(Msg Type << 32) | Section #",
                      },
            0xC1508: {    "devdesc": "No procs found with valid memory",
                          "moduleid": "MOD_UPDATE_PROC_MEM_TO_USE",
                        "reasoncode": "RC_NO_UPDATE_WHEN_MEM_MISSING",
                         "userdata1": "Saved value of ATTR_PROC_MEM_TO_USE",
                         "userdata2": "Updated value of ATTR_PROC_MEM_TO_USE",
                      },
            0xF0708: {    "devdesc": "Error mapping in memory",
                          "moduleid": "INTR::MOD_INTR_INIT_MPIPLAREA",
                        "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                         "userdata1": "physical address",
                         "userdata2": "Size",
                      },
            0x100608: {    "devdesc": "Error: Unsupported bus port was detected for the specified bus type. Possible Causes: Invalid bus configuration in targeting, or getBusPort method has not been updated to support all the possible port for a particular type of bus on the system. Resolution:Development team should be contacted.",
                          "moduleid": "TOD_LOG_UNSUPPORTED_BUSPORT",
                        "reasoncode": "TOD_UNSUPPORTED_BUSPORT",
                         "userdata1": "Bus port that is not currently supported",
                         "userdata2": "Bus Type for which the unsupported port has been reported",
                      },
            0x110E08: {    "devdesc": "Failed to allocate a DMA buffer. Message dropped.",
                          "moduleid": "MOD_MBOXSRV_SENDMSG",
                        "reasoncode": "RC_INVALID_DMA_LENGTH",
                         "userdata1": "DMA length requested",
                         "userdata2": "queue_id",
                      },
            0x111008: {    "devdesc": "Mailbox is disabled, message dropped.",
                          "moduleid": "MOD_MBOXSRV_SENDMSG",
                        "reasoncode": "RC_MAILBOX_DISABLED",
                         "userdata1": "queue_id",
                         "userdata2": "message type",
                      },
            0x1A0B08: {    "devdesc": "HDAT data block falls outside valid range",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_VERIFY_HDAT_ADDRESS",
                        "reasoncode": "RUNTIME::RC_INVALID_ADDRESS",
                         "userdata1": "Start of address range under test",
                         "userdata2": "Size of address range under test",
                      },
            0x220E08: {    "devdesc": "Invalid Boot SEEPROM Side Found",
                          "moduleid": "SBE_GET_TARGET_INFO_STATE",
                        "reasoncode": "SBE_INVALID_SEEPROM_SIDE",
                         "userdata1": "Temporary Current Side",
                         "userdata2": "SBE State Current Side",
                      },
            0x221A08: {    "devdesc": "Unexpected HW Key Hash found in SBE Image",
                          "moduleid": "SBE_GET_TARGET_INFO_STATE",
                        "reasoncode": "SBE_MISMATCHED_HW_KEY_HASH",
                         "userdata1": "Target HUID",
                         "userdata2": "HW Key Hash found in Customized SBE Image",
                      },
            0x222108: {    "devdesc": "Unexpected Secure Version found in SBE Image",
                          "moduleid": "SBE_GET_TARGET_INFO_STATE",
                        "reasoncode": "SBE_MISMATCHED_SECURE_VERSION",
                         "userdata1": "Target HUID",
                         "userdata2": "Secure Version found in Customized SBE Image",
                      },
            0x222208: {    "devdesc": "Invalid Security Setting where lesser Secure Version found from securely loaded PNOR partitions",
                          "moduleid": "SBE_GET_TARGET_INFO_STATE",
                        "reasoncode": "SBE_SECUREBOOT_ESCAPE",
                         "userdata1": "Security Setting (isSecurityEnabled)",
                         "userdata2": "Secure Version Lock-in Policy",
                      },
            0x240908: {    "devdesc": "writeLPC> Unexpected target",
                          "moduleid": "LPC::MOD_WRITELPC",
                        "reasoncode": "LPC::RC_BAD_TARGET",
                         "userdata1": "Requested target",
                         "userdata2": "Current alt target",
                      },
            0x250d08: {    "devdesc": "The sensor could not be found based upon the sensor number.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_TYPE",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_FOUND",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x250f08: {    "devdesc": "The passed in sensor number is not valid.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_TYPE",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_NUMBER",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x261608: {    "devdesc": "Homer pointer is nullptr, unable to communicate with the OCCs. Leaving system in safe mode.",
                          "moduleid": "HTMGT_MOD_BUILD_OCCS",
                        "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                         "userdata1": "OCC Instance",
                         "userdata2": "homer virtual address",
                      },
            0x262408: {    "devdesc": "No functional OCCs were found",
                          "moduleid": "HTMGT_MOD_BUILD_OCCS",
                        "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                         "userdata1": "functional processor count",
                         "userdata2": "",
                      },
            0x270A08: {    "devdesc": "Timeout waiting for TPM data available.",
                          "moduleid": "TPMDD_POLLFORDATAAVAIL",
                        "reasoncode": "TPM_TIMEOUT",
                         "userdata1": "TPM",
                         "userdata2": "STS Reg",
                      },
            0x2BAE08: {    "devdesc": "Command failure performing PCR read.",
                          "moduleid": "MOD_TPM_CMD_PCRREAD",
                        "reasoncode": "RC_TPM_COMMAND_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "dataSize",
                      },
            0x2BAF08: {    "devdesc": "pcr read invalid arguments",
                          "moduleid": "MOD_TPM_CMD_PCRREAD",
                        "reasoncode": "RC_TPM_INVALID_ARGS",
                         "userdata1": "Digest Ptr",
                         "userdata2": "Full Digest Size",
                      },
            0x341008: {    "devdesc": "LPC error detected.",
                          "moduleid": "Bootloader::MOD_PNORACC_FINDTOC",
                        "reasoncode": "Bootloader::RC_LPC_ERR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x341108: {    "devdesc": "TOC not found",
                          "moduleid": "Bootloader::MOD_PNORACC_FINDTOC",
                        "reasoncode": "Bootloader::RC_TOC_NOT_FOUND_ERR",
                         "userdata1": "TI_WITH_SRC",
                         "userdata2": "TI_BOOTLOADER",
                      },
            0x370D08: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                          "moduleid": "MMIO::MOD_DETERMINE_CALLOUTS",
                        "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                         "userdata1": "OCMB HUID",
                         "userdata2": "OCMB chip ID",
                      },
            0x31209: {    "devdesc": "SCOM runtime interface not linked.",
                          "moduleid": "SCOM_RT_SEND_SCOM_TO_HYP",
                        "reasoncode": "SCOM_RUNTIME_INTERFACE_ERR",
                         "userdata1": "SCOM Op Type",
                         "userdata2": "SCOM address",
                      },
            0x31509: {    "devdesc": "Error from Hypervisor attempting SCOM",
                          "moduleid": "SCOM_RT_SEND_SCOM_TO_HYP",
                        "reasoncode": "SCOM_RUNTIME_HYP_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "Chipid sent to Hyp",
                      },
            0x60909: {    "devdesc": "PNOR startup task returned an error.",
                          "moduleid": "PNOR::MOD_PNORRP_DIDSTARTUPFAIL",
                        "reasoncode": "PNOR::RC_BAD_STARTUP_RC",
                         "userdata1": "return code pnorrp",
                         "userdata2": "return code spnorrp",
                      },
            0x70A09: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                          "moduleid": "I2C_SEND_SLAVE_STOP",
                        "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                         "userdata1": "Target for the attribute",
                         "userdata2": "<UNUSED>",
                      },
            0xA0B09: {    "devdesc": "FsiDD::genFullFsiAddr> Master Type is not supported",
                          "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_FSI_NOT_SUPPORTED",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Physical Node of FSI Master processor",
                      },
            0xA0C09: {    "devdesc": "FsiDD::genFullFsiAddr> Cannot chain 2 masters",
                          "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_INVALID_FSI_PATH_1",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Target's FSI Master Chip",
                      },
            0xA0D09: {    "devdesc": "FsiDD::genFullFsiAddr> Invalid master type for the target's master",
                          "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_INVALID_FSI_PATH_2",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Target's FSI Master Chip",
                      },
            0xB0309: {    "devdesc": "While attempting to allocate a virtual memory block for an attribute section, the kernel returned an error.",
                          "moduleid": "TARG_CREATE_VMM_SECTIONS",
                        "reasoncode": "TARG_RC_MM_BLOCK_FAIL",
                         "userdata1": "vAddress attempting to allocate.",
                         "userdata2": "RC from kernel.",
                      },
            0xE0109: {    "devdesc": "cacheEeprom invalid op type",
                          "moduleid": "EEPROM_CACHE_PERFORM_OP",
                        "reasoncode": "EEPROM_INVALID_OPERATION",
                         "userdata1": "Op Type that was invalid",
                         "userdata2": "Eeprom Role",
                      },
            0xE0809: {    "devdesc": "cacheEeprom invalid op type",
                          "moduleid": "EEPROM_CACHE_PERFORM_OP",
                        "reasoncode": "EEPROM_OVERFLOW_ERROR",
                         "userdata1": "Length of Operation",
                         "userdata2": "Offset we are attempting to read/write",
                      },
            0xE0A09: {    "devdesc": "cacheEeprom mm_remove_pages FLUSH failed",
                          "moduleid": "EEPROM_CACHE_PERFORM_OP",
                        "reasoncode": "EEPROM_FAILED_TO_FLUSH_CONTENTS",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0xE0D09: {    "devdesc": "Tried to lookup eeprom not in cache",
                          "moduleid": "EEPROM_CACHE_PERFORM_OP",
                        "reasoncode": "EEPROM_NOT_IN_CACHE",
                         "userdata1": "Op Type",
                         "userdata2": "Eeprom Role",
                      },
            0xF0709: {    "devdesc": "Error mapping in memory",
                          "moduleid": "INTR::MOD_INTR_SYNC_NODES",
                        "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                         "userdata1": "physical address",
                         "userdata2": "Block size requested",
                      },
            0x100709: {    "devdesc": "Error: Creation of TOD topology required when TOD HW is running",
                          "moduleid": "TOD_SETUP",
                        "reasoncode": "TOD_INVALID_ACTION",
                         "userdata1": "ChipTOD logic HW state, 1=running, zero otherwise",
                         "userdata2": "",
                      },
            0x110F09: {    "devdesc": "Could not register mailbox message queue",
                          "moduleid": "MBOX::MOD_MBOXSRV_INIT",
                        "reasoncode": "MBOX::RC_KERNEL_REG_FAILED",
                         "userdata1": "rc from msq_q_register",
                         "userdata2": "",
                      },
            0x1A0A09: {    "devdesc": "NACA data doesn't seem right",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_FINDSPIRA",
                        "reasoncode": "RUNTIME::RC_BAD_NACA",
                         "userdata1": "Mainstore address of NACA",
                         "userdata2": "Payload Base Address",
                      },
            0x1A1609: {    "devdesc": "Could not find a valid SPIRA of any type",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_FINDSPIRA",
                        "reasoncode": "RUNTIME::RC_NO_SPIRA",
                         "userdata1": "RC for Legacy SPIRA fail",
                         "userdata2": "EID for Legacy SPIRA fail",
                      },
            0x1E0709: {    "devdesc": "Container's component ID does not match expected component ID",
                          "moduleid": "SECUREBOOT::MOD_SECURE_VERIFY_COMPONENT",
                        "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x220F09: {    "devdesc": "ECC or Data Miscompare Fail Reading Back SBE Version Information",
                          "moduleid": "SBE_GET_SEEPROM_INFO",
                        "reasoncode": "SBE_ECC_FAIL",
                         "userdata1": "ECC Status",
                         "userdata2": "SEEPROM Side",
                      },
            0x250d09: {    "devdesc": "The sensor could not be found based upon the sensor number.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_ENTITY_ID",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_FOUND",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x250f09: {    "devdesc": "The passed in sensor number is not valid.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_ENTITY_ID",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_NUMBER",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x262309: {    "devdesc": "Invalid pass thru command",
                          "moduleid": "HTMGT_MOD_PASS_THRU",
                        "reasoncode": "HTMGT_RC_INVALID_DATA",
                         "userdata1": "command data[0-7]",
                         "userdata2": "command data length",
                      },
            0x262409: {    "devdesc": "Specified OCC not available",
                          "moduleid": "HTMGT_MOD_PASS_THRU",
                        "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                         "userdata1": "command data[0-7]",
                         "userdata2": "command data length",
                      },
            0x264509: {    "devdesc": "Invalid pass thru command data",
                          "moduleid": "HTMGT_MOD_PASS_THRU",
                        "reasoncode": "HTMGT_RC_INVALID_PARAMETER",
                         "userdata1": "command data[0-7]",
                         "userdata2": "command data length",
                      },
            0x270809: {    "devdesc": "TPM expected less data during FIFO write",
                          "moduleid": "TPMDD_WRITEFIFO",
                        "reasoncode": "TPM_OVERFLOW_ERROR",
                         "userdata1": "TPM",
                         "userdata2": "Current byte",
                      },
            0x270909: {    "devdesc": "TPM expected more data during FIFO write",
                          "moduleid": "TPMDD_WRITEFIFO",
                        "reasoncode": "TPM_UNDERFLOW_ERROR",
                         "userdata1": "TPM",
                         "userdata2": "Current Byte",
                      },
            0x270A09: {    "devdesc": "TPM timeout writing to FIFO",
                          "moduleid": "TPMDD_WRITEFIFO",
                        "reasoncode": "TPM_TIMEOUT",
                         "userdata1": "TPM",
                         "userdata2": "Current Byte",
                      },
            0x2BA909: {    "devdesc": "Unmarshal error while replaying tpm log.",
                          "moduleid": "MOD_TPM_REPLAY_LOG",
                        "reasoncode": "RC_TPM_UNMARSHALING_FAIL",
                         "userdata1": "Starting address of event that caused error",
                         "userdata2": "0",
                      },
            0x332509: {    "devdesc": "Unable to resolve other end of bus",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_OTHER_END",
                        "reasoncode": "fapi2::RC_FOUND_TOO_MANY_PEERS",
                         "userdata1": "Unused",
                         "userdata2": "Unused",
                      },
            0x332609: {    "devdesc": "Unable to resolve other end of bus",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_OTHER_END",
                        "reasoncode": "fapi2::RC_FOUND_NO_PEERS",
                         "userdata1": "Unused",
                         "userdata2": "Unused",
                      },
            0x370809: {    "devdesc": "OCMB MMIO read failed",
                          "moduleid": "MMIO::MOD_DETERMINE_EXP_CALLOUTS",
                        "reasoncode": "MMIO::RC_BAD_MMIO_READ",
                         "userdata1": "OCMB huid",
                         "userdata2": "Address offset",
                      },
            0x900509: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_SLCA_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x3010A: {    "devdesc": "The provided address is over 32 bits long which makes it invalid.",
                          "moduleid": "SCOM_OP_SANITY_CHECK",
                        "reasoncode": "SCOM_INVALID_ADDR",
                         "userdata1": "Scom address",
                         "userdata2": "Scom target",
                      },
            0x3160A: {    "devdesc": "Buffer size is less than allowed or NULL data buffer",
                          "moduleid": "SCOM_OP_SANITY_CHECK",
                        "reasoncode": "SCOM_INVALID_DATA_BUFFER",
                         "userdata1": "Buffer size",
                         "userdata2": "Minimum allowed buffer size",
                      },
            0x3170A: {    "devdesc": "Scom invalid operation type",
                          "moduleid": "SCOM_OP_SANITY_CHECK",
                        "reasoncode": "SCOM_INVALID_OP_TYPE",
                         "userdata1": "Operation type",
                         "userdata2": "Scom address",
                      },
            0x61E0A: {    "devdesc": "mm_remove_pages failed",
                          "moduleid": "PNOR::MOD_PNORRP_FLUSH",
                        "reasoncode": "PNOR::RC_MM_REMOVE_PAGES_FAILED",
                         "userdata1": "section Id",
                         "userdata2": "RC",
                      },
            0x6310A: {    "devdesc": "Error parsing secure header",
                          "moduleid": "SECUREBOOT::MOD_SECURE_CONT_HDR_PARSE",
                        "reasoncode": "PNOR::RC_BAD_SECURE_MAGIC_NUM",
                         "userdata1": "Actual magic number",
                         "userdata2": "Expected magic number",
                      },
            0x70A0A: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                          "moduleid": "I2C_PROCESS_ACTIVE_MASTERS",
                        "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                         "userdata1": "Target for the attribute",
                         "userdata2": "Operation",
                      },
            0x90D0A: {    "devdesc": "Attempt to read an MVPD field using an invalid record",
                          "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                        "reasoncode": "RC_INVALID_RECORD",
                         "userdata1": "Record enumerator",
                         "userdata2": "",
                      },
            0x90E0A: {    "devdesc": "Attempt to read an MVPD field using an invalid keyword",
                          "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                        "reasoncode": "RC_INVALID_KEYWORD",
                         "userdata1": "Keyword enumerator",
                         "userdata2": "",
                      },
            0x9100A: {    "devdesc": "Attempt to read an MVPD field using an invalid record",
                          "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                        "reasoncode": "RC_RECORD_OUT_OF_BOUNDS",
                         "userdata1": "Record enumerator",
                         "userdata2": "Index",
                      },
            0x9110A: {    "devdesc": "Attempt to read an MVPD field using an invalid keyword",
                          "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                        "reasoncode": "RC_KEYWORD_OUT_OF_BOUNDS",
                         "userdata1": "Keyword enumerator",
                         "userdata2": "Index",
                      },
            0xA110A: {    "devdesc": "FsiDD::checkForErrors> Error discovered in MAEB",
                          "moduleid": "FSI::MOD_FSIDD_CHECKFORERRORS",
                        "reasoncode": "FSI::RC_ERROR_IN_MAEB",
                         "userdata1": "Physical Node of FSI Master processor",
                         "userdata2": "Physical Position of FSI Master processor",
                      },
            0xC160A: {    "devdesc": "To enforce all target types have partial good rules and logic, all targets must be included in the rules table. A combination of target type, chip type, and chip unit produced an empty set of logic for the target.",
                          "moduleid": "HWAS::MOD_FIND_RULES_FOR_TARGET",
                        "reasoncode": "HWAS::RC_NO_PG_LOGIC",
                         "userdata1": "target type attribute",
                         "userdata2": "HUID of the target",
                      },
            0xC190A: {    "devdesc": "A rule called for the use of the MRW's supplied CHIPLET_ID for an index into the PG vector. That value has gone unexpectedly out-of-range.",
                          "moduleid": "HWAS::MOD_FIND_RULES_FOR_TARGET",
                        "reasoncode": "HWAS::RC_PG_INDEX_INVALID",
                         "userdata1": "PG Index value",
                         "userdata2": "HUID of the target",
                      },
            0xE0F0A: {    "devdesc": "invalidateCache failed to find cache in map",
                          "moduleid": "EEPROM_INVALIDATE_CACHE",
                        "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_MAP",
                         "userdata1": "HUID of Master",
                         "userdata2": "Port (or 0xFF)",
                      },
            0xE100A: {    "devdesc": "invalidateCache failed to find cache in pnor",
                          "moduleid": "EEPROM_INVALIDATE_CACHE",
                        "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_PNOR",
                         "userdata1": "HUID of Master",
                         "userdata2": "Port (or 0xFF)",
                      },
            0xF070A: {    "devdesc": "Error mapping in memory",
                          "moduleid": "INTR::MOD_INTR_SYNC_ADDNODE",
                        "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                         "userdata1": "physical address",
                         "userdata2": "Size",
                      },
            0x11050A: {    "devdesc": "Message from FSP. Message not claimed by any Hostboot service.",
                          "moduleid": "MBOX::MOD_MBOXSRC_UNCLAIMED",
                        "reasoncode": "MBOX::RC_INVALID_QUEUE",
                         "userdata1": "msg queue",
                         "userdata2": "msg type",
                      },
            0x160C0A: {    "devdesc": "The size requested is too large for the TCE table",
                          "moduleid": "Util::UTIL_TCE_ALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                         "userdata1": "Number of TCEs Needed",
                         "userdata2": "Size of the address space trying to get TCEs",
                      },
            0x160D0A: {    "devdesc": "The Physical Address for the TCE entry is not page aligned.",
                          "moduleid": "Util::UTIL_TCE_ALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_ADDR_NOT_ALIGNED",
                         "userdata1": "Address to start TCE",
                         "userdata2": "Size of the address space trying to get TCEs for.",
                      },
            0x16100A: {    "devdesc": "Requested size is too large to fit into TCE Table",
                          "moduleid": "Util::UTIL_TCE_ALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_NOT_ENOUGH_FREE_ENTRIES",
                         "userdata1": "Number of TCEs Needed",
                         "userdata2": "Size of address space TCEs are tying to map to",
                      },
            0x16120A: {    "devdesc": "The starting address was previously allocated",
                          "moduleid": "Util::UTIL_TCE_ALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_PREVIOUSLY_ALLOCATED",
                         "userdata1": "Starting Address",
                         "userdata2": "Starting TCE position in TCE Table",
                      },
            0x1A080A: {    "devdesc": "There is no host data for specified kind of payload",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL",
                        "reasoncode": "RUNTIME::RC_INVALID_PAYLOAD_KIND",
                         "userdata1": "ATTR_PAYLOAD_KIND",
                         "userdata2": "Requested Section",
                      },
            0x1A0C0A: {    "devdesc": "Unknown section requested",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL",
                        "reasoncode": "RUNTIME::RC_INVALID_SECTION",
                         "userdata1": "Section Id",
                         "userdata2": "<unused>",
                      },
            0x22100A: {    "devdesc": "Bad Path in decisionUpdateTree: cur=PERM/DIRTY",
                          "moduleid": "SBE_DECISION_TREE",
                        "reasoncode": "SBE_PERM_SIDE_DIRTY_BAD_PATH",
                         "userdata1": "System Situation",
                         "userdata2": "Update Actions",
                      },
            0x250d0A: {    "devdesc": "The sensor could not be found based upon the sensor number.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_NAME",
                        "reasoncode": "IPMI::RC_SENSOR_NOT_FOUND",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x250f0A: {    "devdesc": "The passed in sensor number is not valid.",
                          "moduleid": "IPMI::MOD_IPMISENSOR_NAME",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_NUMBER",
                         "userdata1": "IPMI Sensor Number",
                         "userdata2": "<unused>",
                      },
            0x27080A: {    "devdesc": "TPM provided more data during FIFO read then buffer space provided",
                          "moduleid": "TPMDD_READFIFO",
                        "reasoncode": "TPM_OVERFLOW_ERROR",
                         "userdata1": "TPM",
                         "userdata2": "Operation",
                      },
            0x270A0A: {    "devdesc": "TPM timeout reading from FIFO",
                          "moduleid": "TPMDD_READFIFO",
                        "reasoncode": "TPM_TIMEOUT",
                         "userdata1": "TPM",
                         "userdata2": "Operation",
                      },
            0x27140A: {    "devdesc": "Either the available STS from TPM is wrong or responseSize was wrong",
                          "moduleid": "TPMDD_READFIFO",
                        "reasoncode": "TPM_EXTRA_DATA_AVAILABLE",
                         "userdata1": "TPM",
                         "userdata2": "responseSize returned in first data bytes",
                      },
            0x28520A: {    "devdesc": "SBE booted from unexpected side.",
                          "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                        "reasoncode": "SBEIO_BOOTED_UNEXPECTED_SIDE",
                         "userdata1": "0",
                         "userdata2": "HUID of working proc",
                      },
            0x285C0A: {    "devdesc": "We have already flipped seeprom sides once and we should not have attempted to flip again",
                          "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                        "reasoncode": "SBEIO_EXCEED_MAX_SIDE_SWITCHES",
                         "userdata1": "Switch Sides Count",
                         "userdata2": "HUID of proc",
                      },
            0x285E0A: {    "devdesc": "There was a problem attempting to boot SBE on the slave processor",
                          "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                        "reasoncode": "SBEIO_SLAVE_FAILED_TO_BOOT",
                         "userdata1": "Bool to describe if FFDC data is found",
                         "userdata2": "HUID of proc",
                      },
            0x28620A: {    "devdesc": "Attempted to swap seeprom sides and boot using hreset but version mismatched",
                          "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                        "reasoncode": "SBEIO_SEEPROM_VERSION_MISMATCH",
                         "userdata1": "HUID of proc",
                         "userdata2": "unused",
                      },
            0x2BB10A: {    "devdesc": "msg_sendrecv() failed",
                          "moduleid": "MOD_TPM_PCREXTEND",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "",
                      },
            0x2BB20A: {    "devdesc": "msg_send() failed",
                          "moduleid": "MOD_TPM_PCREXTEND",
                        "reasoncode": "RC_SEND_FAIL",
                         "userdata1": "rc from msq_send()",
                         "userdata2": "",
                      },
            0x37050A: {    "devdesc": "Invalid offset, requested address was out of range for a MMIO operation.",
                          "moduleid": "MMIO::RT_OCMB_MMIO_PERFORM_OP",
                        "reasoncode": "MMIO::RC_INVALID_OFFSET",
                         "userdata1": "Target huid",
                         "userdata2": "Data Offset",
                      },
            0x90050A: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_IPLPARMS_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x6210B: {    "devdesc": "Non ECC protected section is passed to fixECC",
                          "moduleid": "PNOR::MOD_PNORRP_FIXECC",
                        "reasoncode": "PNOR::RC_NON_ECC_PROTECTED_SECTION",
                         "userdata1": "Section ID",
                         "userdata2": "0",
                      },
            0x70A0B: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                          "moduleid": "I2C_FORCE_RESET_AND_UNLOCK",
                        "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                         "userdata1": "Target for the attribute",
                         "userdata2": "<UNUSED>",
                      },
            0xA0E0B: {    "devdesc": "FsiDD::verifyPresent> Target was never detected during FSI Init",
                          "moduleid": "FSI::MOD_FSIDD_VERIFYPRESENT",
                        "reasoncode": "FSI::RC_TARGET_NEVER_DETECTED",
                         "userdata1": "HUID of Master Proc",
                         "userdata2": "Detected Slaves",
                      },
            0xB160B: {    "devdesc": "Invalid enum value for attribute.",
                          "moduleid": "TARGETING::TARG_HANDLE_ENUM_CHECK_FAILURE",
                        "reasoncode": "TARGETING::TARG_RC_ATTRIBUTE_ENUM_CHECK_FAIL",
                         "userdata1": "Target's HUID",
                         "userdata2": "Attribute ID",
                      },
            0xC1A0B: {    "devdesc": "Partial Good (PG) issues are present within the system and this error log contains information about which targets, procs, and entries in the PG vector are problematic.",
                          "moduleid": "MOD_DISCOVER_TARGETS",
                        "reasoncode": "RC_PARTIAL_GOOD_INFORMATION",
                         "userdata1": "None",
                         "userdata2": "None",
                      },
            0xE0F0B: {    "devdesc": "resolveSource failed to find cache in map during runtime",
                          "moduleid": "EEPROM_RESOLVE_SOURCE",
                        "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_MAP",
                         "userdata1": "master Huid",
                         "userdata2": "port (or 0xFF)",
                      },
            0xF030B: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_ADDHBNODE",
                        "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                         "userdata1": "MSG_INTR_ADD_HBNODE",
                         "userdata2": "hbNode to add",
                      },
            0x10080B: {    "devdesc": "Error: Erroneous TOD configuration Possible Causes: Programming issue Resolution: Development team should be contacted.",
                          "moduleid": "TOD_LOG_INVALID_CONFIG",
                        "reasoncode": "TOD_INVALID_CONFIG",
                         "userdata1": "The problematic configuration ( Primary/Secondary)",
                         "userdata2": "",
                      },
            0x11050B: {    "devdesc": "Error sending IPC message",
                          "moduleid": "MBOX::MOD_MBOX_SEND",
                        "reasoncode": "MBOX::RC_INVALID_QUEUE",
                         "userdata1": "returncode from msg_send()",
                         "userdata2": "q_handle",
                      },
            0x11110B: {    "devdesc": "An invalid node was specified",
                          "moduleid": "MBOX::MOD_MBOX_SEND",
                        "reasoncode": "MBOX::RC_IPC_INVALID_NODE",
                         "userdata1": "The destination queue id",
                         "userdata2": "The node",
                      },
            0x160C0B: {    "devdesc": "The size requested is too large based on the startingAddress the space avilable in the table",
                          "moduleid": "Util::UTIL_TCE_DEALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                         "userdata1": "starting index",
                         "userdata2": "number of TCEs needed for this request",
                      },
            0x16110B: {    "devdesc": "The deallocate went across TCE Allocate space.",
                          "moduleid": "Util::UTIL_TCE_DEALLOCATE",
                        "reasoncode": "Util::UTIL_TCE_ENTRY_NOT_CONTIGUOUS",
                         "userdata1": "Starting address of the TCEs to be deallocated",
                         "userdata2": "Size of the address space to be deallocated",
                      },
            0x17000B: {    "devdesc": "Request given to load payload into mirrored memory, but no mirrored memory exists at that location.",
                          "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                        "reasoncode": "ISTEP::RC_NO_MIRRORED_MEMORY",
                         "userdata1": "Mirrored Memory Address",
                         "userdata2": "0",
                      },
            0x17010B: {    "devdesc": "Failure extending memory to after exiting cache contained mode.",
                          "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                        "reasoncode": "ISTEP::RC_MM_EXTEND_FAILED",
                         "userdata1": "rc from mm_extend",
                         "userdata2": "<UNUSED>",
                      },
            0x171E0B: {    "devdesc": "There is no functional memory",
                          "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                        "reasoncode": "ISTEP::RC_NO_FUNCTIONAL_MEMORY",
                         "userdata1": "Bottom of memory",
                         "userdata2": "Top of memory",
                      },
            0x1A050B: {    "devdesc": "Error mapping in memory",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_MAPREGION",
                        "reasoncode": "RUNTIME::RC_CANNOT_MAP_MEMORY",
                         "userdata1": "Starting Address",
                         "userdata2": "Size",
                      },
            0x1E0C0B: {    "devdesc": "Error parsing secure header; requested copy size starting at current offset would exceed the header size or the max transaction size.  Reinstall boot firmware.",
                          "moduleid": "SECUREBOOT::MOD_SECURE_CONT_HDR_CPY_INC",
                        "reasoncode": "SECUREBOOT::RC_CONT_HDR_NO_SPACE",
                         "userdata1": "Total bytes read so far",
                         "userdata2": "Requested size to copy",
                      },
            0x22110B: {    "devdesc": "Unsuccessful in creating Customized SBE Image",
                          "moduleid": "SBE_CUSTOMIZE_IMG",
                        "reasoncode": "SBE_P10_XIP_CUSTOMIZE_UNSUCCESSFUL",
                         "userdata1": "procIOMask in/out parameter",
                         "userdata2": "rc of procedure",
                      },
            0x221E0B: {    "devdesc": "Did not find the HBBL ID signature in customized image",
                          "moduleid": "SBE_CUSTOMIZE_IMG",
                        "reasoncode": "SBE_HBBL_ID_NOT_FOUND",
                         "userdata1": "i_SourceBfrLen",
                         "userdata2": "Unused",
                      },
            0x25100B: {    "devdesc": "The sensor returned an invalid setting",
                          "moduleid": "IPMI::MOD_IPMISENSOR_REBOOTCNTRL",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_SETTING",
                         "userdata1": "Invalid reboot control setting",
                         "userdata2": "<unused>",
                      },
            0x26050B: {    "devdesc": "Set of OCC state failed",
                          "moduleid": "HTMGT_MOD_WAIT_FOR_CHECKPOINT",
                        "reasoncode": "HTMGT_RC_OCC_NOT_READY",
                         "userdata1": "OCC instance",
                         "userdata2": "last OCC checkpoint",
                      },
            0x270A0B: {    "devdesc": "TPM timeout waiting for stsValid",
                          "moduleid": "TPMDD_READSTSREGVALID",
                        "reasoncode": "TPM_TIMEOUT",
                         "userdata1": "TPM",
                         "userdata2": "Operation",
                      },
            0x2BB30B: {    "devdesc": "msg_respond() failed",
                          "moduleid": "MOD_TPM_TPMDAEMON",
                        "reasoncode": "RC_MSGRESPOND_FAIL",
                         "userdata1": "rc from msq_respond()",
                         "userdata2": "",
                      },
            0x2BBA0B: {    "devdesc": "Unable to reach the TPM",
                          "moduleid": "MOD_TPM_TPMDAEMON",
                        "reasoncode": "RC_UNREACHABLE_TPM",
                         "userdata1": "TPM HUID or nullptr",
                         "userdata2": "",
                      },
            0x2BBB0B: {    "devdesc": "Attempted to request a random number that is bigger than the max a TPM can provide",
                          "moduleid": "MOD_TPM_TPMDAEMON",
                        "reasoncode": "RC_RAND_NUM_TOO_BIG",
                         "userdata1": "The size of requested random number",
                         "userdata2": "The maximum random number size",
                      },
            0x33220B: {    "devdesc": "Invalid amount of child cores found on a proc",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_CHILDREN_FILTER_TEST",
                        "reasoncode": "fapi2::RC_INVALID_CHILD_COUNT",
                         "userdata1": "Expected Child Count",
                         "userdata2": "Actual Child Count",
                      },
            0x7070C: {    "devdesc": "Master Sentinel chip was used as a target for an I2C operation.  This is not permitted.",
                          "moduleid": "I2C_PAGE_SWITCH_OP",
                        "reasoncode": "I2C_MASTER_SENTINEL_TARGET",
                         "userdata1": "Operation Type requested",
                         "userdata2": "<UNUSED>",
                      },
            0x70A0C: {    "devdesc": "ATTR_EEPROM_PAGE_ARRAY not found",
                          "moduleid": "I2C_PAGE_SWITCH_OP",
                        "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                         "userdata1": "Target HUID for the attribute",
                         "userdata2": "<UNUSED>",
                      },
            0x7100C: {    "devdesc": "There was an error retrieving the EEPROM page mutex for this i2c master engine",
                          "moduleid": "I2C_PAGE_SWITCH_OP",
                        "reasoncode": "I2C_INVALID_EEPROM_PAGE_MUTEX",
                         "userdata1": "Target Huid",
                         "userdata2": "<UNUSED>",
                      },
            0xA120C: {    "devdesc": "FsiDD::initializeHardware> Unexpected attribute data for remote FSI link",
                          "moduleid": "FSI::MOD_FSIDD_INITIALIZEHARDWARE",
                        "reasoncode": "FSI::RC_BAD_ATTRIBUTES",
                         "userdata1": "Slave HUID",
                         "userdata2": "Slave FSI LinkId",
                      },
            0xB170C: {    "devdesc": "Invalid range for attribute value.",
                          "moduleid": "TARGETING::TARG_HANDLE_RANGE_CHECK_FAILURE",
                        "reasoncode": "TARGETING::TARG_RC_ATTRIBUTE_RANGE_CHECK_FAIL",
                         "userdata1": "Target's HUID",
                         "userdata2": "Attribute ID",
                      },
            0xE110C: {    "devdesc": "Attempted to lookup VPD in reserved memory and failed",
                          "moduleid": "EEPROM_CACHE_INIT_RT",
                        "reasoncode": "EEPROM_CACHE_NO_VPD_IN_RSV_MEM",
                         "userdata1": "Node Id",
                         "userdata2": "Unused",
                      },
            0xE120C: {    "devdesc": "Attempted to lookup VPD in reserved memory and failed",
                          "moduleid": "EEPROM_CACHE_INIT_RT",
                        "reasoncode": "EEPROM_DUPLICATE_CACHE_ENTRY",
                         "userdata1": "master Huid",
                         "userdata2": "port (or 0xFF)",
                      },
            0x10090C: {    "devdesc": "Error: The ordinal Id of one of the TOD procs did not fall in the range 0 <= Ordinal Id < getMaxProcsOnSystem Possible Causes: TOD logic has not been updated to support the latest system type where the no. of processor chips is either equal to or more than getMaxProcsOnSystem Resolution: Development team should be contacted.",
                          "moduleid": "TOD_LOG_UNSUPORTED_ORDINALID",
                        "reasoncode": "TOD_UNSUPORTED_ORDINALID",
                         "userdata1": "Ordinal Id for which the error is logged",
                         "userdata2": "",
                      },
            0x11050C: {    "devdesc": "Invalid message queue ID",
                          "moduleid": "MOD_MBOXSRV_IPC_MSG",
                        "reasoncode": "RC_INVALID_QUEUE",
                         "userdata1": "msg queue",
                         "userdata2": "msg type",
                      },
            0x11120C: {    "devdesc": "Invalid msg or msg queue",
                          "moduleid": "MBOX::MOD_MBOXSRV_IPC_MSG",
                        "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                         "userdata1": "rc from msg_send()",
                         "userdata2": "msg queue id",
                      },
            0x16020C: {    "devdesc": "TCE Table Could Not Be Block-Mapped",
                          "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                        "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                         "userdata1": "Physical Address of the TCE Table",
                         "userdata2": "Requested Size of the TCE Table",
                      },
            0x160C0C: {    "devdesc": "TCE Table size requested too large.",
                          "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                        "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                         "userdata1": "Size of of the table that is too large",
                         "userdata2": "Max TCE Table Size",
                      },
            0x160D0C: {    "devdesc": "TCE Table not page aligned.",
                          "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                        "reasoncode": "Util::UTIL_TCE_ADDR_NOT_ALIGNED",
                         "userdata1": "Phyiscal Address of the TCE Table",
                         "userdata2": "<unused>",
                      },
            0x16130C: {    "devdesc": "TCE Table size requested too large.",
                          "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                        "reasoncode": "Util::UTIL_TCE_INVALID_COUNT",
                         "userdata1": "Number of TCEs Requested",
                         "userdata2": "Max Number of TCEs that TCE Table can hold",
                      },
            0x1A230C: {    "devdesc": "Unsupported section requested",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GETINSTANCECOUNT",
                        "reasoncode": "RUNTIME::RC_INSTANCES_UNSUPPORTED",
                         "userdata1": "Section Id",
                         "userdata2": "<unused>",
                      },
            0x1E0D0C: {    "devdesc": "Error parsing secure header",
                          "moduleid": "SECUREBOOT::MOD_SECURE_CONT_VALIDATE",
                        "reasoncode": "SECUREBOOT::RC_CONT_HDR_INVALID",
                         "userdata1": "Magic Number",
                         "userdata2": "ROM version",
                      },
            0x22120C: {    "devdesc": "Successful Update of SBE SEEPROM SBE Version Information",
                          "moduleid": "SBE_PERFORM_UPDATE_ACTIONS",
                        "reasoncode": "SBE_INFO_LOG",
                         "userdata1": "Update Actions Enum",
                         "userdata2": "Customized Data CRC",
                      },
            0x25100C: {    "devdesc": "The sensor returned an invalid setting",
                          "moduleid": "IPMI::MOD_IPMISENSOR_HBVOLATILE",
                        "reasoncode": "IPMI::RC_INVALID_SENSOR_SETTING",
                         "userdata1": "Invalid hb volatile control setting",
                         "userdata2": "<unused>",
                      },
            0x27010C: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                          "moduleid": "TPMDD_TPMPRESENCEDETECT",
                        "reasoncode": "TPM_INVALID_OPERATION",
                         "userdata1": "Data Length",
                         "userdata2": "",
                      },
            0x28570C: {    "devdesc": "FFDC returned by SBE after failing to reach runtime",
                          "moduleid": "SBEIO_GET_FFDC_HANDLER",
                        "reasoncode": "SBEIO_RETURNED_FFDC",
                         "userdata1": "Processor Target",
                         "userdata2": "Number of FFDC packages",
                      },
            0x285B0C: {    "devdesc": "Unexpected number of FFDC packages in buffer",
                          "moduleid": "SBEIO_GET_FFDC_HANDLER",
                        "reasoncode": "SBEIO_MORE_FFDC_THAN_EXPECTED",
                         "userdata1": "Maximum expected packages",
                         "userdata2": "Number of FFDC packages",
                      },
            0x2BB30C: {    "devdesc": "msg_respond() failed",
                          "moduleid": "MOD_TPM_SYNCRESPONSE",
                        "reasoncode": "RC_MSGRESPOND_FAIL",
                         "userdata1": "rc from msq_respond()",
                         "userdata2": "",
                      },
            0x332A0C: {    "devdesc": "Invalid attribute read request",
                          "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_ATTR",
                        "reasoncode": "RC_INVALID_ATTRIBUTE",
                         "userdata1": "FAPI2 Target Type",
                         "userdata2": "HB Target HUID",
                      },
            0x6270D: {    "devdesc": "PnorRP::getSideInfo> Side not supported",
                          "moduleid": "PNOR::MOD_PNORRP_GETSIDEINFO",
                        "reasoncode": "PNOR::RC_INVALID_PNOR_SIDE",
                         "userdata1": "Requested SIDE",
                         "userdata2": "0",
                      },
            0x7100D: {    "devdesc": "There was an error retrieving the EEPROM page mutex for this i2c master engine",
                          "moduleid": "I2C_PAGE_UNLOCK_OP",
                        "reasoncode": "I2C_INVALID_EEPROM_PAGE_MUTEX",
                         "userdata1": "Target Huid",
                         "userdata2": "<UNUSED>",
                      },
            0xB040D: {    "devdesc": "While attempting to set permissions on a virtual memory block for an attribute section, the kernel returned an error.",
                          "moduleid": "TARG_EDIT_PAGE_PERMISSIONS",
                        "reasoncode": "TARG_RC_MM_PERM_FAIL",
                         "userdata1": "vAddress attempting to allocate.",
                         "userdata2": "(kernel-rc << 32) | (Permissions)",
                      },
            0xB060D: {    "devdesc": "Found unhandled attribute section type",
                          "moduleid": "TARG_EDIT_PAGE_PERMISSIONS",
                        "reasoncode": "TARG_RC_UNHANDLED_ATTR_SEC_TYPE",
                         "userdata1": "Section type",
                         "userdata2": "",
                      },
            0xC1E0D: {    "devdesc": "A target was not found in the map of states kept by the PG checking algorithm. Therefore, it did not have PG checks run against it.",
                          "moduleid": "MOD_CHECK_PG_FOR_DESC",
                        "reasoncode": "RC_PARTIAL_GOOD_MISSING_TARGET",
                         "userdata1": "huid of the target",
                         "userdata2": "",
                      },
            0xE130D: {    "devdesc": "Not sure how to perform operation with unknown access method type",
                          "moduleid": "EEPROM_PERFORM_OP_HW",
                        "reasoncode": "EEPROM_INVALID_ACCESS_METHOD",
                         "userdata1": "Target device associated w/ the EEPROM",
                         "userdata2": "Access method",
                      },
            0xF080D: {    "devdesc": "Unexpected RC from issuing PSIHB EOI store",
                          "moduleid": "INTR::MOD_INTRRP_SENDEOI",
                        "reasoncode": "INTR::RC_PSIHB_ESB_EOI_FAIL",
                         "userdata1": "Value read from EOI load",
                         "userdata2": "Interrupt Source to issue EOI to",
                      },
            0x11120D: {    "devdesc": "Message send to mailbox sp failed",
                          "moduleid": "MBOX::MOD_MBOX_MSGQ_FAIL",
                        "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                         "userdata1": "kernel errno",
                         "userdata2": "<unused>",
                      },
            0x16150D: {    "devdesc": "mm_block_unmap failed for TCE Table",
                          "moduleid": "Util::UTIL_TCE_DISABLE_TCES",
                        "reasoncode": "Util::UTIL_TCE_BLOCK_UNMAP_FAIL",
                         "userdata1": "Starting virtual address of pages to be removed",
                         "userdata2": "Return Code from mm_block_unmap",
                      },
            0x17110D: {    "devdesc": "Mixed bus connection of two types",
                          "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                        "reasoncode": "RC_MIXED_PBUS_CONNECTION",
                         "userdata1": "Endpoint1 bus type",
                         "userdata2": "Endpoint2 bus type",
                      },
            0x17120D: {    "devdesc": "Both endpoint connections of same chip",
                          "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                        "reasoncode": "RC_SAME_CHIP_PBUS_CONNECTION",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x17130D: {    "devdesc": "Connection is conflicting. endp1 -> endp2 but endp2 -> endp3. endp1 -> endp2 but endp2 -> endp2 (itself) or not existing",
                          "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                        "reasoncode": "RC_CONFLICT_PBUS_CONNECTION",
                         "userdata1": "Bus endpoint target pointer1",
                         "userdata2": "Bus endpoint target pointer2",
                      },
            0x1A260D: {    "devdesc": "Unsupported section requested",
                          "moduleid": "RUNTIME::MOD_HDATSERVICE_GETANDCHECKTUPLE",
                        "reasoncode": "RUNTIME::RC_GETTUPLE_UNSUPPORTED",
                         "userdata1": "Section Id",
                         "userdata2": "<unused>",
                      },
            0x1E0E0D: {    "devdesc": "Invalid SBE security mode",
                          "moduleid": "SECUREBOOT::MOD_SECURE_SET_SBE_SECURE_MODE",
                        "reasoncode": "SECUREBOOT::RC_SBE_INVALID_SEC_MODE",
                         "userdata1": "Security mode to set",
                         "userdata2": "0",
                      },
            0x22130D: {    "devdesc": "SBE Version Miscompare with Master Target",
                          "moduleid": "SBE_MASTER_VERSION_COMPARE",
                        "reasoncode": "SBE_MISCOMPARE_WITH_MASTER_VERSION",
                         "userdata1": "Master Target HUID",
                         "userdata2": "Comparison Target HUID",
                      },
            0x22140D: {    "devdesc": "Error Associated with Updating this Target",
                          "moduleid": "SBE_MASTER_VERSION_COMPARE",
                        "reasoncode": "SBE_ERROR_ON_UPDATE",
                         "userdata1": "Target HUID",
                         "userdata2": "Original Error PLID",
                      },
            0x22150D: {    "devdesc": "SBE Image Version Miscompare with Master Target",
                          "moduleid": "SBE_MASTER_VERSION_COMPARE",
                        "reasoncode": "SBE_MASTER_VERSION_DOWNLEVEL",
                         "userdata1": "Master Target HUID",
                         "userdata2": "Master Target Loop Index",
                      },
            0x270D0D: {    "devdesc": "The system's TPM Required policy is set to TPM Required and a TPM that was expected to be present was not detected properly.  The TPM in question will eventually be flagged as TPM_UNUSABLE for redundancy calculations, Possible causes: (1) absent or improperly seated TPM, (2) TPM hardware failure, (3) firmware bug, (4) incorrect TPM part, (5) SPI failure, (6) processor failure, See earlier error logs with same PLID for additional details.",
                          "moduleid": "TPMDD_TPMPRESENCE",
                        "reasoncode": "TPM_RC_TPM_NOT_DETECTED",
                         "userdata1": "TPM HUID",
                         "userdata2": "",
                      },
            0x270E0D: {    "devdesc": "Unexpected vendor ID read from TPM",
                          "moduleid": "TPMDD_TPMPRESENCE",
                        "reasoncode": "TPM_RC_UNEXPECTED_VENDOR_ID",
                         "userdata1": "Expected vendor ID",
                         "userdata2": "Actual vendor ID",
                      },
            0x2BB10D: {    "devdesc": "msg_sendrecv() failed",
                          "moduleid": "MOD_TPM_SEPARATOR",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "",
                      },
            0x2BB20D: {    "devdesc": "msg_send() failed",
                          "moduleid": "MOD_TPM_SEPARATOR",
                        "reasoncode": "RC_SEND_FAIL",
                         "userdata1": "rc from msq_send()",
                         "userdata2": "",
                      },
            0x332A0D: {    "devdesc": "Invalid attribute write request",
                          "moduleid": "fapi2::MOD_FAPI2_SET_TARGETING_ATTR",
                        "reasoncode": "RC_INVALID_ATTRIBUTE",
                         "userdata1": "FAPI2 Target Type",
                         "userdata2": "HB Target HUID",
                      },
            0x90010D: {    "devdesc": "input Target pointer is NULL",
                          "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                        "reasoncode": "HDAT::RC_INVALID_OBJECT",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90040D: {    "devdesc": "Target class not supported",
                          "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                        "reasoncode": "HDAT::RC_TARGET_UNSUPPORTED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90060D: {    "devdesc": "node returned empty Target list",
                          "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                        "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x3110E: {    "devdesc": "Hypervisor wakeup failed.",
                          "moduleid": "SCOM_CALL_WAKEUP_HYP",
                        "reasoncode": "SCOM_RUNTIME_WAKEUP_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "Runtime Target ID",
                      },
            0x3120E: {    "devdesc": "Wakeup runtime interface not linked.",
                          "moduleid": "SCOM_CALL_WAKEUP_HYP",
                        "reasoncode": "SCOM_RUNTIME_INTERFACE_ERR",
                         "userdata1": "Target HUID",
                         "userdata2": "Wakeup Enable",
                      },
            0x60C0E: {    "devdesc": "PNOR::validateAltMaster> Fail verifying FFS Header on Master Candidate PNOR TOC0",
                          "moduleid": "PNOR::MOD_PNORVALID_MAIN",
                        "reasoncode": "PNOR::RC_PARTITION_TABLE_INVALID",
                         "userdata1": "Master Candidate Processor Target",
                         "userdata2": "<unused>",
                      },
            0x6290E: {    "devdesc": "PnorRP::setSideInfo> No valid TOCs found",
                          "moduleid": "PNOR::MOD_PNORRP_SETSIDEINFO",
                        "reasoncode": "PNOR::RC_INVALID_TOC",
                         "userdata1": "Side Id",
                         "userdata2": "primary toc",
                      },
            0x7110E: {    "devdesc": "There was a request for an invalid EEPROM page",
                          "moduleid": "I2C_CHOOSE_EEPROM_PAGE",
                        "reasoncode": "I2C_INVALID_EEPROM_PAGE_REQUEST",
                         "userdata1": "Target Huid",
                         "userdata2": "Requested Page",
                      },
            0xC1F0E: {    "devdesc": "The EC (Revision) info read from the OCMB and SPD did not match the expected values.",
                          "moduleid": "MOD_OCMB_IDEC",
                        "reasoncode": "RC_OCMB_SPD_REVISION_MISMATCH",
                         "userdata1": "OCMB IDEC register EC",
                         "userdata2": "Translated SPD EC",
                      },
            0xC210E: {    "devdesc": "The ID read from the SPD didn't match any known OCMB chip types.",
                          "moduleid": "MOD_OCMB_IDEC",
                        "reasoncode": "RC_OCMB_UNKNOWN_CHIP_TYPE",
                         "userdata1": "SPD Module Revision",
                         "userdata2": "DRAM Interface Type Presented or Emulated",
                      },
            0xC220E: {    "devdesc": "The memory interface type read from the SPD did not match the DDIMM value. Setting the appropriate IDEC values for this target cannot continue.",
                          "moduleid": "MOD_OCMB_IDEC",
                        "reasoncode": "RC_OCMB_INTERFACE_TYPE_MISMATCH",
                         "userdata1": "SPD Module Revision",
                         "userdata2": "DRAM Interface Type Presented or Emulated",
                      },
            0xC230E: {    "devdesc": "The IDEC info read from the OCMB and SPD did not match the expected values.",
                          "moduleid": "MOD_OCMB_IDEC",
                        "reasoncode": "RC_OCMB_CHIP_ID_MISMATCH",
                         "userdata1": "OCMB IDEC Register ID",
                         "userdata2": "Translated SPD ID",
                      },
            0xE010E: {    "devdesc": "Operation type is not supported",
                          "moduleid": "EEPROM_PERFORM_SPI_OP",
                        "reasoncode": "EEPROM_INVALID_OPERATION",
                         "userdata1": "EEPROM operation type",
                         "userdata2": "target",
                      },
            0x100B0E: {    "devdesc": "nullptr is passed in for node target",
                          "moduleid": "TOD_GETFUNCNODETARGETSONSYSTEM",
                        "reasoncode": "TOD_NULL_INPUT_TARGET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x100C0E: {    "devdesc": "Input target is not a node or sys target",
                          "moduleid": "TOD_GETFUNCNODETARGETSONSYSTEM",
                        "reasoncode": "TOD_INVALID_TARGET",
                         "userdata1": "Target HUID",
                         "userdata2": "",
                      },
            0x160E0E: {    "devdesc": "PSI Bridge device Map failed",
                          "moduleid": "Util::UTIL_TCE_MAP_PSIHB",
                        "reasoncode": "Util::UTIL_TCE_DEV_MAP_FAIL",
                         "userdata1": "Address to be mapped PsiBridgeAddr",
                         "userdata2": "Target Unit Id",
                      },
            0x1A300E: {    "devdesc": "Trying to load invalid lid",
                          "moduleid": "RUNTIME::MOD_PREVERLIDMGR_LOAD_FROM_PNOR",
                        "reasoncode": "RUNTIME::RC_INVALID_LID",
                         "userdata1": "PNOR section",
                         "userdata2": "Lid id mapped from PNOR section",
                      },
            0x1A310E: {    "devdesc": "No content after Section header or size was parsed from secure header incorrectly.",
                          "moduleid": "RUNTIME::MOD_PREVERLIDMGR_LOAD_FROM_PNOR",
                        "reasoncode": "RUNTIME::RC_PREVER_INVALID_SIZE",
                         "userdata1": "PNOR section",
                         "userdata2": "Size of section including header",
                      },
            0x1E0F0E: {    "devdesc": "Device write did not return expected size",
                          "moduleid": "SECUREBOOT::MOD_SECURE_GET_ALL_SEC_REGS",
                        "reasoncode": "SECUREBOOT::RC_DEVICE_WRITE_ERR",
                         "userdata1": "Actual size written",
                         "userdata2": "Expected size written",
                      },
            0x27060E: {    "devdesc": "SPI controller path target is null.",
                          "moduleid": "TPMDD_GETSPICONTROLLERTARGET",
                        "reasoncode": "TPM_TARGET_NULL",
                         "userdata1": "HUID of target",
                         "userdata2": "Compressed Entity Path",
                      },
            0x27120E: {    "devdesc": "SPI controller entity path doesn't exist.",
                          "moduleid": "TPMDD_GETSPICONTROLLERTARGET",
                        "reasoncode": "TPM_SPI_CONTROLLER_PATH_ERROR",
                         "userdata1": "HUID of target",
                         "userdata2": "Compressed Entity Path",
                      },
            0x283D0E: {    "devdesc": "Unable to inform OPAL of SBE failure",
                          "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                        "reasoncode": "SBEIO_RT_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "HUID of target",
                         "userdata2": "none",
                      },
            0x28530E: {    "devdesc": "PRD detected an error with the SBE and HB failed to recover",
                          "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                        "reasoncode": "SBEIO_NO_RECOVERY_ACTION",
                         "userdata1": "Huid of processor",
                         "userdata2": "Unused",
                      },
            0x28540E: {    "devdesc": "We expected an error log to be returned from                           p10_extract_rc but there wasn't one",
                          "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                        "reasoncode": "SBEIO_EXTRACT_RC_ERROR",
                         "userdata1": "Huid of processor",
                         "userdata2": "Return action from extract_rc",
                      },
            0x2BA20E: {    "devdesc": "Command failure reading TPM capability.",
                          "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                        "reasoncode": "RC_TPM_GETCAP_FAIL",
                         "userdata1": "responseCode",
                         "userdata2": "0",
                      },
            0x2BA30E: {    "devdesc": "Command failure reading TPM NV indexes.",
                          "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                        "reasoncode": "RC_TPM_GETCAP_FW_INVALID_RESP",
                         "userdata1": "capability",
                         "userdata2": "0",
                      },
            0x2BB50E: {    "devdesc": "Command failure reading TPM NV indexes. TPM is likely provisioned incorrectly.",
                          "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                        "reasoncode": "RC_TPM_NVINDEX_VALIDATE_FAIL",
                         "userdata1": "foundRSAEKCert",
                         "userdata2": "foundECCEKCert",
                      },
            0x900B0E: {    "devdesc": "memory alloc failed in calloc",
                          "moduleid": "HDAT::MOD_IOHUB_BUILD_DAUGHTER",
                        "reasoncode": "HDAT::RC_MEM_ALLOC_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x3130F: {    "devdesc": "Disabling special wakeup when not enabled.",
                          "moduleid": "SCOM_CALL_WAKEUP_HWP",
                        "reasoncode": "SCOM_SPCWKUP_COUNT_ERR",
                         "userdata1": "Target HUID",
                         "userdata2": "Wakeup Enable",
                      },
            0x31E0F: {    "devdesc": "Unexpectedly forcing wakeup off when the counter is non-zero, implies a bug in the code flow.",
                          "moduleid": "SCOM_CALL_WAKEUP_HWP",
                        "reasoncode": "SCOM_UNEXPECTED_FORCE_WAKEUP",
                         "userdata1": "Target HUID",
                         "userdata2": "Wakeup Enable",
                      },
            0x60C0F: {    "devdesc": "PNOR::validateMagic> Fail verifying FFS Magic Number in Header on Master",
                          "moduleid": "PNOR::MOD_PNORVALID_MAGIC",
                        "reasoncode": "PNOR::RC_PARTITION_TABLE_INVALID",
                         "userdata1": "Magic Number read",
                         "userdata2": "<unused>",
                      },
            0x7020F: {    "devdesc": "Invalid I2C device type",
                          "moduleid": "I2C::FAPI_I2C_PERFORM_OP",
                        "reasoncode": "I2C::I2C_INVALID_OP_TYPE",
                         "userdata1": "OP type",
                         "userdata2": "HUID of target",
                      },
            0x7130F: {    "devdesc": "Invalid I2C master path",
                          "moduleid": "I2C::FAPI_I2C_PERFORM_OP",
                        "reasoncode": "I2C::INVALID_MASTER_TARGET",
                         "userdata1": "HUID of target with FAPI_I2C_CONTROL_INFO",
                         "userdata2": "",
                      },
            0xB1A0F: {    "devdesc": "Invalid message type requested through the attribute resource provider's attribute synchronization sync daemon.",
                          "moduleid": "TARG_ATTR_SYNC_TASK",
                        "reasoncode": "TARG_RC_UNSUPPORTED_ATTR_SYNC_MSG",
                         "userdata1": "Return code",
                         "userdata2": "Message type",
                      },
            0xB1B0F: {    "devdesc": "Shutdown just occurred so the mailbox service is down. Messages can not be handled at this time.",
                          "moduleid": "TARG_ATTR_SYNC_TASK",
                        "reasoncode": "TARG_RC_ATTR_SYNC_SERVICE_DOWN",
                         "userdata1": "Return code",
                         "userdata2": "Message type",
                      },
            0xE140F: {    "devdesc": "Attempting to cache empty buffer in EEACHE",
                          "moduleid": "EEPROM_GENERIC_CACHE",
                        "reasoncode": "EEPROM_INVALID_LENGTH",
                         "userdata1": "Target HUID",
                         "userdata2": "1 if target is present, 0 if not",
                      },
            0xF090F: {    "devdesc": "Error unmasking interrupt source",
                          "moduleid": "INTR::MOD_INTRRP_UNMASKINTERRUPT",
                        "reasoncode": "INTR::RC_XIVE_ESB_WRONG_STATE",
                         "userdata1": "Huid of processor",
                         "userdata2": "Interrupt Source Number",
                      },
            0x100D0F: {    "devdesc": "TOD master drawer not found",
                          "moduleid": "TOD_TOPOLOGY_CREATE",
                        "reasoncode": "TOD_CREATION_ERR",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "",
                      },
            0x160F0F: {    "devdesc": "PSI Bridge device Map failed",
                          "moduleid": "Util::UTIL_TCE_UNMAP_PSIHB",
                        "reasoncode": "Util::UTIL_TCE_DEV_UNMAP_FAIL",
                         "userdata1": "Address to be unmapped",
                         "userdata2": "Return Code of mmio_dev_unmap",
                      },
            0x1A310F: {    "devdesc": "No space left for fake header injection",
                          "moduleid": "RUNTIME::MOD_PREVERLIDMGR_LOAD_IMAGE",
                        "reasoncode": "RUNTIME::RC_PREVER_INVALID_SIZE",
                         "userdata1": "Size of section including space for header",
                         "userdata2": "Size of header",
                      },
            0x1E120F: {    "devdesc": "Hostboot Base Image Header not valid",
                          "moduleid": "SECUREBOOT::MOD_SECURE_LOAD_HEADER",
                        "reasoncode": "SECUREBOOT::RC_INVALID_BASE_HEADER",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x28060F: {    "devdesc": "Caller requested PSU quiesce against an unassigned target or a target that is not a processor.",
                          "moduleid": "SBEIO_SEND_PSU_QUIESCE_SBE",
                        "reasoncode": "SBEIO_PSU_INVALID_TARGET",
                         "userdata1": "Target HUID (0, if invalid pointer)",
                         "userdata2": "Target type (TYPE_NA, if invalid pointer)",
                      },
            0x2BB10F: {    "devdesc": "msg_sendrecv() failed trying to send flush message to TPM daemon",
                          "moduleid": "MOD_FLUSH_TPM_QUEUE",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "",
                      },
            0x35120F: {    "devdesc": "Encountered error setting the energy source policy Make sure the connection between energy source and NVDIMM is intact",
                          "moduleid": "NVDIMM_SET_ES",
                        "reasoncode": "NVDIMM_SET_ES_ERROR",
                         "userdata1": "Related ops (0xff = NA)",
                         "userdata2": "Target Huid",
                      },
            0x90050F: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_IOHUB_LOAD_DATA",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x70A10: {    "devdesc": "FAPI_I2C_CONTROL_INFO attribute was not found",
                          "moduleid": "I2C::READ_I2C_ATTRIBUTES",
                        "reasoncode": "I2C::I2C_ATTRIBUTE_NOT_FOUND",
                         "userdata1": "HUID of target",
                         "userdata2": "",
                      },
            0xB0510: {    "devdesc": "Failed to either send/(receive) the requested message to/from the attribute resource provider OR the provider failed executing the message request.",
                          "moduleid": "TARG_SEND_ATTR_SYNC_MSG",
                        "reasoncode": "TARG_RC_ATTR_MSG_FAIL",
                         "userdata1": "Message type",
                         "userdata2": "API return code (from msg_send or msg_sendrecv; 0=N/A)",
                      },
            0xE1510: {    "devdesc": "flushToPnor mm_remove_pages FLUSH failed",
                          "moduleid": "EEPROM_FLUSH_TO_PNOR",
                        "reasoncode": "EEPROM_FAILED_TO_FLUSH_PAGE",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x100D10: {    "devdesc": "TOD drawer has one or more disconnected procs",
                          "moduleid": "TOD_WIRE_PROCS",
                        "reasoncode": "TOD_CREATION_ERR",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "TOD drawer id",
                      },
            0x101110: {    "devdesc": "TOD drawer not specified",
                          "moduleid": "TOD_WIRE_PROCS",
                        "reasoncode": "TOD_INVALID_PARAM",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "",
                      },
            0x161610: {    "devdesc": "Error calling mm_block_map for Mcl Mgr",
                          "moduleid": "Util::UTIL_MCL_INIT_MEM",
                        "reasoncode": "Util::UTIL_MM_BLOCK_MAP_FAILED",
                         "userdata1": "Address being allocated",
                         "userdata2": "Size of block allocation",
                      },
            0x171610: {    "devdesc": "activate_threads> Could not find a target for the master core",
                          "moduleid": "ISTEP::MOD_THREAD_ACTIVATE",
                        "reasoncode": "ISTEP::RC_NO_MASTER_CORE_TARGET",
                         "userdata1": "Master cpu id",
                         "userdata2": "Master processor chip huid",
                      },
            0x171F10: {    "devdesc": "activate_threads> Could not find a target for the master-fused core",
                          "moduleid": "ISTEP::MOD_THREAD_ACTIVATE",
                        "reasoncode": "ISTEP::RC_NO_FUSED_CORE_TARGET",
                         "userdata1": "Master-fused core id",
                         "userdata2": "Master-fused processor chip huid",
                      },
            0x1D3210: {    "devdesc": "writePNOR mm_remove_pages FLUSH failed",
                          "moduleid": "VPD_WRITE_PNOR",
                        "reasoncode": "VPD_REMOVE_PAGES_FAIL",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x1E1310: {    "devdesc": "Error parsing secure header; ECID count field of specified type was non-zero.  Reinstall boot firmware.",
                          "moduleid": "SECUREBOOT::MOD_SECURE_VALIDATE_ECID_COUNT",
                        "reasoncode": "SECUREBOOT::RC_INVALID_ECID_COUNT",
                         "userdata1": "ECID count field type",
                         "userdata2": "Actual ECID count",
                      },
            0x231010: {    "devdesc": "Setting of LED value did not appear to work",
                          "moduleid": "GPIO_PCA9551_SET_LED",
                        "reasoncode": "GPIO_PCA9551_DATA_MISMATCH",
                         "userdata1": "HUID of Master Processor Target",
                         "userdata2": "Input LED to Set",
                      },
            0x266310: {    "devdesc": "Invalid OCC error log data",
                          "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                        "reasoncode": "HTMGT_RC_INVALID_OCC_ELOG",
                         "userdata1": "instance",
                         "userdata2": "error source",
                      },
            0x267D10: {    "devdesc": "Bad FRU data received in OCC error log",
                          "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                        "reasoncode": "HTMGT_RC_BAD_FRU_CALLOUTS",
                         "userdata1": "OCC elog id",
                         "userdata2": "Bad callout index",
                      },
            0x267F10: {    "devdesc": "No FRU callouts found for non-info OCC Error",
                          "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                        "reasoncode": "HTMGT_RC_MISMATCHING_SEVERITY",
                         "userdata1": "OCC elog id",
                         "userdata2": "OCC severity",
                      },
            0x286310: {    "devdesc": "startDeadmanLoop was called twice in a row",
                          "moduleid": "SBEIO_DEAD_MAN_TIMER",
                        "reasoncode": "SBEIO_START_DMT_CALLED_TWICE",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x2BAC10: {    "devdesc": "TPM log buffer init failure.",
                          "moduleid": "MOD_TPMLOGMGR_INITIALIZE",
                        "reasoncode": "RC_TPMLOGMGR_INIT_FAIL",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x332B10: {    "devdesc": "Image header magic value mismatch",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_WOF_IMAGE_MAGIC_MISMATCH",
                         "userdata1": "Image header magic value",
                         "userdata2": "Expected magic value",
                      },
            0x332C10: {    "devdesc": "WOF tables header magic value mismatch",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_WOF_TABLES_MAGIC_MISMATCH",
                         "userdata1": "WOF tables header magic value",
                         "userdata2": "Expected magic value",
                      },
            0x332D10: {    "devdesc": "No WOF table match found",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_WOF_TABLE_NOT_FOUND",
                         "userdata1": "Number of cores",
                         "userdata2": "WOF Power Mode (1=Nominal, 2=Turbo)",
                      },
            0x332E10: {    "devdesc": "Image header version not supported",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_WOF_IMAGE_VERSION_MISMATCH",
                         "userdata1": "Image header version",
                         "userdata2": "Supported header version",
                      },
            0x332F10: {    "devdesc": "WOF tables header version not supported",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_WOF_TABLES_VERSION_MISMATCH",
                         "userdata1": "WOF tables header version",
                         "userdata2": "Max supported header version",
                      },
            0x333010: {    "devdesc": "Error calling mm_alloc_block for WOFDATA",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_MM_ALLOC_BLOCK_FAILED",
                         "userdata1": "Address being allocated",
                         "userdata2": "Size of block allocation",
                      },
            0x333110: {    "devdesc": "Error calling mm_set_permission for WOFDATA",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_MM_SET_PERMISSION_FAILED",
                         "userdata1": "Address being changed",
                         "userdata2": "Size of change",
                      },
            0x333210: {    "devdesc": "Error calling mm_remove_pages for WOFDATA",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_MM_REMOVE_PAGES_FAILED",
                         "userdata1": "Address being removed",
                         "userdata2": "Size of removal",
                      },
            0x333310: {    "devdesc": "Error calling mm_set_permission for WOFDATA",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                        "reasoncode": "fapi2::RC_MM_SET_PERMISSION2_FAILED",
                         "userdata1": "Address being changed",
                         "userdata2": "Size of change",
                      },
            0x351810: {    "devdesc": "Encountered error arming the catastrophic save trigger on NVDIMM. Make sure an energy source is connected to the NVDIMM and the ES policy is set properly",
                          "moduleid": "NVDIMM_SET_ARM",
                        "reasoncode": "NVDIMM_ARM_FAILED",
                         "userdata1": "Related ops (0xff = NA)",
                         "userdata2": "Target Huid",
                      },
            0x30111: {    "devdesc": "The scom address provided was invalid, check to see if the address matches a target in the scomdef file.",
                          "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                        "reasoncode": "SCOM::SCOM_INVALID_ADDR",
                         "userdata1": "Address",
                         "userdata2": "Target's Type",
                      },
            0x30A11: {    "devdesc": "Scom Translation did not modify the address",
                          "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                        "reasoncode": "SCOM::SCOM_INVALID_TRANSLATION",
                         "userdata1": "Original Address",
                         "userdata2": "l_chipUnit",
                      },
            0x30C11: {    "devdesc": "The scom target did not match the provided address",
                          "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                        "reasoncode": "SCOM::SCOM_TARGET_ADDR_MISMATCH",
                         "userdata1": "Address",
                         "userdata2": "Target's Type",
                      },
            0x30D11: {    "devdesc": "EKB code has detected and error in the scom",
                          "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                        "reasoncode": "SCOM::SCOM_ISCHIPUNITSCOM_INVALID",
                         "userdata1": "Input address",
                         "userdata2": "Target huid",
                      },
            0x32011: {    "devdesc": "Scom Translate not supported for this type",
                          "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                        "reasoncode": "SCOM::SCOM_P10_TRANS_INVALID_TYPE",
                         "userdata1": "Address",
                         "userdata2": "Target's Type",
                      },
            0x71411: {    "devdesc": "I2C mux path target is null",
                          "moduleid": "I2C_ACCESS_MUX",
                        "reasoncode": "I2C_MUX_TARGET_NOT_FOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x71511: {    "devdesc": "I2C mux path target is not functional",
                          "moduleid": "I2C_ACCESS_MUX",
                        "reasoncode": "I2C_MUX_TARGET_NON_FUNCTIONAL",
                         "userdata1": "I2C MUX Target Huid",
                         "userdata2": "",
                      },
            0xB1C11: {    "devdesc": "Can't find targeting target for given runtime target ID",
                          "moduleid": "TARGETING::TARG_TRANSLATE_TARGET",
                        "reasoncode": "TARGETING::TARG_RC_TARGET_TYPE_NOT_SUPPORTED",
                         "userdata1": "Runtime target ID",
                         "userdata2": "",
                      },
            0xE0E11: {    "devdesc": "New part has likely been loaded into the system.",
                          "moduleid": "EEPROM_FIND_EEPROM_HEADER_IN_CACHE",
                        "reasoncode": "EEPROM_NEW_DEVICE_DETECTED",
                         "userdata1": "Old Size of Eeprom",
                         "userdata2": "New Size of Eeprom",
                      },
            0x100D11: {    "devdesc": "TOD drawer couldn't be wired",
                          "moduleid": "TOD_WIRE_DRAWERS",
                        "reasoncode": "TOD_CREATION_ERR",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "TOD drawer id",
                      },
            0x101111: {    "devdesc": "TOD drawer not specified",
                          "moduleid": "TOD_WIRE_DRAWERS",
                        "reasoncode": "TOD_INVALID_PARAM",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "",
                      },
            0x101211: {    "devdesc": "MDMT could not be found",
                          "moduleid": "TOD_WIRE_DRAWERS",
                        "reasoncode": "TOD_MASTER_TARGET_NOT_FOUND",
                         "userdata1": "Topology type : primary/secondary",
                         "userdata2": "",
                      },
            0x161711: {    "devdesc": "Error calling mm_block_unmap for Mcl Mgr",
                          "moduleid": "Util::UTIL_MCL_REL_MEM",
                        "reasoncode": "Util::UTIL_MM_BLOCK_UNMAP_FAILED",
                         "userdata1": "Address being removed",
                         "userdata2": "rc from mm_block_unmap",
                      },
            0x173811: {    "devdesc": "Failed to boot a slave SBE",
                          "moduleid": "MOD_CHECK_SECONDARY_SBE_SEEPROM_COMPLETE",
                        "reasoncode": "RC_FAILED_TO_BOOT_SBE",
                         "userdata1": "HUID of proc that failed to boot its SBE",
                         "userdata2": "Unused",
                      },
            0x2BAA11: {    "devdesc": "TPM log buffer add failure.",
                          "moduleid": "MOD_TPMLOGMGR_ADDEVENT",
                        "reasoncode": "RC_TPMLOGMGR_ADDEVENT_FAIL",
                         "userdata1": "Max log size",
                         "userdata2": "Log buffer NULL",
                      },
            0x2BAB11: {    "devdesc": "log buffer marshal failure.",
                          "moduleid": "MOD_TPMLOGMGR_ADDEVENT",
                        "reasoncode": "RC_TPMLOGMGR_ADDEVENTMARSH_FAIL",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x900D11: {    "devdesc": "Device read failed",
                          "moduleid": "HDAT::MOD_UTIL_VPD",
                        "reasoncode": "HDAT::RC_DEV_READ_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x71612: {    "devdesc": "ddimmPresenceDetect> Invalid data length (!= 1 bytes)",
                          "moduleid": "I2C::I2C_GENERIC_PRES_DETECT",
                        "reasoncode": "I2C::I2C_INVALID_LENGTH",
                         "userdata1": "Data Length",
                         "userdata2": "HUID of target being detected",
                      },
            0x71712: {    "devdesc": "ocmbPresenceDetect> Master i2c path returned nullptr",
                          "moduleid": "I2C::I2C_GENERIC_PRES_DETECT",
                        "reasoncode": "I2C::I2C_NULL_MASTER_TARGET",
                         "userdata1": "HUID of target being detected",
                         "userdata2": "Unused",
                      },
            0x93012: {    "devdesc": "Extra bad bits set for DIMM",
                          "moduleid": "MOD_FAPI2_BAD_DQ_BITMAP",
                        "reasoncode": "RC_BAD_DQ_MFG_MODE_BITS",
                         "userdata1": "DIMM Target HUID",
                         "userdata2": "<unused>",
                      },
            0xC2412: {    "devdesc": "SBE and HB targets configuration do not match.",
                          "moduleid": "MOD_DECONFIG_TARGETS_FROM_GARD_AND_VPD",
                        "reasoncode": "RC_HB_SBE_DECONFIG_MISMATCH",
                         "userdata1": "Target HUID",
                         "userdata2": "SBE target functional? (0: no, 1: yes)",
                      },
            0xF0C12: {    "devdesc": "Error encountered sending coalesce message to INTRP",
                          "moduleid": "INTR::MOD_INTRRP_XIVE_SENDEOI",
                        "reasoncode": "INTR::RC_MESSAGE_SEND_ERROR",
                         "userdata1": "RC from msg_send command",
                         "userdata2": "",
                      },
            0x101312: {    "devdesc": "No MDMT present on the system",
                          "moduleid": "TOD_INIT_HWP",
                        "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                         "userdata1": "EMOD_TOD_INIT_HWP",
                         "userdata2": "PRIMARY topology type",
                      },
            0x160612: {    "devdesc": "Error processing component for Mcl Mgr",
                          "moduleid": "Util::UTIL_MCL_PROCESS_COMP",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                         "userdata1": "Total Size of Component",
                         "userdata2": "Max size of memory region",
                      },
            0x161812: {    "devdesc": "Error processing component for Mcl Mgr",
                          "moduleid": "Util::UTIL_MCL_PROCESS_COMP",
                        "reasoncode": "Util::UTIL_MCL_SIZE_MISMATCH",
                         "userdata1": "Total Size of Component",
                         "userdata2": "Size read by FSP",
                      },
            0x1A1A12: {    "devdesc": "The targeting type of the input targeting target is not supported by runtime code",
                          "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                        "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                         "userdata1": "Targeting target's HUID",
                         "userdata2": "Targeting target's type",
                      },
            0x1A1B12: {    "devdesc": "No processor targeting target was found for the given targeting target",
                          "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                        "reasoncode": "RUNTIME::RT_NO_PROC_TARGET",
                         "userdata1": "Input targeting target's HUID",
                         "userdata2": "",
                      },
            0x1A4912: {    "devdesc": "No associated OMI targeting target(s) found for given OCMB targeting target",
                          "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                        "reasoncode": "RUNTIME::RT_NO_OMI_TARGET_FOUND",
                         "userdata1": "OCMB targeting target's HUID",
                         "userdata2": "",
                      },
            0x1D3312: {    "devdesc": "Unexpected target type",
                          "moduleid": "VPD_GET_PN_AND_SN",
                        "reasoncode": "VPD_UNEXPECTED_TARGET_TYPE",
                         "userdata1": "Target HUID",
                         "userdata2": "<UNUSED>",
                      },
            0x1D3f12: {    "devdesc": "ocmbPresenceDetect> Invalid master i2c path",
                          "moduleid": "I2C::I2C_GENERIC_PRES_DETECT",
                        "reasoncode": "VPD::VPD_INVALID_MASTER_I2C_PATH",
                         "userdata1": "HUID of target being detected",
                         "userdata2": "Unused",
                      },
            0x1E1512: {    "devdesc": "Planar jumper configuration",
                          "moduleid": "SECUREBOOT::MOD_SECURE_LOG_PLAT_SECURITY_CONFIG",
                        "reasoncode": "SECUREBOOT::RC_SECURE_LOG_PLAT_SECURITY_CONFIG",
                         "userdata1": "Minimum FW Secure Version",
                         "userdata2": "",
                      },
            0x2BB012: {    "devdesc": "TPM log header entry is missing.",
                          "moduleid": "MOD_TPMLOGMGR_INITIALIZEEXISTLOG",
                        "reasoncode": "RC_TPMLOGMGR_LOGWALKFAIL",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x71D13: {    "devdesc": "A bad PEC byte was found during the device operation.",
                          "moduleid": "I2C_BAD_PEC_BYTE_ERROR",
                        "reasoncode": "I2C_BAD_PEC_BYTE",
                         "userdata1": "Expected PEC byte",
                         "userdata2": "Actual PEC byte",
                      },
            0xF0D13: {    "devdesc": "Error encountered routing IPC message",
                          "moduleid": "INTR::MOD_INTRRP_IPC",
                        "reasoncode": "INTR::RC_IPC_DATA_INVALID",
                         "userdata1": "IPC Data Area MSG Queue ID",
                         "userdata2": "PIR",
                      },
            0x100713: {    "devdesc": "Error: Initialization of chip TOD logic cannot be done when its already in the running state",
                          "moduleid": "TOD_INIT_ALREADY_RUNNING",
                        "reasoncode": "TOD_INVALID_ACTION",
                         "userdata1": "EMOD_TOD_INIT",
                         "userdata2": "ChipTOD logic HW state, 1=running, zero otherwise",
                      },
            0x1A1A13: {    "devdesc": "Targeting target's type not supported by runtime code",
                          "moduleid": "RUNTIME::MOD_CUST_CONF_HBRT_HYP_IDS",
                        "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                         "userdata1": "Target's HUID",
                         "userdata2": "Target's targeting type",
                      },
            0x1D3e13: {    "devdesc": "getVpdLocation> VPD_REC_NUM is invalid, bad MRW",
                          "moduleid": "VPD_GET_VPD_LOCATION",
                        "reasoncode": "VPD_BAD_REC_NUM",
                         "userdata1": "Target HUID",
                         "userdata2": "VPD_REC_NUM",
                      },
            0x221813: {    "devdesc": "Bad RC from p9_xip_delete",
                          "moduleid": "SBE_APPEND_HBBL",
                        "reasoncode": "ERROR_FROM_XIP_DELETE",
                         "userdata1": "rc from p9_xip_delete",
                         "userdata2": "<unused>",
                      },
            0x221913: {    "devdesc": "Bad RC from p9_xip_get_section",
                          "moduleid": "SBE_APPEND_HBBL",
                        "reasoncode": "ERROR_FROM_XIP_FIND",
                         "userdata1": "rc from p9_xip_get_section",
                         "userdata2": "<unused>",
                      },
            0x221F13: {    "devdesc": "Bad RC from p9_xip_delete",
                          "moduleid": "SBE_APPEND_HBBL",
                        "reasoncode": "ERROR_FROM_XIP_DELETE_RINGS",
                         "userdata1": "rc from p9_xip_delete",
                         "userdata2": "<unused>",
                      },
            0x222013: {    "devdesc": "Bad RC from p9_xip_get_section",
                          "moduleid": "SBE_APPEND_HBBL",
                        "reasoncode": "ERROR_FROM_XIP_FIND_RINGS",
                         "userdata1": "rc from p9_xip_get_section",
                         "userdata2": "<unused>",
                      },
            0x333913: {    "devdesc": "Detecting more than 1 parent proc targets",
                          "moduleid": "fapi2::MOD_FAPI2_GET_CHIP_CFAM_TARGET",
                        "reasoncode": "fapi2::RC_INVALID_PARENT_TARGET_FOUND",
                         "userdata1": "Number of parent proc chips found",
                         "userdata2": "HUID of input target",
                      },
            0x351A13: {    "devdesc": "NVDIMM failed to restore data. This is likely due to failure entering self-refresh and/or restore timeout (Controller error)",
                          "moduleid": "NVDIMM_RESTORE",
                        "reasoncode": "NVDIMM_RESTORE_FAILED",
                         "userdata1": "Target Huid",
                         "userdata2": "<UNUSED>",
                      },
            0x901013: {    "devdesc": "SPD read fail",
                          "moduleid": "HDAT::MOD_UTIL_SPD_READ_FUNC",
                        "reasoncode": "HDAT::RC_SPD_READ_FAIL",
                         "userdata1": "spd keyword",
                         "userdata2": "",
                      },
            0xF0314: {    "devdesc": "Interrupt resource provider not initialized yet.",
                          "moduleid": "INTR::MOD_INTR_DUMP",
                        "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                         "userdata1": "MSG_INTR_DUMP",
                         "userdata2": "0",
                      },
            0xF0C14: {    "devdesc": "Error encountered sending print intr info message to INTRP",
                          "moduleid": "INTR::MOD_INTR_DUMP",
                        "reasoncode": "INTR::RC_MESSAGE_SEND_ERROR",
                         "userdata1": "RC from msg_send command",
                         "userdata2": "",
                      },
            0x100714: {    "devdesc": "Error: TOD HW logic is not running, only use case of resetBackup is when TOD is already running",
                          "moduleid": "TOD::TOD_RESET_BACKUP",
                        "reasoncode": "TOD::TOD_INVALID_ACTION",
                         "userdata1": "ChipTOD logic HW state, 1 means running, zero otherwise",
                         "userdata2": "",
                      },
            0x161A14: {    "devdesc": "Unable to find frequency list",
                          "moduleid": "UTIL_MOD_GET_OBUS_PLL_BUCKET",
                        "reasoncode": "UTIL_ERC_NO_FREQ_LIST",
                         "userdata1": "HB Target HUID",
                         "userdata2": "Chip model",
                      },
            0x161B14: {    "devdesc": "No matching frequency for PLL bucket",
                          "moduleid": "UTIL_MOD_GET_OBUS_PLL_BUCKET",
                        "reasoncode": "UTIL_ERC_NO_MATCHING_FREQ",
                         "userdata1": "HB Target HUID",
                         "userdata2": "Input frequency",
                      },
            0x171C14: {    "devdesc": "Timeout waiting for OCC checkpoint",
                          "moduleid": "ISTEP::MOD_PM_VERIFY_OCC_CHKPT",
                        "reasoncode": "ISTEP::RC_PM_OCC_CHKPT_TIMEOUT",
                         "userdata1": "HUID",
                         "userdata2": "Checkpoint value",
                      },
            0x1E1714: {    "devdesc": "Could not allocate any requested SMF memory. The system may not have enough available memory.",
                          "moduleid": "SECUREBOOT::MOD_SMF_SPLIT_SMF_MEM",
                        "reasoncode": "SECUREBOOT::RC_COULD_NOT_ALLOCATE_SMF_MEM",
                         "userdata1": "Requested amount of SMF memory",
                         "userdata2": "Total amount of mem available on the system",
                      },
            0x1E1814: {    "devdesc": "The amount of SMF memory alocated does not match the requested SMF memory amount. A rounding error may have occurred or there is not enough of memory on the system.",
                          "moduleid": "SECUREBOOT::MOD_SMF_SPLIT_SMF_MEM",
                        "reasoncode": "SECUREBOOT::RC_ALLOCATED_NE_REQUESTED",
                         "userdata1": "Requested amount of SMF memory",
                         "userdata2": "Actual allocated amount of SMF memory",
                      },
            0x220F14: {    "devdesc": "Error Associated with Updating this Target",
                          "moduleid": "SBE_GET_HW_KEY_HASH",
                        "reasoncode": "SBE_ECC_FAIL",
                         "userdata1": "Target HUID",
                         "userdata2": "Seeprom Side",
                      },
            0x221914: {    "devdesc": "Error Associated with Target's SBE Seeprom",
                          "moduleid": "SBE_GET_HW_KEY_HASH",
                        "reasoncode": "ERROR_FROM_XIP_FIND",
                         "userdata1": "Target HUID",
                         "userdata2": "Seeprom Side",
                      },
            0x2BB414: {    "devdesc": "Failed to set SEEPROM lock and/or TPM deconfig protection for this processor, so we cannot guarrantee platform secuirty for this processor",
                          "moduleid": "TRUSTEDBOOT::MOD_TPM_MARK_FAILED",
                        "reasoncode": "TRUSTEDBOOT::RC_UPDATE_SECURITY_CTRL_HWP_FAIL",
                         "userdata1": "Processor Target",
                         "userdata2": "TPM Target",
                      },
            0x351614: {    "devdesc": "NVDIMM OpenPage timed out, likely due to controller error",
                          "moduleid": "NVDIMM_OPEN_PAGE",
                        "reasoncode": "NVDIMM_OPEN_PAGE_TIMEOUT",
                         "userdata1": "Related ops (0xff = NA)",
                         "userdata2": "Target Huid",
                      },
            0x901114: {    "devdesc": "Exceeded limit of number of mainstore VPD In Memory Trace array entries",
                          "moduleid": "MOD_ADD_IMT_ADDR_RANGE",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current number of array entries",
                         "userdata2": "maximum number of array entries",
                      },
            0x60215: {    "devdesc": "PnorSfcDD::eraseFlash> Address not on erase boundary",
                          "moduleid": "PNOR::MOD_PNORDD_ERASEFLASH",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "Flash Address",
                         "userdata2": "Nearest Erase Boundary",
                      },
            0x92615: {    "devdesc": "The hwsv found an error while processing the message so it sent an error message back to indicate to HostBoot to stop the IPL. Userdata1 will have the error PLID from hwsv's errorlog",
                          "moduleid": "fapi::MOD_VDDR_PROC_MSG",
                        "reasoncode": "fapi::RC_VDDR_ERROR_MSG",
                         "userdata1": "error PLID from hwsv",
                         "userdata2": "0",
                      },
            0x92815: {    "devdesc": "HB got an incorrect type message. HWSV did not populate the message correctly or mbox corrupted the message",
                          "moduleid": "fapi::MOD_VDDR_PROC_MSG",
                        "reasoncode": "fapi::RC_INCORRECT_MSG_TYPE",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0xF0E15: {    "devdesc": "Attempted to unregsister a source that is not registered",
                          "moduleid": "INTR::MOD_INTRRP_UNREGISTERINTERRUPT",
                        "reasoncode": "INTR::RC_SOURCE_NOT_REGISTERED",
                         "userdata1": "LSI Interrupt Source to Unregister",
                         "userdata2": "Number of unregistered LSI sources",
                      },
            0x101315: {    "devdesc": "Error: Could not find MDMT on active topology even though TOD HW logic is running",
                          "moduleid": "TOD_MDMT_TOPOLOGY",
                        "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                         "userdata1": "EMOD_TOD_SET_ACTIVE_MDMT",
                         "userdata2": "Topology type on which MDMT was searched",
                      },
            0x1A1D15: {    "devdesc": "PM load complex unknown mode",
                          "moduleid": "MOD_PM_RT_LOAD_PM_COMPLEX",
                        "reasoncode": "RC_PM_RT_UNKNOWN_MODE",
                         "userdata1": "HBRT PM Mode",
                         "userdata2": "HUID",
                      },
            0x2BB115: {    "devdesc": "msg_sendrecv() failed",
                          "moduleid": "MOD_INIT_BACKUP_TPM",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "",
                      },
            0x351715: {    "devdesc": "Encountered timeout while performing operation on NVDIMM Refer to userdata1 for which operation it timed out.",
                          "moduleid": "NVDIMM_POLL_STATUS",
                        "reasoncode": "NVDIMM_STATUS_TIMEOUT",
                         "userdata1": "Related ops (0xff = NA)",
                         "userdata2": "Target Huid",
                      },
            0x901115: {    "devdesc": "Exceeded limit of number of mainstore VPD In Memory Trace array entries",
                          "moduleid": "MOD_ADD_UE_ADDR_RANGE",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current number of array entries",
                         "userdata2": "maximum number of array entries",
                      },
            0x92516: {    "devdesc": "The hwsv returned a message where the extra data was null.  This should not happen so need to tell HostBoot to stop the ipl",
                          "moduleid": "fapi::MOD_VDDR_PROC_VDDR_MSG",
                        "reasoncode": "fapi::RC_VDDR_EMPTY_MSG",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x92716: {    "devdesc": "The hwsv returned a message where there was an error when the powr function was called. userdata1 contains the errorlog plid from hwsv generated by the powr function",
                          "moduleid": "fapi::MOD_VDDR_PROC_VDDR_MSG",
                        "reasoncode": "fapi::RC_VDDR_POWR_ERR",
                         "userdata1": "l_errPlid",
                         "userdata2": "0",
                      },
            0x161D16: {    "devdesc": "Could not find requested component ID in master container LID",
                          "moduleid": "Util::UTIL_MCL_PROCESS_SINGLE_COMP",
                        "reasoncode": "Util::UTIL_LIDMGR_INVAL_COMP",
                         "userdata1": "Component ID [truncated to 8 bytes]",
                         "userdata2": "",
                      },
            0x172916: {    "devdesc": "call_proc_exit_cache_contained: did not find minimum hardware to continue",
                          "moduleid": "ISTEP::MOD_PROC_EXIT_CACHE_CONTAINED",
                        "reasoncode": "ISTEP::RC_MIN_HW_CHECK_FAILED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x174716: {    "devdesc": "call_proc_exit_cache_contained: did not find valid memory configuration",
                          "moduleid": "ISTEP::MOD_PROC_EXIT_CACHE_CONTAINED",
                        "reasoncode": "ISTEP::RC_NO_VALID_MEM_CONFIG",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1A1E16: {    "devdesc": "HCODE scom update runtime interface not linked.",
                          "moduleid": "MOD_PM_RT_HCODE_UPDATE",
                        "reasoncode": "RC_PM_RT_INTERFACE_ERR",
                         "userdata1": "Target HUID",
                         "userdata2": "SCOM restore section",
                      },
            0x1A1F16: {    "devdesc": "HCODE SCOM update error",
                          "moduleid": "MOD_PM_RT_HCODE_UPDATE",
                        "reasoncode": "RC_PM_RT_HCODE_UPDATE_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "SCOM address",
                      },
            0x351916: {    "devdesc": "Encountered error erasing previously stored data image on NVDIMM. Likely due to timeout and/or controller error",
                          "moduleid": "NVDIMM_CHECK_ERASE",
                        "reasoncode": "NVDIMM_ERASE_FAILED",
                         "userdata1": "Related ops (0xff = NA)",
                         "userdata2": "Target Huid",
                      },
            0x901116: {    "devdesc": "Exceeded limit of number of mainstore VPD Reserved Hostboot array entries",
                          "moduleid": "MOD_ADD_RES_HB_ADDR_RANGE",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current number of array entries",
                         "userdata2": "maximum number of array entries",
                      },
            0x92817: {    "devdesc": "HB got an incorrect type message.  HB did not provide the correct message type in the istep. Userdata1 shows the message type passed in",
                          "moduleid": "fapi::MOD_VDDR_SEND_MSG",
                        "reasoncode": "fapi::RC_INCORRECT_MSG_TYPE",
                         "userdata1": "i_msgType",
                         "userdata2": "0",
                      },
            0x101517: {    "devdesc": "This TOD end point target on processor is not receiving signal from the OSC.",
                          "moduleid": "TOD_ENDPOINT_CALLOUT",
                        "reasoncode": "TOD_MASTER_PATH_ERROR",
                         "userdata1": "EMOD_CALLOUT_TOD_ENDPOINT",
                         "userdata2": "HUID of the TOD end point that is not receiving signal HUID of the OSC from which signal is not received",
                      },
            0x1A0517: {    "devdesc": "Error mapping a virtual memory map",
                          "moduleid": "RUNTIME::MOD_MAP_PHYS_ADDR",
                        "reasoncode": "RUNTIME::RC_CANNOT_MAP_MEMORY",
                         "userdata1": "Phys address we are trying to map",
                         "userdata2": "Size of memory we are trying to map",
                      },
            0x2BB717: {    "devdesc": "TPM testcase error. See the return code for details.",
                          "moduleid": "MOD_TEST_CMP_PRIMARY_AND_BACKUP_TPM",
                        "reasoncode": "RC_BACKUP_TPM_TEST_FAIL",
                         "userdata1": "return code",
                         "userdata2": "0",
                      },
            0x901117: {    "devdesc": "Exceeded limit of number of mainstore area array entries",
                          "moduleid": "MOD_ADD_MS_AREA_FRU",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current array entry count",
                         "userdata2": "maximum array entry count",
                      },
            0x161F18: {    "devdesc": "BMC returned a lid of size larger than the size of lid's destination",
                          "moduleid": "Util::UTIL_LIDMGR_GET_LID_BMC",
                        "reasoncode": "Util::UTIL_LIDMGR_LID_TOO_BIG",
                         "userdata1": "LID ID",
                         "userdata2": "Requested lid size",
                      },
            0x1A1C18: {    "devdesc": "Error unmapping a virtual memory map",
                          "moduleid": "RUNTIME::MOD_UNMAP_VIRT_ADDR",
                        "reasoncode": "RUNTIME::RC_UNMAP_FAIL",
                         "userdata1": "Virtual address we are trying to unmap",
                         "userdata2": "0",
                      },
            0x2BB118: {    "devdesc": "msg_sendrecv() failed",
                          "moduleid": "MOD_TPM_GETRANDOM",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msq_sendrecv()",
                         "userdata2": "TPM HUID if it's not nullptr",
                      },
            0x351B18: {    "devdesc": "Failed to read ready status or NVDIMM not ready for host access. (userdata1 != 0xA5)",
                          "moduleid": "NVDIMM_CHECK_READY",
                        "reasoncode": "NVDIMM_NOT_READY",
                         "userdata1": "Ret value from ready register",
                         "userdata2": "Target Huid",
                      },
            0x901218: {    "devdesc": "Attempted to add a RAM FRU for an invalid mainstore area",
                          "moduleid": "MOD_ADD_RAM_FRU",
                        "reasoncode": "RC_ERC_NO_PARENT",
                         "userdata1": "main store area id",
                         "userdata2": "current count of main store areas",
                      },
            0x100C19: {    "devdesc": "nullptr Target is supplied as an input",
                          "moduleid": "TOD_FUNCTIONAL_TARGET",
                        "reasoncode": "TOD_INVALID_TARGET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1A2119: {    "devdesc": "Found duplicate I2C link IDs in PCRD section of HDAT. System security cannot be guaranteed.",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_DUPLICATE_I2C_LINK_IDS",
                         "userdata1": "I2C Link ID",
                         "userdata2": "",
                      },
            0x1A2219: {    "devdesc": "An I2C device in the PCRD does not have a match in the MRW. Physical presence detection will not be available.",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_I2C_DEVICE_NOT_IN_MRW",
                         "userdata1": "I2C Link ID",
                         "userdata2": "",
                      },
            0x1A2419: {    "devdesc": "An I2C device in the PCRD has a duplicate match in the MRW. Physical presence detection will still be available.",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_I2C_DEVICE_DUPLICATE_IN_MRW",
                         "userdata1": "I2C Link ID",
                         "userdata2": "",
                      },
            0x1A2519: {    "devdesc": "An I2C device in the MRW has no match in the PCRD.",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_EXTRA_I2C_DEVICE_IN_MRW",
                         "userdata1": "[0:7] I2C engine",
                         "userdata2": "[8:15] I2C masterPort",
                      },
            0x1A2A19: {    "devdesc": "The TPM data hdat section doesn't have enough space",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_OUT_OF_SPACE",
                         "userdata1": "Size of hdat data struct",
                         "userdata2": "Max size of hdat data struct",
                      },
            0x1A2B19: {    "devdesc": "TPM data hdat struct format value doesn't match",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_ID_MISMATCH",
                         "userdata1": "hdat struct format value",
                         "userdata2": "Expected hdat struct format value",
                      },
            0x1A2C19: {    "devdesc": "TPM data hdat struct name eye catcher doesn't match",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_EYE_CATCH_MISMATCH",
                         "userdata1": "hdat struct name eye catcher",
                         "userdata2": "Expected hdat eye catch",
                      },
            0x1A2D19: {    "devdesc": "TPM does not have a processor",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_MISSING_PROC",
                         "userdata1": "Number of processors",
                         "userdata2": "0",
                      },
            0x1A2E19: {    "devdesc": "Bad PCRD section version",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_BAD_VERSION",
                         "userdata1": "hdat version",
                         "userdata2": "Expected support version",
                      },
            0x1A2F19: {    "devdesc": "HDAT PCRD reported more than the max number of i2c devices",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_BAD_NUM_I2C",
                         "userdata1": "hdat array count",
                         "userdata2": "max number of i2c devices",
                      },
            0x1A3A19: {    "devdesc": "Failed to convert virtual address to physical address",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_VIRT_TO_PHYS_ERR",
                         "userdata1": "Requested virtual address to convert",
                         "userdata2": "",
                      },
            0x1A3B19: {    "devdesc": "Failed to map physical memory to virtual memory",
                          "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                        "reasoncode": "RUNTIME::RC_TPM_HDAT_MAP_BLOCK_ERR",
                         "userdata1": "Aligned physical address to map",
                         "userdata2": "Aligned size or region to map",
                      },
            0x2BB819: {    "devdesc": "Caller attempted to get a random number from a TPM using an invalid TPM target.",
                          "moduleid": "MOD_VALIDATE_TPM_HANDLE",
                        "reasoncode": "RC_INVALID_TPM_HANDLE",
                         "userdata1": "TPM HUID if it's not nullptr",
                         "userdata2": "",
                      },
            0x2BB919: {    "devdesc": "Call attempted to get a random number from a TPM that was not functional",
                          "moduleid": "MOD_VALIDATE_TPM_HANDLE",
                        "reasoncode": "RC_NON_FUNCTIONAL_TPM_HANDLE",
                         "userdata1": "TPM HUID if it's not nullptr",
                         "userdata2": "",
                      },
            0x351C19: {    "devdesc": "Unable to inform PHYP of NVDIMM protection",
                          "moduleid": "NOTIFY_NVDIMM_PROTECTION_CHG",
                        "reasoncode": "NVDIMM_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "HUID of processor target",
                         "userdata2": "Requested protection state",
                      },
            0x901119: {    "devdesc": "Failed trying to add another entry to a mainstore area address range array",
                          "moduleid": "MOD_ADD_ADDR_RANGE",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current number of array entries",
                         "userdata2": "maximum number of array entries",
                      },
            0x90111a: {    "devdesc": "Failed trying to add another entry to a mainstore area RAM array",
                          "moduleid": "MOD_ADD_RAM",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current number of array entries",
                         "userdata2": "maximum number of array entries",
                      },
            0x17321A: {    "devdesc": "SBE cannot be reset during MPIPL",
                          "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                        "reasoncode": "RC_SBE_UPDATE_IN_MPIPL",
                         "userdata1": "ATTR_FORCE_SBE_UPDATE, bit mask of reasons See SBE_UPDATE_TYPE from attribute_types_hb.xml",
                         "userdata2": "0",
                      },
            0x17521A: {    "devdesc": "An IPL failure occurred",
                          "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                        "reasoncode": "RC_SBE_UPDATE_UNEXPECTEDLY_FAILED",
                         "userdata1": "ATTR_FORCE_SBE_UPDATE, bit mask of reasons See SBE_UPDATE_TYPE from attribute_types_hb.xml",
                         "userdata2": "0",
                      },
            0x175A1A: {    "devdesc": "Scratch reg / attribute mismatch",
                          "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                        "reasoncode": "RC_SCRATCH_REG_ATTR_MISMATCH",
                         "userdata1": "Bitwise scratch register miscompare",
                         "userdata2": "0",
                      },
            0x2BBC1A: {    "devdesc": "Incorrect response from TPM_CC_CreatePrimary command (see logs for TPM HUID)",
                          "moduleid": "MOD_TPM_CMD_CREATE_ATTEST",
                        "reasoncode": "RC_TPM_BAD_RESP",
                         "userdata1": "TPM HUID",
                         "userdata2": "Expected response RC",
                      },
            0x33411A: {    "devdesc": "Attribute overrides were rejected because system is in secure mode",
                          "moduleid": "MOD_FAPI2_MONITOR_FOR_FSP_MSGS",
                        "reasoncode": "RC_ATTR_OVERRIDE_DISALLOWED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90051b: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_MSVPD_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x2BB11B: {    "devdesc": "msg_sendrecv failed for createAttestationKeys",
                          "moduleid": "MOD_CREATE_ATT_KEYS",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msg_sendrecv",
                         "userdata2": "TPM HUID",
                      },
            0x33281B: {    "devdesc": "Less than expected number of bytes returned.",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_VPD_OCMB",
                        "reasoncode": "fapi2::RC_INVALID_TYPE",
                         "userdata1": "vpd_type attempted",
                         "userdata2": "HUID of OCMB target",
                      },
            0x90141c: {    "devdesc": "Master proc target returned is Null",
                          "moduleid": "HDAT::MOD_GET_PATH_INFO",
                        "reasoncode": "HDAT::RC_MASTER_PROC_TARGET_NULL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x100C1C: {    "devdesc": "Invalid target is supplied as input, SYSTEM target has no parent",
                          "moduleid": "TOD_UTIL_MOD_GET_PARENT",
                        "reasoncode": "TOD_INVALID_TARGET",
                         "userdata1": "HUID of the input target",
                         "userdata2": "",
                      },
            0x10171C: {    "devdesc": "Parent of input CLASS for supplied Target is not found",
                          "moduleid": "TOD_UTIL_MOD_GET_PARENT",
                        "reasoncode": "TOD_PARENT_NOT_FOUND",
                         "userdata1": "HUID of supplied Target",
                         "userdata2": "Size of the list",
                      },
            0x2BB11C: {    "devdesc": "msg_sendrecv failed for readAKCertificate",
                          "moduleid": "MOD_READ_AK_CERT",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msg_sendrecv",
                         "userdata2": "TPM HUID",
                      },
            0x333F1C: {    "devdesc": "platErrorOnSet> Set operation not valid",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_ERROR_ON_SET",
                        "reasoncode": "fapi2::RC_SET_ATTR_NOT_VALID",
                         "userdata1": "Target HUID",
                         "userdata2": "FAPI Attribute Id",
                      },
            0x9311D: {    "devdesc": "Invalid omi frequence and omi vco settings",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_MC_PLL_BUCKET",
                        "reasoncode": "fapi2::RC_NO_MATCHING_FREQ",
                         "userdata1": "ATTR_FREQ_OMI_MHZ",
                         "userdata2": "ATTR_FREQ_PLL_VCO",
                      },
            0x17351D: {    "devdesc": "P9N (Nimbus) DD1.x is not supported in this firmware driver.  Please update your module or use a different driver",
                          "moduleid": "ISTEP::MOD_SET_IPL_PARMS",
                        "reasoncode": "ISTEP::RC_P9N_DD1_NOT_SUPPORTED",
                         "userdata1": "PVR of master proc",
                         "userdata2": "",
                      },
            0x174D1D: {    "devdesc": "PNOR-IPMI not enabled, BMC firmware needs to be updated",
                          "moduleid": "ISTEP::MOD_SET_IPL_PARMS",
                        "reasoncode": "ISTEP::RC_PNOR_IPMI_NOT_ENABLED",
                         "userdata1": "HIOMAP Mode",
                         "userdata2": "CONFIG_PNORDD_IS_BMCMBOX",
                      },
            0x2BBC1D: {    "devdesc": "Incorrect response from TPM_CC_NV_Read command (see logs for TPM HUID)",
                          "moduleid": "MOD_TPM_CMD_READ_AK_CERT",
                        "reasoncode": "RC_TPM_BAD_RESP",
                         "userdata1": "TPM HUID",
                         "userdata2": "Expected response RC",
                      },
            0x90141d: {    "devdesc": "Master proc target returned is Null",
                          "moduleid": "HDAT::MOD_HDAT_SP_SUBSYS_CTOR",
                        "reasoncode": "HDAT::RC_MASTER_PROC_TARGET_NULL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x9311E: {    "devdesc": "Invalid omi frequence and omi vco settings",
                          "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_FREQ_MCA_MHZ",
                        "reasoncode": "fapi2::RC_NO_MATCHING_FREQ",
                         "userdata1": "ATTR_FREQ_OMI_MHZ",
                         "userdata2": "ATTR_FREQ_PLL_VCO",
                      },
            0x10191E: {    "devdesc": "Top level Target not found",
                          "moduleid": "TOD_IS_MPIPL",
                        "reasoncode": "TOD_TOP_LEVEL_TARGET_NOT_FOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x2BBC1E: {    "devdesc": "Incorrect response from TPM_CC_Quote command (see logs for TPM HUID)",
                          "moduleid": "MOD_TPM_CMD_GEN_QUOTE",
                        "reasoncode": "RC_TPM_BAD_RESP",
                         "userdata1": "TPM HUID",
                         "userdata2": "Expected response RC",
                      },
            0x90051e: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HDAT_SP_SUBSYS_DTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x90021f: {    "devdesc": "Top level target not found",
                          "moduleid": "HDAT::MOD_PCRD_LOAD",
                        "reasoncode": "HDAT::RC_TOP_LVL_TGT_NOT_FOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x900A1f: {    "devdesc": "could not find target",
                          "moduleid": "HDAT::MOD_PCRD_LOAD",
                        "reasoncode": "RC_TGT_ATTR_NOTFOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x100C1F: {    "devdesc": "No/Multiple parent(s) found for processor osc target",
                          "moduleid": "TOD_RT_TOPOLOGY_RESET_BACKUP",
                        "reasoncode": "TOD_INVALID_TARGET",
                         "userdata1": "The number of parents found osc target",
                         "userdata2": "None",
                      },
            0x101A1F: {    "devdesc": "Host interfaces are not initialized",
                          "moduleid": "TOD_RT_TOPOLOGY_RESET_BACKUP",
                        "reasoncode": "TOD_RT_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "None",
                         "userdata2": "None",
                      },
            0x2BB11F: {    "devdesc": "msg_sendrecv failed for generateQuote",
                          "moduleid": "MOD_GEN_QUOTE",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msg_sendrecv",
                         "userdata2": "TPM HUID",
                      },
            0x93120: {    "devdesc": "PROC or OCC expected",
                          "moduleid": "fapi::MOD_GET_OCC_CHIP_TARGET",
                        "reasoncode": "fapi::RC_TARGET_UNSUPPORTED",
                         "userdata1": "Target Type",
                         "userdata2": "Target HUID",
                      },
            0xA0120: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                          "moduleid": "FSI::MOD_FSIPRES_PROCPRESENCEDETECT",
                        "reasoncode": "FSI::RC_INVALID_LENGTH",
                         "userdata1": "Data Length",
                         "userdata2": "",
                      },
            0xA0F20: {    "devdesc": "presenceDetect> FSI and MVPD do not agree",
                          "moduleid": "FSI::MOD_FSIPRES_PROCPRESENCEDETECT",
                        "reasoncode": "FSI::RC_FSI_MVPD_MISMATCH",
                         "userdata1": "HUID of processor",
                         "userdata2": "FSI Presence",
                      },
            0x101A20: {    "devdesc": "Host interfaces are not initialized",
                          "moduleid": "TOD_RT_TOPOLOGY_DATA",
                        "reasoncode": "TOD_RT_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x173920: {    "devdesc": "Targets detected via I2C were rediscovered after an I2C reset.  Reboot to add to config",
                          "moduleid": "ISTEP::MOD_REDISCOVER_I2C_TARGETS",
                        "reasoncode": "ISTEP::RC_REDISCOVERED_TARGETS",
                         "userdata1": "HUID of 1st rediscovered target",
                         "userdata2": "HUID of 2nd rediscovered target, if applicable",
                      },
            0x1A2720: {    "devdesc": "Unable to fill in HB data memory",
                          "moduleid": "RUNTIME::MOD_FILL_RSVMEM_HBDATA",
                        "reasoncode": "RUNTIME::RC_EXCEEDED_MEMORY",
                         "userdata1": "Total size needed",
                         "userdata2": "Size allowed",
                      },
            0x1A4420: {    "devdesc": "Unknown reserved memory label attempted",
                          "moduleid": "RUNTIME::MOD_FILL_RSVMEM_HBDATA",
                        "reasoncode": "RUNTIME::RC_UNKNOWN_LABEL",
                         "userdata1": "Unknown Label",
                         "userdata2": "<unused>",
                      },
            0x1D0320: {    "devdesc": "The record enumeration did not have a corresponding string value.",
                          "moduleid": "VPD::VPD_IPVPD_TRANSLATE_RECORD",
                        "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                         "userdata1": "Record enumeration.",
                         "userdata2": "<UNUSED>",
                      },
            0x1E2020: {    "devdesc": "Error found in Node Comm status/ctrl register",
                          "moduleid": "MOD_NCDD_CHECK_FOR_ERRORS",
                        "reasoncode": "RC_NCDD_HW_ERROR_FOUND",
                         "userdata1": "Status Register Value",
                         "userdata2": "Target HUID",
                      },
            0x2BBC20: {    "devdesc": "Incorrect response from TPM2_FlushContext command (see logs for TPM HUID)",
                          "moduleid": "MOD_TPM_CMD_FLUSH_CONTEXT",
                        "reasoncode": "RC_TPM_BAD_RESP",
                         "userdata1": "TPM HUID",
                         "userdata2": "Expected response RC",
                      },
            0x333420: {    "devdesc": "Bad SPD or unsupported DIMM",
                          "moduleid": "MOD_FAPI2_SPD_ACCESS",
                        "reasoncode": "RC_INVALID_SPD_DRAM_GEN",
                         "userdata1": "DDR generation",
                         "userdata2": "HUID of input target",
                      },
            0x900120: {    "devdesc": "Input Target Pointer is NULL",
                          "moduleid": "HDAT::MOD_PCRD_SET_PROC_INF",
                        "reasoncode": "HDAT::RC_INVALID_OBJECT",
                         "userdata1": "Index of proc target",
                         "userdata2": "Target HUID",
                      },
            0x900620: {    "devdesc": "Input Target Pointer is NULL",
                          "moduleid": "HDAT::MOD_PCRD_SET_PROC_INF:",
                        "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x93221: {    "devdesc": "Improper data size, data is not 8 byte aligned.",
                          "moduleid": "fapi::MOD_ACCESS_OCB_INDIRECT_CHANNEL",
                        "reasoncode": "fapi::RC_INVALID_DATA_BUFFER_LENGTH",
                         "userdata1": "Length of requested buffer size(in Bytes) to perform read operation.",
                         "userdata2": "OCI address",
                      },
            0x93321: {    "devdesc": "Found mismatching processor attribute settings when we expect them to all be in sync",
                          "moduleid": "fapi2::MOD_GET_OMI_FREQ",
                        "reasoncode": "fapi2::RC_PROC_FREQ_MISMATCH",
                         "userdata1": "first ATTR_FREQ_OMI_MHZ found",
                         "userdata2": "first proc HUID",
                      },
            0x101B21: {    "devdesc": "This TOD OSC is not able to provide good signals to the processor. This OSC will be called out. Associated TOD end points on the processor side will also be called out, look for other callout details on this error log.",
                          "moduleid": "TOD_OSC_CALLOUT",
                        "reasoncode": "TOD_BAD_OSC",
                         "userdata1": "EMOD_CALLOUT_TOD_OSC",
                         "userdata2": "HUID of the TOD OSC through which good signals are not received.",
                      },
            0x171B21: {    "devdesc": "Nominal Mode mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_NOMINAL_FREQ_MISMATCH,",
                         "userdata1": "Master node nominal frequency",
                         "userdata2": "Current node nominal frequency",
                      },
            0x172021: {    "devdesc": "Power Mode mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_POWER_MODE_MISMATCH,",
                         "userdata1": "Master node nominal power mode",
                         "userdata2": "Current node nominal power mode",
                      },
            0x174021: {    "devdesc": "messages from other nodes have not returned in time",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_FREQ_ATTR_TIMER_EXPIRED,",
                         "userdata1": "MAX_TIME_ALLOWED_MS",
                         "userdata2": "Number of nodes that have not responded",
                      },
            0x174121: {    "devdesc": "Freq attribute DATA timer thread failed",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_FREQ_ATTR_TIMER_THREAD_FAIL,",
                         "userdata1": "l_tidretrc,",
                         "userdata2": "l_childsts,",
                      },
            0x174221: {    "devdesc": "Floor Freq mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_FLOOR_FREQ_MISMATCH,",
                         "userdata1": "Master node Floor frequency",
                         "userdata2": "Current node floor frequency",
                      },
            0x174321: {    "devdesc": "Ceil Freq mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_CEIL_FREQ_MISMATCH,",
                         "userdata1": "Master node Ceil frequency",
                         "userdata2": "Current node Ceil frequency",
                      },
            0x174421: {    "devdesc": "Turbo Freq mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_TURBO_FREQ_MISMATCH,",
                         "userdata1": "Master node Turbo frequency",
                         "userdata2": "Current node Turbo frequency",
                      },
            0x174521: {    "devdesc": "UltraTurbo Freq mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_ULTRA_TURBO_FREQ_MISMATCH,",
                         "userdata1": "Master node UltraTurbo frequency",
                         "userdata2": "Current node UltraTurbo frequency",
                      },
            0x174621: {    "devdesc": "Nest Freq mismatch between drawers",
                          "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                        "reasoncode": "ISTEP::RC_NEST_FREQ_MISMATCH,",
                         "userdata1": "Master node Nest frequency",
                         "userdata2": "Current node Nest frequency",
                      },
            0x1A2821: {    "devdesc": "Unable to pin read/write attribute memory",
                          "moduleid": "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL",
                        "reasoncode": "RUNTIME::RC_UNABLE_TO_PIN_ATTR_MEM",
                         "userdata1": "Message return code from message handler",
                         "userdata2": "Return code from msg_sendrecv function",
                      },
            0x1A2921: {    "devdesc": "Unable to unpin read/write attribute memory",
                          "moduleid": "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL",
                        "reasoncode": "RUNTIME::RC_UNABLE_TO_UNPIN_ATTR_MEM",
                         "userdata1": "Message return code from message handler",
                         "userdata2": "Return code from msg_sendrecv function",
                      },
            0x1D0421: {    "devdesc": "The keyword enumeration did not have a corresponding string value.",
                          "moduleid": "VPD::VPD_IPVPD_TRANSLATE_KEYWORD",
                        "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                         "userdata1": "Keyword Enumeration",
                         "userdata2": "<UNUSED>",
                      },
            0x1E2121: {    "devdesc": "Timed out waiting for command complete.",
                          "moduleid": "MOD_NCDD_WAIT_FOR_CMD_COMP",
                        "reasoncode": "RC_NCDD_CMD_COMP_TIMEOUT",
                         "userdata1": "Status Register Value",
                         "userdata2": "Status/Control Register Address",
                      },
            0x2BB121: {    "devdesc": "msg_sendrecv failed for TPM2_FlushContext",
                          "moduleid": "MOD_FLUSH_CONTEXT",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msg_sendrecv",
                         "userdata2": "TPM HUID",
                      },
            0x900521: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_PCRD_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0xA0B22: {    "devdesc": "FsiDD::genFullFsiAddr> Master Type is not supported",
                          "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_FSI_NOT_SUPPORTED",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Physical Node of FSI Master processor",
                      },
            0xA0C22: {    "devdesc": "FsiDD::genFullFsiAddr> Cannot chain 2 masters",
                          "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_INVALID_FSI_PATH_1",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Target's FSI Master Chip",
                      },
            0xA0D22: {    "devdesc": "FsiDD::genFullFsiAddr> Invalid master type for the target's master",
                          "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                        "reasoncode": "FSI::RC_INVALID_FSI_PATH_2",
                         "userdata1": "Target of FSI Operation",
                         "userdata2": "Target's FSI Master Chip",
                      },
            0x174A22: {    "devdesc": "p10_fabric_iovalid HWP returned errors on odd and even links. Creating an error to link all the individual link RCs together",
                          "moduleid": "MOD_SMP_WRAP_PROC_IOVALID",
                        "reasoncode": "RC_LINK_TRAIN_ERRORS_FROM_HWP",
                         "userdata1": "PROC HUID",
                         "userdata2": "Number of RCs from HWP",
                      },
            0x1A3E22: {    "devdesc": "messages from other nodes have not returned in time",
                          "moduleid": "RUNTIME::MOD_SEND_SBE_SYSCONFIG,",
                        "reasoncode": "RUNTIME::RC_SEND_SBE_TIMER_EXPIRED,",
                         "userdata1": "Message Type IPC_QUERY_CHIPINFO or IPC_SET_SBE_CHIPINFO",
                         "userdata2": "Number of nodes that have not responded",
                      },
            0x1A3F22: {    "devdesc": "sendSBESystemConfig timer thread failed",
                          "moduleid": "RUNTIME::MOD_SEND_SBE_SYSCONFIG,",
                        "reasoncode": "RUNTIME::RC_HOST_TIMER_THREAD_FAIL,,",
                         "userdata1": "l_tidretrc,",
                         "userdata2": "l_childsts,",
                      },
            0x1D0322: {    "devdesc": "The requested record was not found in the VPD TOC.",
                          "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET",
                        "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                         "userdata1": "Requested Record",
                         "userdata2": "Requested Keyword",
                      },
            0x1D3122: {    "devdesc": "Unable to resolve the VPD source (PNOR or SEEPROM)",
                          "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET",
                        "reasoncode": "VPD::VPD_READ_SOURCE_UNRESOLVED",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested VPD Source Location",
                      },
            0x1E2222: {    "devdesc": "No Attention was found after sending data in Xbus Node Comm Test",
                          "moduleid": "MOD_NC_XBUS_TEST",
                        "reasoncode": "RC_NC_DATA_MISCOMPARE",
                         "userdata1": "Data Read Back",
                         "userdata2": "LinkId data was read from",
                      },
            0x1E2322: {    "devdesc": "No Attention was found after sending data in XBUS Node Comm Test",
                          "moduleid": "MOD_NC_XBUS_TEST",
                        "reasoncode": "RC_NC_NO_ATTN_FOUND",
                         "userdata1": "Data Sent",
                         "userdata2": "LinkId data was sent from",
                      },
            0x2BB122: {    "devdesc": "msg_sendrecv failed for pcrRead",
                          "moduleid": "MOD_PCR_READ",
                        "reasoncode": "RC_SENDRECV_FAIL",
                         "userdata1": "rc from msg_sendrecv",
                         "userdata2": "TPM HUID",
                      },
            0x334322: {    "devdesc": "Invalid read buffer size, needs to be divisible by transaction size",
                          "moduleid": "fapi2::MOD_FAPI2_EXPLR_IB_I2C_READ",
                        "reasoncode": "fapi2::RC_INVALID_BUFFER_SIZE",
                         "userdata1": "Buffer size",
                         "userdata2": "Transaction size",
                      },
            0x901522: {    "devdesc": "PVPD read fail",
                          "moduleid": "HDAT::MOD_UTIL_PVPD_READ_FUNC",
                        "reasoncode": "HDAT::RC_PVPD_READ_FAIL",
                         "userdata1": "pvpd record",
                         "userdata2": "pvpd keyword",
                      },
            0x901622: {    "devdesc": "PVPD read fail",
                          "moduleid": "HDAT::MOD_UTIL_PVPD_READ_FUNC",
                        "reasoncode": "HDAT::RC_PVPD_FAIL",
                         "userdata1": "pvpd record",
                         "userdata2": "pvpd keyword",
                      },
            0x1A3223: {    "devdesc": "Error with Firmware Notify request",
                          "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                        "reasoncode": "RC_FW_NOTIFY_RT_INVALID_MSG",
                         "userdata1": "Firmware Request type",
                         "userdata2": "Sequence number (FSP msg)",
                      },
            0x1A3423: {    "devdesc": "SBE error recovery attempt failed",
                          "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                        "reasoncode": "RC_FW_REQUEST_RT_NULL_PTR",
                         "userdata1": "HUID of target",
                         "userdata2": "HWSV error log id (plid)",
                      },
            0x1A3523: {    "devdesc": "SBE error recovery attempt failed",
                          "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                        "reasoncode": "RC_SBE_RT_INVALID_HUID",
                         "userdata1": "HUID of target",
                         "userdata2": "HWSV error log id (plid)",
                      },
            0x1D0423: {    "devdesc": "Keyword was not found in Record starting at given offset.",
                          "moduleid": "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR",
                        "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                         "userdata1": "Start of Record Offset",
                         "userdata2": "Keyword Index",
                      },
            0x1D0523: {    "devdesc": "Record name does not match value expected for offset read.",
                          "moduleid": "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR",
                        "reasoncode": "VPD::VPD_RECORD_MISMATCH",
                         "userdata1": "Current offset into VPD",
                         "userdata2": "Start of Record offset",
                      },
            0x1E2423: {    "devdesc": "Too many attentions were found in the Node Comm FIR Register",
                          "moduleid": "MOD_NC_MAP_ATTN",
                        "reasoncode": "RC_NC_TOO_MANY_ATTNS_FOUND",
                         "userdata1": "Raw FIR Data",
                         "userdata2": "Number of Attentions found",
                      },
            0x334323: {    "devdesc": "Invalid write buffer size, needs to be divisible by transaction size",
                          "moduleid": "fapi2::MOD_FAPI2_EXPLR_IB_I2C_WRITE",
                        "reasoncode": "fapi2::RC_INVALID_BUFFER_SIZE",
                         "userdata1": "Buffer size",
                         "userdata2": "Transaction size",
                      },
            0x901823: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_PROCESS_FRU",
                        "reasoncode": "HDAT::RC_DEV_UNMAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x174C24: {    "devdesc": "The HX keyword data found in the vpd is invalid. See Userdata for specific reason.",
                          "moduleid": "MOD_GET_LANEMASK_FROM_HX_KEYWORD",
                        "reasoncode": "RC_INVALID_HX_KEYWORD_DATA",
                         "userdata1": "Return code value from parseHxKeyword",
                         "userdata2": "PEC target HUID",
                      },
            0x1A3424: {    "devdesc": "Hypervisor firmware request interface not linked",
                          "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                        "reasoncode": "RC_FW_REQUEST_RT_NULL_PTR",
                         "userdata1": "Number of Attributes to serialize and send",
                         "userdata2": "",
                      },
            0x1A3724: {    "devdesc": "The Firmware Request call failed",
                          "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                        "reasoncode": "RC_FW_REQUEST_HWSV_ERR",
                         "userdata1": "HWSV error log id (PLID)",
                         "userdata2": "Sequence number",
                      },
            0x1A3824: {    "devdesc": "The Firmware Request call failed",
                          "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                        "reasoncode": "RC_FW_REQUEST_RESET_RELOAD_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "Firmware Request type (HCODE Update) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation",
                      },
            0x1A3924: {    "devdesc": "The Firmware Request call failed",
                          "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                        "reasoncode": "RC_FW_REQUEST_ERR",
                         "userdata1": "Hypervisor return code",
                         "userdata2": "Firmware Request type (HCODE Update) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation",
                      },
            0x1D0624: {    "devdesc": "Buffer size was not greater than or equal to expected buffer size.",
                          "moduleid": "VPD::VPD_IPVPD_CHECK_BUFFER_SIZE",
                        "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                         "userdata1": "Buffer Size",
                         "userdata2": "Expected Buffer Size",
                      },
            0x1E2524: {    "devdesc": "Invalid Input Args for Node Comm DD call",
                          "moduleid": "MOD_NCDD_PERFORM_OP",
                        "reasoncode": "RC_NCDD_INVALID_ARGS",
                         "userdata1": "BUS Mode Enum Value",
                         "userdata2": "LinkId Value",
                      },
            0x1E3024: {    "devdesc": "NodeComm DD invalid operation type",
                          "moduleid": "MOD_NCDD_PERFORM_OP",
                        "reasoncode": "RC_NCDD_INVALID_OP_TYPE",
                         "userdata1": "Operation type",
                         "userdata2": "Input Target HUID",
                      },
            0x2BBD24: {    "devdesc": "Could not fetch the TPM log manager",
                          "moduleid": "MOD_TPM_CMD_EXPAND_TPM_LOG",
                        "reasoncode": "RC_NO_TPM_LOG_MGR",
                         "userdata1": "TPM HUID",
                         "userdata2": "",
                      },
            0x901724: {    "devdesc": "process fru funciton failed",
                          "moduleid": "HDAT::MOD_BUILD_SPECIFIED_VPD",
                        "reasoncode": "HDAT::RC_PROCESS_FRU_FAIL",
                         "userdata1": "Spira data area",
                         "userdata2": "Hdat fru type",
                      },
            0x1A3C25: {    "devdesc": "Attribute failed to update on HBRT side",
                          "moduleid": "MOD_RT_ATTR_SYNC_REQUEST",
                        "reasoncode": "RC_ATTR_UPDATE_FAILED",
                         "userdata1": "Target HUID",
                         "userdata2": "Attribute ID",
                      },
            0x1E2625: {    "devdesc": "Sent bit not set in Node Comm status/ctrl register",
                          "moduleid": "MOD_NCDD_WRITE",
                        "reasoncode": "RC_NCDD_DATA_NOT_SENT",
                         "userdata1": "Status Register Value",
                         "userdata2": "Target HUID",
                      },
            0x900525: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HDAT_SERVICEDATA_CTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x174F26: {    "devdesc": "The UCD content LID was not found within the UCD container",
                          "moduleid": "ISTEP::MOD_CALL_UPDATE_UCD_FLASH",
                        "reasoncode": "ISTEP::RC_UCD_IMG_NOT_IN_CONTAINER",
                         "userdata1": "UCD LID ID",
                         "userdata2": "",
                      },
            0x1A3D26: {    "devdesc": "Hostboot attempted to reserve memory past allowed range. Bottom limit = Hostboot HRMOR + 64M, top limit = 256M - 4K.",
                          "moduleid": "RUNTIME::MOD_CHECK_HB_RES_MEM_LIMIT",
                        "reasoncode": "RUNTIME::RC_HB_RES_MEM_EXCEEDED",
                         "userdata1": "Starting address",
                         "userdata2": "Size of the section",
                      },
            0x1E2926: {    "devdesc": "Master Proc's ATTR_PHYS_PATH is invalid as it doesn't have either a NODE or PROC elemenent",
                          "moduleid": "MOD_NCEX_MAIN",
                        "reasoncode": "RC_NCEX_INVALID_PHYS_PATH",
                         "userdata1": "Master Proc Target HUID",
                         "userdata2": "<Unused>",
                      },
            0x1E2A26: {    "devdesc": "When processing the OBUS Peer paths, the wrong count of valid paths was found",
                          "moduleid": "MOD_NCEX_MAIN",
                        "reasoncode": "RC_NCEX_INVALID_INSTANCE_COUNT",
                         "userdata1": "Master Proc Target HUID",
                         "userdata2": "Number of Valid OBUS Instances",
                      },
            0x900526: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HDAT_NODEDATA_DTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x175027: {    "devdesc": "Could not unmap unsecure HOMER's virtual address",
                          "moduleid": "ISTEP::MOD_LOAD_HCODE",
                        "reasoncode": "ISTEP::RC_MM_UNMAP_FAILED",
                         "userdata1": "Unsecure HOMER addr",
                         "userdata2": "RC from HBPM_UNMAP",
                      },
            0x1A4027: {    "devdesc": "Copy of trace buffer from previous HBRT run",
                          "moduleid": "RUNTIME::MOD_INIT_RT_RES_MEM_TRACE_BUF",
                        "reasoncode": "RUNTIME::RC_RT_RES_TRACE_BUF_DUMPED",
                         "userdata1": "unused",
                         "userdata2": "unused",
                      },
            0x901927: {    "devdesc": "could not create the data area from spiras",
                          "moduleid": "HDAT::MOD_SPIRAS_CREATE_DATA_AREA",
                        "reasoncode": "HDAT::RC_DATA_AREA_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1A4228: {    "devdesc": "SP ATTN Areas attempting to allocate past valid memory range.",
                          "moduleid": "RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS",
                        "reasoncode": "RUNTIME::RC_SP_ATTN_AREA_OVERFLOW",
                         "userdata1": "SP ATTN Area total size",
                         "userdata2": "SP ATTN Area start address",
                      },
            0x1A4328: {    "devdesc": "SP ATTN Area 1 size exceeds the maximum.",
                          "moduleid": "RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS",
                        "reasoncode": "RUNTIME::RC_SP_ATTN_AREA1_SIZE_OVERFLOW",
                         "userdata1": "SP ATTN Area 1 size proposed by hostboot",
                         "userdata2": "SP ATTN Area 1 size reported in HDAT",
                      },
            0x900528: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_SPIRAS_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x175B29: {    "devdesc": "Hostboot did not detect a part that the service processor found.",
                          "moduleid": "ISTEP::MOD_DISCOVER_TARGETS",
                        "reasoncode": "ISTEP::RC_PRESENCE_MISMATCH_HB",
                         "userdata1": "HUID of missing target",
                         "userdata2": "",
                      },
            0x175C29: {    "devdesc": "Hostboot detected a part that the service processor did not.",
                          "moduleid": "ISTEP::MOD_DISCOVER_TARGETS",
                        "reasoncode": "ISTEP::RC_PRESENCE_MISMATCH_SP",
                         "userdata1": "HUID of missing target",
                         "userdata2": "",
                      },
            0x1A4529: {    "devdesc": "Unable to allocate firmware request messages",
                          "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                        "reasoncode": "RC_NULL_FIRMWARE_MSG_PTR",
                         "userdata1": "Number of Attributes to serialize and send",
                         "userdata2": "",
                      },
            0x1A4629: {    "devdesc": "Serialization of an Attribute Failed",
                          "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                        "reasoncode": "RC_SERIALIZE_ATTRIBUTE_FAILED",
                         "userdata1": "Number of Attributes to serialize and send",
                         "userdata2": "",
                      },
            0x1A4729: {    "devdesc": "Serialization data of Attribute to large for given buffer",
                          "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                        "reasoncode": "RC_NO_SPACE_FOR_ATTRIBUTE_SERIALIZATION",
                         "userdata1": "Number of Attributes to serialize and send",
                         "userdata2": "",
                      },
            0x1E3429: {    "devdesc": "Functional Primary TPM was not found",
                          "moduleid": "MOD_NCEX_GET_RANDOM",
                        "reasoncode": "RC_NCEX_NO_FUNCTIONAL_PRIMARY_TPM",
                         "userdata1": "TPM Target HUID",
                         "userdata2": "TPM Target HWAS State Present",
                      },
            0x900529: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HDAT_SPIRAH_DTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "Spirah address hi",
                         "userdata2": "Spirah address lo",
                      },
            0x901a2a: {    "devdesc": "Null passed for spirah ms addr",
                          "moduleid": "HDAT::MOD_HDAT_GET_SPIRAH",
                        "reasoncode": "HDAT::RC_NULL_PTR_PASSED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1E272A: {    "devdesc": "Mismatch between expected and actual Link Mbox Ids a secure ABUS message was received on",
                          "moduleid": "MOD_NC_RECV",
                        "reasoncode": "RC_NCEX_MISMATCH_RECV_LINKS",
                         "userdata1": "Master Proc Target HUID",
                         "userdata2": "Expected Link Id to receive message on",
                      },
            0x1E2B2A: {    "devdesc": "Timed out waiting to receive message over ABUS Link Mailbox",
                          "moduleid": "MOD_NC_RECV",
                        "reasoncode": "RC_NC_WAITING_TIMEOUT",
                         "userdata1": "Master Proc Target HUID",
                         "userdata2": "Time Polled in ns",
                      },
            0x90052b: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_NACA_GET_MEM",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x901b2b: {    "devdesc": "map a mapped region failed",
                          "moduleid": "HDAT::MOD_NACA_GET_MEM",
                        "reasoncode": "HDAT::RC_INVALID_NACA",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1E2D2B: {    "devdesc": "Could not fetch primary TPM's Log",
                          "moduleid": "MOD_NC_GEN_SLAVE_RESPONSE",
                        "reasoncode": "RC_NC_NO_PRIMARY_TPM_LOG",
                         "userdata1": "Primary TPM HUID",
                         "userdata2": "",
                      },
            0x1A1A2C: {    "devdesc": "Targeting target's type not supported by runtime code",
                          "moduleid": "RUNTIME::MOD_CONFIGURE_HBRT_HYP_IDS",
                        "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                         "userdata1": "Target's HUID",
                         "userdata2": "Target's targeting type",
                      },
            0x90052c: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HBRT_LOAD_DATA",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x900A2c: {    "devdesc": "The target attribute not found",
                          "moduleid": "HDAT::MOD_HBRT_LOAD_DATA",
                        "reasoncode": "HDAT::RC_TGT_ATTR_NOTFOUND",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x901c2d: {    "devdesc": "Device read failed",
                          "moduleid": "HDAT::MOD_UTIL_FULL_MVPD_READ_FUNC",
                        "reasoncode": "HDAT::RC_DEV_READ_VPD_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x9242D: {    "devdesc": "mm_block_unmap returned incorrectly with 0",
                          "moduleid": "fapi::MOD_START_XZ_PAYLOAD",
                        "reasoncode": "fapi::RC_MM_UNMAP_ERR",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x93E2D: {    "devdesc": "xz-embedded has returned an error. the return code can be found in xz.h",
                          "moduleid": "fapi::MOD_START_XZ_PAYLOAD",
                        "reasoncode": "fapi::RC_INVALID_RETURN_XZ_CODE",
                         "userdata1": "Return code from xz-embedded",
                         "userdata2": "Original Payload Size",
                      },
            0x1A4D2E: {    "devdesc": "Could not map OCC reset reason from PHYP to HTMGT",
                          "moduleid": "RUNTIME::MOD_PM_RT_RESET_W_REASON",
                        "reasoncode": "RUNTIME::RC_COULD_NOT_MAP_RESET_REASON",
                         "userdata1": "Input OCC reason code",
                         "userdata2": "Chip ID of the input chip",
                      },
            0x1E312E: {    "devdesc": "Invalid Input Args for Node Comm Transfer Send",
                          "moduleid": "MOD_NCT_SEND",
                        "reasoncode": "RC_NCT_TYPE_SIZE_MISMATCH",
                         "userdata1": "Input TARGET HUID",
                         "userdata2": "Input Data Size",
                      },
            0x1E322E: {    "devdesc": "Invalid data from ACK for Node Comm Transfer Send",
                          "moduleid": "MOD_NCT_SEND",
                        "reasoncode": "RC_NCT_ACK_MISMATCH",
                         "userdata1": "Actual Node Sending the ACK",
                         "userdata2": "Expected Node Sending the ACK",
                      },
            0x90152f: {    "devdesc": "PVPD read fail",
                          "moduleid": "HDAT::MOD_UTIL_PVPD_FULL_READ_FUNC",
                        "reasoncode": "HDAT::RC_PVPD_READ_FAIL",
                         "userdata1": "pvpd record",
                         "userdata2": "",
                      },
            0x90162f: {    "devdesc": "PVPD read fail",
                          "moduleid": "HDAT::MOD_UTIL_PVPD_FULL_READ_FUNC",
                        "reasoncode": "HDAT::RC_PVPD_FAIL",
                         "userdata1": "pvpd record",
                         "userdata2": "",
                      },
            0x92A2F: {    "devdesc": "messages from other nodes have not returned in time",
                          "moduleid": "fapi::MOD_VERIFY_IPC_CONNECTION",
                        "reasoncode": "fapi::RC_HOST_TIMER_EXPIRED",
                         "userdata1": "MAX_TIME_ALLOWED_MS",
                         "userdata2": "Number of nodes that have not responded",
                      },
            0x92B2F: {    "devdesc": "host coalesce host timer thread failed",
                          "moduleid": "fapi::MOD_VERIFY_IPC_CONNECTION",
                        "reasoncode": "fapi::RC_HOST_TIMER_THREAD_FAIL",
                         "userdata1": "l_tidRetRc",
                         "userdata2": "l_childSts",
                      },
            0x17072F: {    "devdesc": "mm_block_unmap failed and returned nullptr",
                          "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                        "reasoncode": "ISTEP::RC_MM_UNMAP_ERR",
                         "userdata1": "Map Fail Location",
                         "userdata2": "Return code from mm_block_unmap",
                      },
            0x170A2F: {    "devdesc": "mm_block_map failed and returned nullptr",
                          "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                        "reasoncode": "ISTEP::RC_MM_MAP_ERR",
                         "userdata1": "Map Fail Location",
                         "userdata2": "<UNUSED>",
                      },
            0x173A2F: {    "devdesc": "PAYLOAD allocated more HDAT space than temporary space that Hostboot uses",
                          "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                        "reasoncode": "ISTEP::RC_HDAT_SIZE_CHECK_FAILED",
                         "userdata1": "Allocated HDAT size from PAYLOAD",
                         "userdata2": "Temporary HDAT size",
                      },
            0x1E312F: {    "devdesc": "Unexpected Size of Data Received based on Input Transfer Type",
                          "moduleid": "MOD_NCT_RECEIVE",
                        "reasoncode": "RC_NCT_TYPE_SIZE_MISMATCH",
                         "userdata1": "Input TARGET HUID",
                         "userdata2": "Output Data Size",
                      },
            0x1E332F: {    "devdesc": "Invalid data from Initiation Message",
                          "moduleid": "MOD_NCT_RECEIVE",
                        "reasoncode": "RC_NCT_INITIATION_MISMATCH",
                         "userdata1": "Actual Node Sending the Initiation Message",
                         "userdata2": "Expected Node Sending the Initiation Message",
                      },
            0x1D0330: {    "devdesc": "The requested record was not found in the VPD VTOC.",
                          "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET_SEEPROM",
                        "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                         "userdata1": "Requested Record",
                         "userdata2": "Requested Keyword",
                      },
            0x1D3030: {    "devdesc": "The VHDR was invalid",
                          "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET_SEEPROM",
                        "reasoncode": "VPD::VPD_RECORD_INVALID_VHDR",
                         "userdata1": "VHDR length",
                         "userdata2": "Target HUID",
                      },
            0x900D30: {    "devdesc": "Device read failed",
                          "moduleid": "HDAT::MOD_UTIL_MVPD",
                        "reasoncode": "HDAT::RC_DEV_READ_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1D3131: {    "devdesc": "Unable to resolve the VPD source (PNOR or SEEPROM)",
                          "moduleid": "VPD::VPD_IPVPD_FETCH_DATA",
                        "reasoncode": "VPD::VPD_READ_SOURCE_UNRESOLVED",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested VPD Source Location",
                      },
            0x900531: {    "devdesc": "Unmap a mapped region failed",
                          "moduleid": "HDAT::MOD_HDAT_IPMI_DTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x1D3432: {    "devdesc": "Unable to resolve the VPD destination (PNOR or SEEPROM)",
                          "moduleid": "VPD::VPD_IPVPD_WRITE_KEYWORD",
                        "reasoncode": "VPD::VPD_WRITE_DEST_UNRESOLVED",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested VPD Destination",
                      },
            0x1D3c32: {    "devdesc": "Attempting to write to a VPD record that has been overridden by firmware",
                          "moduleid": "VPD::VPD_IPVPD_WRITE_KEYWORD",
                        "reasoncode": "VPD::VPD_CANNOT_WRITE_OVERRIDDEN_VPD",
                         "userdata1": "Target HUID",
                         "userdata2": "<unused>",
                      },
            0x900532: {    "devdesc": "Creation of mapped region failed",
                          "moduleid": "HDAT::MOD_TPMDATA_CONSTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "Address attempted to map upper",
                         "userdata2": "Address attempted to map lower",
                      },
            0x1D3533: {    "devdesc": "The amount of space required for the VPD cache exceeds the available space",
                          "moduleid": "VPD::VPD_IPVPD_LOAD_PNOR",
                        "reasoncode": "VPD::VPD_CACHE_SIZE_EXCEEDED",
                         "userdata1": "HUID of target chip",
                         "userdata2": "Available size",
                      },
            0x900533: {    "devdesc": "Unmap of a mapped region failed",
                          "moduleid": "HDAT::MOD_TPMDATA_DESTRUCTOR",
                        "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                         "userdata1": "Address attempted to unmap upper",
                         "userdata2": "Address attempted to unmap lower",
                      },
            0x1D3034: {    "devdesc": "The VHDR was invalid",
                          "moduleid": "VPD::VPD_IPVPD_GET_RECORD_LIST_SEEPROM",
                        "reasoncode": "VPD::VPD_RECORD_INVALID_VHDR",
                         "userdata1": "VHDR length",
                         "userdata2": "Target HUID",
                      },
            0x901e34: {    "devdesc": "Invalid OBUS brick ID",
                          "moduleid": "HDAT::MOD_UTIL_SMP_LINK_INFO",
                        "reasoncode": "HDAT::RC_INVALID_OBUS_BRICKID",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x901f34: {    "devdesc": "Invalid OBUS Freq Bucket",
                          "moduleid": "HDAT::MOD_UTIL_SMP_LINK_INFO",
                        "reasoncode": "HDAT::RC_INVALID_OBUS_FREQ_BUCKET",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x901135: {    "devdesc": "Failed trying to add another entry to a mainstore area MMIO address range array",
                          "moduleid": "MOD_ADD_MMIO_ADDR_RANGE",
                        "reasoncode": "RC_ERC_MAX_EXCEEDED",
                         "userdata1": "current no of mmio array entries",
                         "userdata2": "maximum no of mmio array entries",
                      },
            0x1E4140: {    "devdesc": "Master processor target did not have ATTR_GPIO_INFO_PHYS_PRES associated with it",
                          "moduleid": "MOD_DETECT_PHYS_PRES",
                        "reasoncode": "RC_PHYS_PRES_ATTR_NOT_FOUND",
                         "userdata1": "HUID of Master Processor Target",
                         "userdata2": "ATTR_GPIO_INFO_PHYS_PRES hash value",
                      },
            0x1E4240: {    "devdesc": "Attempt to close physical presence window did not close the window",
                          "moduleid": "MOD_DETECT_PHYS_PRES",
                        "reasoncode": "RC_PHYS_PRES_WINDOW_NOT_CLOSED",
                         "userdata1": "HUID of Master Processor Target",
                         "userdata2": "LED Data from PCA9551",
                      },
            0x1E4440: {    "devdesc": "Physical Presence was Asserted",
                          "moduleid": "MOD_DETECT_PHYS_PRES",
                        "reasoncode": "RC_PHYS_PRES_ASSERTED",
                         "userdata1": "Value of Attribute Requesting an Open Window",
                         "userdata2": "Value of Attribute to Fake Physical Presence Assertion",
                      },
            0x1E4341: {    "devdesc": "Attempt to open physical presence window did not close the window",
                          "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                        "reasoncode": "RC_PHYS_PRES_WINDOW_NOT_OPENED",
                         "userdata1": "HUID of Master Processor Target",
                         "userdata2": "LED Data from PCA9551",
                      },
            0x1E4541: {    "devdesc": "Re-IPLing to open a Physical Presence Window",
                          "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                        "reasoncode": "RC_PHYS_PRES_REIPL",
                         "userdata1": "Value of Attribute Requesting an Open Window",
                         "userdata2": "Value of Key Clear Requests",
                      },
            0x1E4741: {    "devdesc": "Found special case of KEY_CLEAR_REQUEST_MFG; No Re-IPL is necessary",
                          "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                        "reasoncode": "RC_KEY_CLEAR_REQUEST_MFG",
                         "userdata1": "Value of Attribute Requesting an Open Window",
                         "userdata2": "Value of Key Clear Requests",
                      },
            0x1E4642: {    "devdesc": "Attempt to clear the Key Clear Request Sensor failed as it still requests some keys to be cleared",
                          "moduleid": "MOD_CLEAR_KEY_CLEAR_SENSOR",
                        "reasoncode": "RC_CLEARING_KEY_CLEAR_SENSOR_FAILED",
                         "userdata1": "Expected Key Clear Request Sensor Value",
                         "userdata2": "Actual Key Clear Request Sensor Value",
                      },
            0x61543: {    "devdesc": "SfcIBM::pollOpComplete> Error or timeout from SFC Status Register",
                          "moduleid": "PNOR::MOD_SFCIBM_POLLOPCOMPLETE",
                        "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                         "userdata1": "NOR Flash Chip ID",
                         "userdata2": "Total poll time (ns)",
                      },
            0x60245: {    "devdesc": "PnorDD::eraseFlash> Address not on erase boundary",
                          "moduleid": "PNOR::MOD_SFCIBM_ERASEFLASH",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "Flash address being erased",
                         "userdata2": "Nearest Erase Boundary",
                      },
            0x61046: {    "devdesc": "SfcIBM::checkForErrors> Error(s) found in SFC and/or LPC Slave Status Registers",
                          "moduleid": "PNOR::MOD_SFCIBM_CHECKFORERRORS",
                        "reasoncode": "PNOR::RC_ERROR_IN_STATUS_REG",
                         "userdata1": "SFC Status Register",
                         "userdata2": "LPC Slave Status Register",
                      },
            0x60747: {    "devdesc": "SfcIBM::hwReset> Unsupported Reset Level requested",
                          "moduleid": "PNOR::MOD_SFCIBM_HWRESET",
                        "reasoncode": "PNOR::RC_UNSUPPORTED_OPERATION",
                         "userdata1": "Unsupported Reset Level Parameter",
                         "userdata2": "<unused>",
                      },
            0x1D3650: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                          "moduleid": "VPD::VPD_PVPD_PRESENCEDETECT",
                        "reasoncode": "VPD::VPD_INVALID_LENGTH",
                         "userdata1": "Data Length",
                         "userdata2": "",
                      },
            0x60261: {    "devdesc": "SfcFake::readFlash> Requested access exceeded the bounds of the allocated PNOR space",
                          "moduleid": "PNOR::MOD_SFCFAKE_READFLASH",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "PNOR Address",
                         "userdata2": "Bytes to read",
                      },
            0x1D0761: {    "devdesc": "Invalid Basic Memory Type",
                          "moduleid": "VPD::VPD_SPD_GET_KEYWORD_VALUE",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "Basic Memory Type (Byte 2)",
                         "userdata2": "Keyword Requested",
                      },
            0x60262: {    "devdesc": "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space",
                          "moduleid": "PNOR::MOD_SFCFAKE_WRITEFLASH",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "PNOR Address",
                         "userdata2": "Bytes to write",
                      },
            0x1D1462: {    "devdesc": "The table entry associated with keyword was NULL.",
                          "moduleid": "VPD::VPD_SPD_GET_VALUE",
                        "reasoncode": "VPD::VPD_NULL_ENTRY",
                         "userdata1": "SPD Keyword",
                         "userdata2": "Buffer Size",
                      },
            0x60263: {    "devdesc": "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space",
                          "moduleid": "PNOR::MOD_SFCFAKE_ERASEFLASH",
                        "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                         "userdata1": "PNOR Address",
                         "userdata2": "<unused>",
                      },
            0x1D0663: {    "devdesc": "Buffer Size provided was not big enough for the keyword requested.",
                          "moduleid": "VPD::VPD_SPD_CHECK_SIZE",
                        "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                         "userdata1": "Keyword",
                         "userdata2": "Needed Buffer Size",
                      },
            0x60764: {    "devdesc": "SfcFake::sendSpiCmd> Function is not supported",
                          "moduleid": "PNOR::MOD_SFCFAKE_SENDSPICMD",
                        "reasoncode": "PNOR::RC_UNSUPPORTED_OPERATION",
                         "userdata1": "Op Code",
                         "userdata2": "Address",
                      },
            0x1D0164: {    "devdesc": "File is not sufficiently large to read number of bytes at offset given without overrunning file.",
                          "moduleid": "VPD::VPD_SPD_READ_BINARY_FILE",
                        "reasoncode": "VPD::VPD_INSUFFICIENT_FILE_SIZE",
                         "userdata1": "File Size",
                         "userdata2": "Starting offset into file",
                      },
            0x1D0765: {    "devdesc": "Invalid Basic Memory Type",
                          "moduleid": "VPD::VPD_SPD_WRITE_KEYWORD_VALUE",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "Basic Memory Type (Byte 2)",
                         "userdata2": "Keyword Requested",
                      },
            0x1D0766: {    "devdesc": "Invalid DDR Revision",
                          "moduleid": "VPD::VPD_SPD_SPECIAL_CASES",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "SPD Keyword",
                         "userdata2": "DIMM DDR Revision",
                      },
            0x1D0967: {    "devdesc": "Keyword is not a special case keyword.",
                          "moduleid": "VPD::VPD_SPD_DDR3_SPECIAL_CASES",
                        "reasoncode": "VPD::VPD_INVALID_SPD_KEYWORD",
                         "userdata1": "SPD Keyword",
                         "userdata2": "UNUSED",
                      },
            0x1D0968: {    "devdesc": "Keyword is not a special case keyword.",
                          "moduleid": "VPD::VPD_SPD_DDR4_SPECIAL_CASES",
                        "reasoncode": "VPD::VPD_INVALID_SPD_KEYWORD",
                         "userdata1": "SPD Keyword",
                         "userdata2": "UNUSED",
                      },
            0x1D0669: {    "devdesc": "Buffer for checking Presence Detect was not the correct size.",
                          "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                        "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                         "userdata1": "Buffer Length",
                         "userdata2": "<UNUSED>",
                      },
            0x1D116A: {    "devdesc": "Unsupported Module Type.",
                          "moduleid": "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD",
                        "reasoncode": "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED",
                         "userdata1": "Memory Module Type",
                         "userdata2": "Memory Type (byte 2)",
                      },
            0x1D0B6B: {    "devdesc": "The SPD Keyword is not writable.",
                          "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                        "reasoncode": "VPD::VPD_KEYWORD_NOT_WRITABLE",
                         "userdata1": "SPD Keyword",
                         "userdata2": "Buffer Length",
                      },
            0x1D146B: {    "devdesc": "The table entry associated with keyword was NULL.",
                          "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                        "reasoncode": "VPD::VPD_NULL_ENTRY",
                         "userdata1": "SPD Keyword",
                         "userdata2": "Buffer Length",
                      },
            0x1D156B: {    "devdesc": "Writes to non-byte SPD keywords are unsupported.",
                          "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                        "reasoncode": "VPD::VPD_UNSUPPORTED_WRITE",
                         "userdata1": "SPD Keyword",
                         "userdata2": "Keyword Length (in bytes)",
                      },
            0x1D046C: {    "devdesc": "Invalid SPD Keyword",
                          "moduleid": "VPD::VPD_SPD_GET_KEYWORD_ENTRY",
                        "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                         "userdata1": "SPD Keyword",
                         "userdata2": "<UNUSED>",
                      },
            0x1D076C: {    "devdesc": "Invalid DDR Revision",
                          "moduleid": "VPD::VPD_SPD_GET_KEYWORD_ENTRY",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "SPD Keyword",
                         "userdata2": "The DDR Revision",
                      },
            0x1D116E: {    "devdesc": "Unrecognized Module Type.",
                          "moduleid": "VPD::VPD_SPD_GET_MOD_TYPE",
                        "reasoncode": "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED",
                         "userdata1": "Module Type (byte 3[3:0])",
                         "userdata2": "Memory Type (byte 2)",
                      },
            0x1D316F: {    "devdesc": "Unable to resolve the VPD source (PNOR or SEEPROM)",
                          "moduleid": "VPD::VPD_SPD_FETCH_DATA",
                        "reasoncode": "VPD::VPD_READ_SOURCE_UNRESOLVED",
                         "userdata1": "Target HUID",
                         "userdata2": "Requested VPD Source Location",
                      },
            0x1D0770: {    "devdesc": "Invalid DDR Revision",
                          "moduleid": "VPD::VPD_SPD_SET_DIMM_SIZE",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "HUID to DIMM target",
                         "userdata2": "The DDR Revision",
                      },
            0x260C76: {    "devdesc": "Invalid OCC present data in POLL response",
                          "moduleid": "HTMGT_MOD_OCC_POLL",
                        "reasoncode": "HTMGT_RC_DUPLICATE_CHIP_ID",
                         "userdata1": "OCC instance",
                         "userdata2": "response OCC present",
                      },
            0x261C76: {    "devdesc": "Invalid POLL response length",
                          "moduleid": "HTMGT_MOD_OCC_POLL",
                        "reasoncode": "HTMGT_RC_INVALID_LENGTH",
                         "userdata1": "OCC instance",
                         "userdata2": "",
                      },
            0x262276: {    "devdesc": "Invalid role is POLL response",
                          "moduleid": "HTMGT_MOD_OCC_POLL",
                        "reasoncode": "HTMGT_RC_INVALID_ROLE",
                         "userdata1": "OCC instance",
                         "userdata2": "response state",
                      },
            0x61480: {    "devdesc": "SfcAST2X00::enableWriteMode> Unable to enable write mode on the PNOR flash",
                          "moduleid": "PNOR::MOD_SFCAST2X00_ENABLEWRITEMODE",
                        "reasoncode": "PNOR::RC_CANNOT_ENABLE_WRITES",
                         "userdata1": "Output from RDSR",
                         "userdata2": "NOR chip id",
                      },
            0xB8080: {    "devdesc": "The caller passed an invalid node target to find the master proc handle.",
                          "moduleid": "TARG_MOD_QUERY_MASTER_PROC_CHIP",
                        "reasoncode": "TARG_RC_INVALID_NODE",
                         "userdata1": "HUID of Target Passed",
                         "userdata2": "",
                      },
            0xB8180: {    "devdesc": "The caller passed an invalid node target to find the master proc handle",
                          "moduleid": "TARG_MOD_QUERY_MASTER_PROC_CHIP",
                        "reasoncode": "TARG_RC_TARGET_NOT_FOUND",
                         "userdata1": "HUID of Target Passed",
                         "userdata2": "",
                      },
            0xB8081: {    "devdesc": "The caller passed an invalid node target.",
                          "moduleid": "TARG_MOD_SET_MASTER_NODE",
                        "reasoncode": "TARG_RC_INVALID_NODE",
                         "userdata1": "HUID of Target Passed",
                         "userdata2": "",
                      },
            0xC8181: {    "devdesc": "Attempt to create a GARD Record for a target that is not GARDable (not DECONFIG_GARDABLE or not present)",
                          "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_TARGET_NOT_GARDABLE",
                         "userdata1": "HUID of input target // GARD errlog EID",
                         "userdata2": "ATTR_DECONFIG_GARDABLE // ATTR_HWAS_STATE.present",
                      },
            0xC8281: {    "devdesc": "Attempt to create a GARD Record and the GARD Repository is full",
                          "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_GARD_REPOSITORY_FULL",
                         "userdata1": "HUID of input target // GARD errlog EID",
                         "userdata2": "",
                      },
            0xC8681: {    "devdesc": "Post de-configuration of target failed",
                          "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_RT_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "HUID of target",
                         "userdata2": "none",
                      },
            0xC8781: {    "devdesc": "Post de-configuration of target failed",
                          "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_RT_NULL_FIRMWARE_MSG_PTR",
                         "userdata1": "HUID of target",
                         "userdata2": "none",
                      },
            0xC8981: {    "devdesc": "Problem clearing and reset of version",
                          "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "HWAS::RC_BAD_CLEAR_ALL_RESET_VERSION",
                         "userdata1": "none",
                         "userdata2": "none",
                      },
            0xC8A81: {    "devdesc": "No PART NUMBER attribute found on the requested FRU target",
                          "moduleid": "MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "RC_NO_FRU_PART_NUM",
                         "userdata1": "HUID of original input target // GARD errlog EID",
                         "userdata2": "HUID of FRU target",
                      },
            0xC8B81: {    "devdesc": "No SERIAL NUMBER attribute found on the requested FRU target",
                          "moduleid": "MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "RC_NO_FRU_SERIAL_NUM",
                         "userdata1": "HUID of original input target // GARD errlog EID",
                         "userdata2": "HUID of FRU target",
                      },
            0xC8C81: {    "devdesc": "No FRU parent target found for PN or SN",
                          "moduleid": "MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "RC_NO_FRU_TARGET",
                         "userdata1": "HUID of original input target // GARD errlog EID",
                         "userdata2": "",
                      },
            0xC8D81: {    "devdesc": "Not the CURRENT GARD VERSION LAYOUT, NEED INVESTIGATION",
                          "moduleid": "MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "RC_NOT_CURRENT_GARD_VERSION",
                         "userdata1": "GARD errlog EID",
                         "userdata2": "",
                      },
            0xC8E81: {    "devdesc": "Cleaning old gard records",
                          "moduleid": "MOD_PLAT_DECONFIG_GARD",
                        "reasoncode": "RC_CLEAN_GARD_RECORDS",
                         "userdata1": "iv_version read from BINARY",
                         "userdata2": "current iv_version expected",
                      },
            0xB0282: {    "devdesc": "The eyecatch value observed in memory does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute sections are unable to be parsed.",
                          "moduleid": "TARG_MOD_ATTRRP_RT",
                        "reasoncode": "TARG_RC_BAD_EYECATCH",
                         "userdata1": "Observed Header Eyecatch Value",
                         "userdata2": "Memory address referenced.",
                      },
            0xB8A82: {    "devdesc": "Expected node is not present in ATTR_HB_EXISTING_IMAGE",
                          "moduleid": "TARG_MOD_ATTRRP_RT",
                        "reasoncode": "TARG_RT_NODE_NOT_IN_IMAGE",
                         "userdata1": "Node",
                         "userdata2": "HB Existing Image",
                      },
            0xC8382: {    "devdesc": "platReadIDEC> Invalid chipid from hardware (all FFs)",
                          "moduleid": "HWAS::MOD_PLAT_READIDEC",
                        "reasoncode": "HWAS::RC_BAD_CHIPID",
                         "userdata1": "Target HUID",
                         "userdata2": "<unused>",
                      },
            0x1D1b82: {    "devdesc": "Reserved size in memory insufficient for runtime VPD",
                          "moduleid": "VPD::VPD_BLD_RT_IMAGE",
                        "reasoncode": "VPD::VPD_INSUFFICIENT_SPACE_FOR_IMAGE",
                         "userdata1": "Size provided",
                         "userdata2": "vpd_type | Size required",
                      },
            0x61583: {    "devdesc": "SfcAST2X00::pollOpComplete> Timeout during write or erase operation",
                          "moduleid": "PNOR::MOD_SFCAST2X00_POLLOPCOMPLETE",
                        "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                         "userdata1": "NOR Flash Chip ID",
                         "userdata2": "Total poll time (ns)",
                      },
            0xB8283: {    "devdesc": "Size of override data exceeds available buffer space",
                          "moduleid": "TARG_MOD_SAVE_OVERRIDE_TANK",
                        "reasoncode": "TARG_SPACE_OVERRUN",
                         "userdata1": "Maximum Available size",
                         "userdata2": "Required size",
                      },
            0xC8483: {    "devdesc": "platReadLx> Invalid Lx keyword",
                          "moduleid": "HWAS::MOD_PLAT_READLX",
                        "reasoncode": "HWAS::RC_BAD_LX",
                         "userdata1": "Target MCA HUID",
                         "userdata2": "Value of x for Lx keyword",
                      },
            0xC8583: {    "devdesc": "platReadLx> Bad MCA target",
                          "moduleid": "HWAS::MOD_PLAT_READLX",
                        "reasoncode": "HWAS::RC_BAD_MCA",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x1D3783: {    "devdesc": "MBOX send not supported in HBRT",
                          "moduleid": "VPD_SEND_MBOX_WRITE_MESSAGE",
                        "reasoncode": "VPD_RT_NULL_FIRMWARE_REQUEST_PTR",
                         "userdata1": "HUID of target",
                         "userdata2": "VPD message type",
                      },
            0x1D3d83: {    "devdesc": "Could not determine which node the target is in",
                          "moduleid": "VPD_SEND_MBOX_WRITE_MESSAGE",
                        "reasoncode": "VPD_FAILED_TO_RESOLVE_NODE_TARGET",
                         "userdata1": "HUID of target to update VPD for",
                         "userdata2": "VPD message type",
                      },
            0xB8284: {    "devdesc": "Size of attribute data exceeds available buffer space",
                          "moduleid": "TARG_MOD_SAVE_ATTR_TANK",
                        "reasoncode": "TARG_SPACE_OVERRUN",
                         "userdata1": "Maximum Available size",
                         "userdata2": "Required size",
                      },
            0xC8884: {    "devdesc": "Hostboot running on proc with only NVDIMMs",
                          "moduleid": "HWAS::MOD_CHECK_HB_NVDIMM",
                        "reasoncode": "HWAS::RC_HB_PROC_ONLY_NVDIMM",
                         "userdata1": "Hostboot Proc Target HUID",
                         "userdata2": "Hostboot Memory Group",
                      },
            0xB8885: {    "devdesc": "There is a mismatch with the sizes of the lid and/or reserved memory section",
                          "moduleid": "TARGETING::TARG_RT_HBRT_UPDATE_PREP",
                        "reasoncode": "TARGETING::TARG_RT_BAD_ATTR_SIZES",
                         "userdata1": "Lid size",
                         "userdata2": "Attribute size in lid",
                      },
            0xB8386: {    "devdesc": "Bad eyecatcher in the new lid data",
                          "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                        "reasoncode": "TARGETING::TARG_RT_BAD_EYECATCHER_LID",
                         "userdata1": "Eyecatcher from LID",
                         "userdata2": "Expected eyecatcher",
                      },
            0xB8486: {    "devdesc": "Bad eyecatcher in the existing attribute data",
                          "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                        "reasoncode": "TARGETING::TARG_RT_BAD_EYECATCHER_MEM",
                         "userdata1": "Eyecatcher from existing memory",
                         "userdata2": "Expected eyecatcher",
                      },
            0xB8586: {    "devdesc": "Section number mismatch between new and old data",
                          "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                        "reasoncode": "TARGETING::TARG_RT_SECTION_NUM_MISMATCH",
                         "userdata1": "Number of sections in lid",
                         "userdata2": "Number of sections in existing mem",
                      },
            0xB8686: {    "devdesc": "Section number mismatch between new and old data",
                          "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                        "reasoncode": "TARGETING::TARG_RT_SECTION_MISMATCH",
                         "userdata1": "Section number",
                         "userdata2": "Section type in the lid",
                      },
            0xB8787: {    "devdesc": "Could not find attribute data in lid",
                          "moduleid": "TARGETING::TARG_RT_SAVERESTOREATTRS",
                        "reasoncode": "TARGETING::TARG_RT_MISSING_ATTR",
                         "userdata1": "Attribute Id",
                         "userdata2": "HUID of target",
                      },
            0xB8988: {    "devdesc": "For some reason attr IDs in hbMutexAttrIds list are not matching the attribute IDs that target service is seeing. This is causing incorrect matching Make sure mutexattribute.H in genfiles has good values",
                          "moduleid": "TARG_SVC_RESET_MUTEX",
                        "reasoncode": "TARG_SVC_MISSING_ATTR",
                         "userdata1": "Attribute Id we attempted to read",
                         "userdata2": "Huid of target we attempted to read",
                      },
            0xB8089: {    "devdesc": "Invalid Node ID was returned for the passed target",
                          "moduleid": "TARG_MOD_ATTRRP_TO_COMMON_ADDR",
                        "reasoncode": "TARG_RC_INVALID_NODE",
                         "userdata1": "Target's HUID",
                         "userdata2": "Node ID",
                      },
            0x1D1490: {    "devdesc": "SPD is not valid for this part",
                          "moduleid": "VPD::VPD_OCMB_GET_SPD",
                        "reasoncode": "VPD::VPD_NULL_ENTRY",
                         "userdata1": "Buffer Size",
                         "userdata2": "Memory Type",
                      },
            0x260190: {    "devdesc": "OCC is not valid",
                          "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                        "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                         "userdata1": "OCC command type",
                         "userdata2": "",
                      },
            0x260E90: {    "devdesc": "Unable to send cmd to OCC exception",
                          "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                        "reasoncode": "HTMGT_RC_OCC_EXCEPTION",
                         "userdata1": "OCC command",
                         "userdata2": "comm established",
                      },
            0x262490: {    "devdesc": "OCC comm not established or command is not supported",
                          "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                        "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                         "userdata1": "OCC command",
                         "userdata2": "comm established",
                      },
            0x1D0791: {    "devdesc": "Invalid Basic Memory Type",
                          "moduleid": "VPD::VPD_OCMB_SPD_PERFORM_OP",
                        "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                         "userdata1": "Basic Memory Type (Byte 2)",
                         "userdata2": "Target HUID",
                      },
            0x263591: {    "devdesc": "Timeout waiting for OCC response",
                          "moduleid": "HTMGT_MOD_WRITE_OCC_CMD",
                        "reasoncode": "HTMGT_RC_TIMEOUT",
                         "userdata1": "command",
                         "userdata2": "read timeout",
                      },
            0x1D4192: {    "devdesc": "An unsupported eeprom content type was supplied.",
                          "moduleid": "VPD::VPD_READ_FROM_EEPROM_SOURCE",
                        "reasoncode": "VPD::VPD_INVALID_EEPROM_CONTENT_TYPE",
                         "userdata1": "Eeprom Content Type Given",
                         "userdata2": "Target HUID",
                      },
            0x261992: {    "devdesc": "OCC response had checksum failure",
                          "moduleid": "HTMGT_MOD_CHECK_OCC_RSP",
                        "reasoncode": "HTMGT_RC_CHECKSUM_FAIL",
                         "userdata1": "OCC command type",
                         "userdata2": "sequence number",
                      },
            0x261B92: {    "devdesc": "Invalid length in OCC response",
                          "moduleid": "HTMGT_MOD_CHECK_OCC_RSP",
                        "reasoncode": "HTMGT_RC_OCC_CMD_FAIL",
                         "userdata1": "OCC command type",
                         "userdata2": "response data length",
                      },
            0x1D4193: {    "devdesc": "An unsupported eeprom content type was supplied.",
                          "moduleid": "VPD::VPD_GET_MEMTYPE",
                        "reasoncode": "VPD::VPD_INVALID_EEPROM_CONTENT_TYPE",
                         "userdata1": "Eeprom Content Type Given",
                         "userdata2": "Target HUID",
                      },
            0x261894: {    "devdesc": "Invalid response length received",
                          "moduleid": "HTMGT_MOD_PARSE_OCC_RSP",
                        "reasoncode": "HTMGT_RC_SEND_FAIL",
                         "userdata1": "response length",
                         "userdata2": "response buffer[0-3]",
                      },
            0x60BA0: {    "devdesc": "micronFlagStatus> Error or timeout from Micron Flag Status Register",
                          "moduleid": "PNOR::MOD_NORMICRON_MICRONFLAGSTATUS",
                        "reasoncode": "PNOR::RC_MICRON_INCOMPLETE",
                         "userdata1": "Micron Flag status register",
                         "userdata2": "NOR Flash Chip ID",
                      },
            0x61BB0: {    "devdesc": "invalid section passed to getSectionInfo  or section prohibited by secureboot",
                          "moduleid": "PNOR::MOD_RTPNOR_GETSECTIONINFO",
                        "reasoncode": "PNOR::RC_RTPNOR_INVALID_SECTION",
                         "userdata1": "PNOR::SectionId",
                         "userdata2": "Inhibited by secureboot",
                      },
            0x61DB0: {    "devdesc": "section size is zero",
                          "moduleid": "PNOR::MOD_RTPNOR_GETSECTIONINFO",
                        "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                         "userdata1": "PNOR::SectionId",
                         "userdata2": "",
                      },
            0x603B1: {    "devdesc": "invalid section passed to flush",
                          "moduleid": "PNOR::MOD_RTPNOR_FLUSH",
                        "reasoncode": "PNOR::RC_INVALID_SECTION",
                         "userdata1": "PNOR::SectionId",
                         "userdata2": "",
                      },
            0x61DB1: {    "devdesc": "section size is zero",
                          "moduleid": "PNOR::MOD_RTPNOR_FLUSH",
                        "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                         "userdata1": "PNOR::SectionId",
                         "userdata2": "",
                      },
            0x616B2: {    "devdesc": "g_hostInterfaces->pnor_read failed",
                          "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                        "reasoncode": "PNOR::RC_PNOR_READ_FAILED",
                         "userdata1": "rc returned from pnor_read",
                         "userdata2": "section ID",
                      },
            0x617B2: {    "devdesc": "error writing corrected data back to PNOR",
                          "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                        "reasoncode": "PNOR::RC_PNOR_WRITE_FAILED",
                         "userdata1": "rc returned from pnor_write",
                         "userdata2": "Expected size of write",
                      },
            0x61CB2: {    "devdesc": "UNCORRECTABLE ECC",
                          "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                        "reasoncode": "PNOR::RC_UNCORRECTABLE_ECC",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x61FB2: {    "devdesc": "g_hostInterfaces->pnor_read not supported",
                          "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                        "reasoncode": "PNOR::RC_PNOR_READ_NOT_SUPPORTED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x62AB2: {    "devdesc": "Amount of data read from pnor does not match expected size",
                          "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                        "reasoncode": "PNOR::RC_WRONG_SIZE_FROM_READ",
                         "userdata1": "section ID",
                         "userdata2": "requested size of read",
                      },
            0x617B3: {    "devdesc": "g_hostInterfaces->pnor_write failed",
                          "moduleid": "PNOR::MOD_RTPNOR_WRITETODEVICE",
                        "reasoncode": "PNOR::RC_PNOR_WRITE_FAILED",
                         "userdata1": "rc returned from pnor_write",
                         "userdata2": "section ID",
                      },
            0x620B3: {    "devdesc": "g_hostInterfaces->pnor_write not supported",
                          "moduleid": "PNOR::MOD_RTPNOR_WRITETODEVICE",
                        "reasoncode": "PNOR::RC_PNOR_WRITE_NOT_SUPPORTED",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x627B4: {    "devdesc": "getSideInfo> Side not supported",
                          "moduleid": "PNOR::MOD_RTPNOR_GETSIDEINFO",
                        "reasoncode": "PNOR::RC_INVALID_PNOR_SIDE",
                         "userdata1": "Requested SIDE",
                         "userdata2": "0",
                      },
            0x63ED0: {    "devdesc": "Secureboot page verify failure",
                          "moduleid": "MOD_SPNORRP_VERIFY_PAGE",
                        "reasoncode": "RC_VERIFY_PAGE_FAILED",
                         "userdata1": "Kernel RC",
                         "userdata2": "Virtual address accessed",
                      },
            0x604D2: {    "devdesc": "SPnorRP::initDaemon> Error from mm_alloc_block",
                          "moduleid": "PNOR::MOD_SPNORRP_ALLOCATE_BLOCK",
                        "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_alloc_block",
                      },
            0x601D3: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                          "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_INVALID_MESSAGE_TYPE",
                         "userdata1": "Message type",
                         "userdata2": "Requested Virtual Address",
                      },
            0x635D3: {    "devdesc": "Not a loaded section",
                          "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_NOT_A_LOADED_SECTION",
                         "userdata1": "Section attempted to unload",
                         "userdata2": "",
                      },
            0x636D3: {    "devdesc": "Not a supported section",
                          "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_NOT_A_SUPPORTED_SECTION",
                         "userdata1": "Section attempted to unload",
                         "userdata2": "",
                      },
            0x637D3: {    "devdesc": "Secure unload of sections that critical to hostboot operation are not allowed.",
                          "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                        "reasoncode": "PNOR::RC_SECURE_UNLOAD_DISALLOWED",
                         "userdata1": "Section Id",
                         "userdata2": "",
                      },
            0x634D4: {    "devdesc": "Cannot verify unsigned PNOR section",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_UNSIGNED_PNOR_SECTION",
                         "userdata1": "PNOR section requested to verify",
                         "userdata2": "0",
                      },
            0x638D4: {    "devdesc": "Total Container Size smaller than Protected Payload and Header size",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_SECURE_TOTAL_SIZE_INVAL",
                         "userdata1": "PNOR section",
                         "userdata2": "Protected Payload Size plus Header Size",
                      },
            0x639D4: {    "devdesc": "Virtual address of PNOR section is not in Secure Space",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_SECURE_VADDR_MISMATCH",
                         "userdata1": "PNOR section",
                         "userdata2": "PNOR section virtual address",
                      },
            0x63AD4: {    "devdesc": "PNOR section size smaller than total container size",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_SECURE_SIZE_MISMATCH",
                         "userdata1": "PNOR section",
                         "userdata2": "Total Container Size",
                      },
            0x63BD4: {    "devdesc": "Protected Payload Size not Page aligned",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_NOT_PAGE_ALIGNED",
                         "userdata1": "PNOR section",
                         "userdata2": "Protected Payload Size",
                      },
            0x63CD4: {    "devdesc": "Verified Protected Payload size does not match what was parsed by PnorRp",
                          "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                        "reasoncode": "PNOR::RC_SECURE_PRO_SIZE_MISMATCH",
                         "userdata1": "PNOR section",
                         "userdata2": "Protected Payload Size",
                      },
            0x604D5: {    "devdesc": "Could not set permissions of the given PNOR section",
                          "moduleid": "PNOR::MOD_SPNORRP_SET_PERMISSION",
                        "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                         "userdata1": "Requested Address",
                         "userdata2": "rc from mm_set_permission",
                      },
            0x604D6: {    "devdesc": "Secure Boot: Failed to securely load or unload signed boot firmware.",
                          "moduleid": "MOD_PNORRP_LOADUNLOADSECURESECTION",
                        "reasoncode": "RC_EXTERNAL_ERROR",
                         "userdata1": "returncode from msg_sendrecv() or msg->data[1]",
                         "userdata2": "SPNOR message type [LOAD | UNLOAD]",
                      },
            0x62FD7: {    "devdesc": "Hostboot Base and Extend code do not match versions.",
                          "moduleid": "MOD_SPNORRP_BASE_EXT_VER_CHK",
                        "reasoncode": "RC_BASE_EXT_MISMATCH",
                         "userdata1": "First 8 bytes of hash of measured SW signatures",
                         "userdata2": "First 8 bytes of hash of stored SW signatures in hash page table",
                      },
            0x630D8: {    "devdesc": "Key transition flag not set in outer SBKT container containing new hw keys",
                          "moduleid": "MOD_SPNORRP_KEY_TRAN_CHK",
                        "reasoncode": "RC_KEY_TRAN_FLAG_UNSET",
                         "userdata1": "0",
                         "userdata2": "0",
                      },
            0x604D9: {    "devdesc": "mm_remove_pages failed",
                          "moduleid": "PNOR::MOD_SPNORRP_REMOVE_PAGES",
                        "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                         "userdata1": "virtual address",
                         "userdata2": "rc from mm_remove_pages",
                      },
            0x608E0: {    "devdesc": "astMbox::doMessage> LPC Error communicating                            with the mailbox",
                          "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                        "reasoncode": "PNOR::RC_LPC_ERROR",
                         "userdata1": "",
                         "userdata2": "",
                      },
            0x615E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                          "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                        "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                         "userdata1": "mbox status 1 reg",
                         "userdata2": "mbox flag reg",
                      },
            0x632E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                          "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                        "reasoncode": "PNOR::RC_HIOMAP_BAD_SEQUENCE",
                         "userdata1": "mbox status 1 reg",
                         "userdata2": "mbox flag reg",
                      },
            0x633E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                          "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                        "reasoncode": "PNOR::RC_HIOMAP_ERROR_STATUS",
                         "userdata1": "mbox status 1 reg",
                         "userdata2": "mbox flag reg",
                      },
            0x2601E0: {    "devdesc": "OCC reported exception",
                          "moduleid": "HTMGT_MOD_HANLDE_OCC_EXCEPTION",
                        "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                         "userdata1": "rsp status",
                         "userdata2": "exception data length",
                      },
            0x2616E1: {    "devdesc": "Operation not allowed, system is in safe mode",
                          "moduleid": "HTMGT_MOD_ENABLE_OCC_ACTUATION",
                        "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                         "userdata1": "OCC activate [1==true][0==false]",
                         "userdata2": "return code triggering safe mode",
                      },
            0x632F0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                          "moduleid": "PNOR::MOD_IPMIPNORDD_SEND_MESSAGE",
                        "reasoncode": "PNOR::RC_HIOMAP_BAD_SEQUENCE",
                         "userdata1": "mbox status 1 reg",
                         "userdata2": "reserved",
                      },
            0x633F0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                          "moduleid": "PNOR::MOD_IPMIPNORDD_SEND_MESSAGE",
                        "reasoncode": "PNOR::RC_HIOMAP_ERROR_STATUS",
                         "userdata1": "mbox status 1 reg",
                         "userdata2": "reserved",
                      },
          }
