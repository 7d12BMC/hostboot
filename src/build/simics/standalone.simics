# Note : Assumes these vars were setup in startup.simics
# $hb_masterproc : name of master proc chip object
# $vpo_compile : VPO mode or not
# $hb_multiproc : enable multiple processors
##

$hb_pnor = ""
$hb_pnor = (get-master-pnors)[0]

#New Simics flow can simply get the string from get-master-pnor command
if ($hb_pnor == NIL) {
    try {
        @simenv.hb_pnor = quiet_run_command("get-master-pnor")[0]
        @SIM_get_object(simenv.hb_pnor[0])
    } except {
        foreach $pnor in (get-object-list -all BmcCmp) {
            $hb_pnor = ($pnor)
        }
        $hb_pnor = $hb_pnor+".sfc_master_mem"
    }
}
echo "Master PNOR is: "+$hb_pnor

###################################
#EEPROM Cache
###################################
# Look for a custom pre-built copy first
$found_custom_eecache = 0
try {
    $eccPreload = (lookup-file "%simics%/custom_eecache.bin")
    $found_custom_eecache = 1
} except {
    $found_custom_eecache = 0
}

if( $vpo_compile == "1" ) {
    echo "    - Skipping EECACHE preload (VPO Mode)"
} else {
    if( $found_custom_eecache == 1 ) {
        #yep...
    } else if( $hb_multiproc == 1 )  {
        $eccPreload = (lookup-file "%simics%/eecache_2proc_prebuilt.bin.ecc")
    } else {
        $eccPreload = (lookup-file "%simics%/eecache_prebuilt.bin.ecc")
    }
    # NOTE must change offset if PNOR layout changes EECACHE offsets
    echo "    - Loading EECACHE "+$eccPreload+" at 0x2C000 in PNOR"
    ($hb_pnor).load-file $eccPreload 0x2C000
}
###################################


# Turn on all processor cec-chips
foreach $proc in (get-component-list -all proc_p10_pib) {
    foreach $cc in (get-object-list component=$proc type=cec-chip -recursive) {
        @SIM_get_interface(SIM_get_object(simenv.cc), "signal").signal_raise()
    }
}

###################################
#Enable the IPMI Responder
###################################
echo "Enable IPMI Responder"
try {
      run-python-file (lookup-file hbfw/ipmi_bt_responder.py)
} except { echo "ERROR: Failed to load IPMIresponder." }

###############################
#Initialize Explorer Registers
###############################

# Loop over all explorer chips
foreach $obj in (get-object-list ocmb -all){

    # Allow for testing MMIO HW failures
    # Forces write access to TRACE_TRDATA_CONFIG_0(0x08010403) to fail
    # in src/usr/mmio/test/mmiotest.H
    # NOTE: address is left shifted 3 and has MMIO
    #       offset (0x100000000) added.
    $obj->mmio_regs_mmioerr = 0x0000000140082018

}

### Enable the second processor - @TODO-RTC:254475

# Connect up the missing cfams
try {connect backplane0.cnt_hfsi_link[1] backplane0.cnt_fsi_slave[0][1][1]} except {}

###############################
#Initialize Scratch Registers
###############################

# See src/include/usr/initservice/mboxRegs.H for scratch reg struct definitions

# Scratch8:  Set valid bits for Regs 3/4/6/9/10 (Bits 2/3/5/8/9)
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x3F*4 0x34C00000 4 -b

# Scratch3:  Set fwModeCtlFlags (0:31) - Clear all flags
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x3A*4 0x00000000 4 -b

# Scratch4:  Set refSpiBusDivider (0:15) coreBootFreqMhz (16:31)
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x3B*4 0x00410000 4 -b

# Scratch6:  Set isMaster (Bit 24)
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x3D*4 0x00000080 4 -b

# Scratch9:  Set pauPllFreqMhz (0:15) mc(0-3)PllBucket (16:27) ndlMeshCtlSetup (28:31)
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x180*4 0x09600000 4 -b

# Scratch10: Set iohs<bucket>PllBucket (0:31) 4 bits/bucket
(get-master-procs)[0].cfam_cmp.lbus_map.write 0x2800 + 0x181*4 0x33333333 4 -b

#####

# Force the localbus to default to the PIB side
foreach $fsis in (get-object-list -all fsi_slave_t3_v6) {
    $fsis->enforce_lbo = FALSE
}
