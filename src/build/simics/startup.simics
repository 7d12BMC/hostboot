# We need to add the script directory in the P10 simics model
if defined hb_script_to_run {
    $hb_script_location = (python "''.join(map('/'.__add__,\""+$hb_script_to_run+"\"[1:].split('/')[0:-1]))")
    $script_dir = (python "''.join(map('/'.__add__,\""+$hb_script_location+"\"[1:].split('/')[0:-1]))")
    add-directory $script_dir
}
#Display Simics Search Path
list-directories

$hb_startup_path = (lookup-file hbfw/startup.simics)
$cur_path = (env PATH)
$cur_path = $cur_path+":"+$hb_script_location
python "os.environ['HB_TOOLPATH'] = \""+$hb_script_location+"\""
python "os.environ['PATH'] = \""+$cur_path+"\""

$hb_machine = "P10"
# Simics relies on hb_mode; hb_mode is 0 for Axone and beyond
$hb_mode = 0

# Whether we're trying to run in VPO mode or not
$vpo_compile = "0"
@if 'VPO_COMPILE' in os.environ: simenv.vpo_compile = "1"

python "os.environ['HB_MACHINE'] = \""+$hb_machine+"\""
echo "HB_MACHINE is: "+$hb_machine

$hb_masterproc = (get-master-procs)[0]
$hb_masterproc_cecchip = (get-master-cec-chips)[0]

echo "Master Proc is: "+$hb_masterproc
echo "Master Proc Cec-Chip is: "+$hb_masterproc_cecchip

# Choose a default core to start with
$hb_cpu = (get-master-cpus)[0]

if($vpo_compile == "1") {
    $hb_cpu = "system_cmp0.cpu0_0_01_0"
}

echo "Defaulting to CPU "+$hb_cpu+" for Hostboot tools"

# Prevent SBE Updates from happening on an IPL
echo "Altering SBE SEEPROM Versions to disable Update in IPL"
foreach $cc in (get-all-procs) {
# These commands cause P10 simics to fail because the seeprom*_image component
# is not yet implemented in P10 simics. The lines need to be uncommented when
# the SBE is implemented in the P10 model.
        #($cc).seeprom1_image.set 0x3FED9 0x5A5A5A5A 8 -l
        #($cc).seeprom3_image.set 0x3FED9 0x5A5A5A5A 8 -l
}

# Load HB debug tools.
try {
    run-python-file (lookup-file hbfw/simics-debug-framework.py)
}   except { echo "ERROR: Failed to load Simics debug framework (simics-debug-framework.py)" }
try {
    run-python-file (lookup-file hbfw/hb-simdebug.py)
} except { echo "ERROR: Failed to load Hostboot debug tools (hb-simdebug.py)" }


# Build EECACHE
if defined bmc_files {
        # load EECACHE creation tool
        run-python-file (lookup-file hbfw/eecache-gen.py)

        #echo "Find eecache file name from: "+$bmc_files
        @simenv.eecache_file = find_eecache_file( simenv.bmc_files )

        $hb_skip_eecache = 0
        try {
            $eecache_file = (lookup-file $eecache_file)
            #echo "FOUND EECACHE: "+$eecache_file
        } except {
             echo "No eecache file found in bmc_files:"+$bmc_files+", skip EECACHE generation"
             $hb_skip_eecache = 1;
        }

        if ($hb_skip_eecache != 1) {
            @simenv.bmc_files = resolve_eecache_path( simenv.bmc_files, simenv.eecache_file )
            #echo "Resolved eecache path: "+$bmc_files

            # Create EECACHE file using version 1
            @eecache_gen( simenv.eecache_file, 1)

            # check if ECC needs to be added to the EECACHE file
            if defined eecacheEcc {
                # load ECC tools
                run-python-file (lookup-file hbfw/ecc.py)

                # pad the eecache file to nearest 4K boundary
                @alignFileByValue( simenv.eecache_file, 4096 )

                # add ECC to the eecache file
                @injectECC( simenv.eecache_file, simenv.eecache_file )

                echo "Successfully created "+$eecache_file+" with ECC"
            } else {
                echo "Successfully created "+$eecache_file
            }
        }

} else {
    echo "bmc_files not specified, so no EECACHE auto generated"
}


# Determine security state
$hw_security=(shell "echo $SECURITY_HW_POLICY")
if($hw_security == "") {
    # Assume default (no HW security) if not specified
    $hw_security = "0"
}

if(($hw_security != "1") and ($hw_security != "0")) {
    # Emit warning and assume default
    echo ("SECURITY: WARNING! Bad value "+
        $hw_security+" for HW security policy, defaulting to 0")
    $hw_security = "0"
}
echo "SECURITY: HW security policy set to "+$hw_security

# Translate security state to SIMICS jumper state
$jumperApplied=TRUE
if($hw_security == "1") {
    $jumperApplied=FALSE
}

if($vpo_compile == "0") { # no secureboot in VPO
    # Set logical jumper state in SIMICS based on HW policy
    #     "TRUE"=jumper applied(security disabled, default)
    #     "FALSE"=jumper removed(security enabled)

    # Load jumper state to the master processor
    $hb_masterproc.set-secure-jumper value = $jumperApplied

    # Load jumper state to all slave processors
    foreach $procS in ($hb_masterproc.get-slave-procs) {
        $procS.set-secure-jumper value = $jumperApplied
    }

}

if($machine_name == "p10_standalone") {
    run-command-file (lookup-file hbfw/standalone.simics)
} else {
    run-command-file (lookup-file hbfw/combined.simics)
}

# Populate default APSS power readings for the OCC
foreach $apss in (get-object-list -all type = apss_device) {
    ($apss)->adc_channel_val = [0x00000293, 0x00000287, 0x00000887, 0x00000877, 0x00000326, 0x000002f2, 0x00000214, 0x00000006, 0x00000003, 0x00000eb7, 0x0000001b, 0x00000013, 0x00000123, 0x000000fc, 0x000000f2, 0x00000008]
}

if($vpo_compile == "1") {
    echo "Setting up for VPO mode"
    # Manually populate the SBE to HBBL communication area since SBE isn't running in VPO
    #
    # The "Jump forward x3000 instruction"
    system_cmp0.phys_mem.set address = 0x8200000 size = 4 0x48003000
    # The version of SBE
    system_cmp0.phys_mem.set address = 0x8200004 size = 4 0x00100001
    # 0th byte: sbeBootSide 1 byte:lpcConsoleEnable 3-4 byte: cacheSizeMB (4MB)
    system_cmp0.phys_mem.set address = 0x8200008 size = 4 0x00000004
    # The size of the HBBL + 0x3000 offset
    system_cmp0.phys_mem.set address = 0x820000c size = 8 0x9000
    system_cmp0.phys_mem.set address = 0x8200014 size = 2 0x0900
    # 0th byte: numKeyAddrPair; 1-7 byte: start of the XSCOM BAR
    system_cmp0.phys_mem.set address = 0x8200016 size = 8 0x080006
    system_cmp0.phys_mem.set address = 0x820001e size = 2 0x03fc
    system_cmp0.phys_mem.set address = 0x8200020 size = 8 0x00060300

    # Now force the HBBL, HBB, and PNOR images at their respective offsets into the L3 cache.
    $root = (env PROJECT_ROOT)

    (get-master-procs)[0].l3_img.load-file (lookup-file $root+"/standalone/pnor/hbbl.bin") 0x203000
    (get-master-procs)[0].l3_img.load-file (lookup-file $root+"/standalone/staging/hbicore.bin") 0x300000
    (get-master-procs)[0].l3_img.load-file (lookup-file $root+"/standalone/pnor/VPO.pnor") 0x400000

    # Set up to run on core 1 (for testing purposes)
    system_cmp0.cpu0_0_01_0->hrmor = 0x8200000
    system_cmp0.cpu0_0_01_0->urmor = 0x8200000
    system_cmp0.cpu0_0_01_0->iar = 0
    system_cmp0.cpu0_0_01_0.enable
    system_cmp0.cpu0_0_00_0.disable
    sim->frontend_current_processor = "system_cmp0.cpu0_0_01_0"

    # A workaround to allow PVR to be set correctly (otherwise thread 1 hangs)
    set-class-attr $proc_type pvr 0x809100
}

